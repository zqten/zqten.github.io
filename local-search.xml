<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>认识论学习笔记</title>
    <link href="/2026/01/09/2026-01-09-%E8%AE%A4%E8%AF%86%E8%AE%BA/"/>
    <url>/2026/01/09/2026-01-09-%E8%AE%A4%E8%AF%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<hr /><h1 id="笛卡尔方法">笛卡尔方法</h1><p>第一条：凡事我没有明确地认识到的东西，我绝不把它当成真的接受。要小心避免轻率的判断和先入之见。</p><p>第二条：把遇到的每一个难题按照可能和必要的程度分成若干。</p><p>第三条：按次序进行思考，先从最简单、最基础、也是最容易认识的对象开始，一点一点逐步上升，直到认识最复杂的对象。</p><p>第四条：在任何情况之下，都要尽量全面地考察，尽量普遍地复查，做到确信毫无遗漏。</p><h3 id="行动准则">行动准则</h3><p>第一条：保持中庸之道，不走极端</p><p>第二条：行动上鉴定果断，如果走错了起码知道错在哪里，不反复无常。</p><p>第三条：永远只求克服自己，不求克服命运，只求改变自己的愿望，不求改变世间的秩序。我们对自身以外的事情尽了全力之后，凡事没有办到的，对于我们来说，就是绝对办不到的事情，这一条可以很好的消除<strong>痴心妄想</strong>。</p><h3 id="理性-是什么">“理性” 是什么？</h3><ul><li>它是<strong>普遍的</strong>：所有人都拥有同等的理性能力，只是使用程度或方式不同，比如每个人都能通过理性推导明白“太阳实际很大”，而非仅凭感官判断。</li><li>它是<strong>判断真理的工具</strong>：理性的作用是 “怀疑”感官和混乱思想的欺骗，通过 “普遍怀疑” 找到不可再怀疑的起点（比如“我思故我在”），再一步步推导出可靠的知识，它更像一种“正确思考的能力”。</li></ul><hr /><h1 id="休谟方法">休谟方法</h1><hr /><h1 id="康德方法">康德方法</h1><p>（认识论）我们通过时空先天框架感受到现象，通过范畴认识对象，通过知性判断和整理对象，就获得了对象的全部知识。</p><p>康德的这两大批判（纯粹理性批判、实践理性批判），实际上处理的是人类的两种能力：一种是知性，一种是意志。第三批判—《判断力批判》——处理的是情。三大批判相当于人类的知、情、意三种能力的理论，是建立在知、情、意三种能力之上的。</p><h2 id="纯粹理性批判">《纯粹理性批判》</h2><p>《纯粹理性批判》提出的总问题，也就是最终要解决的核心问题，是:smile:<strong>先天综合判断如何可能</strong>。</p><p>:star:先天：我们在一件事情发生之前就可以先天断言它。</p><p>:star:先验：除了可以先天断言之外，还是关于我们这个断言如何可能的知识。</p><p>二者的区别：先验可解释为关于先天的先天，关于先天的先天知识就是先验的知识，先验的知识比先天的知识层次更高，它是对先天知识的反思，即先天的知识如何可能。先天的还不一定是知识，它只是先于经验。我们先于经验有很多断言，比如形式逻辑，形式逻辑有很多断言是先天的，但它不一定是知识。形式逻辑不管大前提，很多错误的前提也可以合乎逻辑地推出结论。先验的知识肯定要涉及关于对象的知识，只有关于对象的知识才是真正的知识，先验的就是关于对象的知识如何可能。</p><h3 id="名词解释">名词解释</h3><p><strong>知性</strong>：其功能是加工感觉材料让其成为<strong>知识</strong></p><ul><li>核心定义：人类先天的 “经验处理能力”，负责把感性接收到的“原始素材”（比如看到的颜色、摸到的硬度），加工成有意义的“知识片段”。</li><li>关键特点：只能处理 “现象界”的经验（能通过感官感知、能验证的事物），不能超出经验范围。</li><li>例子：你看到 “红色、圆形、甜”，知性会把这些素材整合，得出 “这是苹果”的判断 —— 这就是知性的工作。</li></ul><p><strong>范畴</strong>：知性的<strong>加工模板</strong></p><ul><li>核心定义：知性自带的 12 组“先天逻辑框架”（比如量、质、关系、模态），是知性加工经验的 “工具”。</li><li>关键特点：不是从经验里学来的，是大脑 “出厂自带”的，能保证知识的普遍性（比如所有人都能用 “因果范畴” 判断“苹果掉地有原因”）。</li><li>例子：用 “因果范畴”（关系范畴的一种），把 “太阳晒” 和 “石头热”关联起来，得出 “太阳晒导致石头热” 的知识 —— 范畴就是这个“关联工具”。</li></ul><p><strong>理性</strong>：认知的 “终极追求器”</p><ul><li>核心定义：比知性更高阶的思维能力，负责把知性加工好的“知识片段”，整合为 “完整的、统一的体系”，并追求“无条件的终极解释”。</li><li>关键特点：不满足于 “零散知识”，总想找 “根源的根源”（比如从“苹果掉地” 追到 “重力”，再追到 “终极规律”）。</li><li>例子：科学家追求“统一场论”（想把所有物理规律整合为一个体系），普通人追问“宇宙的起源是什么”—— 这些都是理性的诉求。</li></ul><p><strong>纯粹理性</strong>：脱离经验的 “理性”</p><ul><li>核心定义：完全不依赖任何经验，只靠理性自身的逻辑推导，去追求“终极答案” 的思维状态。</li><li>关键特点：康德认为，纯粹理性容易 “越界”——因为它脱离了经验素材，却非要去认知“物自体”（比如上帝、灵魂、宇宙整体），最终陷入悖论。</li><li>例子：理性不依赖经验，凭空推导 “上帝必然存在”“宇宙是无限的”——这些就是纯粹理性的产物，也是康德批判的 “理性越界”。</li></ul><p><strong>理念</strong>：理性的 “终极目标概念”</p><ul><li>核心定义：纯粹理性追求的 “无条件的终极对象”，是理性构建的“理想模型”，但永远没法用经验验证（属于物自体领域）。</li><li>关键特点：不是知识（因为没有经验对应），而是理性的 “思维灯塔”——能引导知性不断探索，但不能当成 “可认知的对象”。</li><li>例子：“上帝”（终极原因的理念）、“灵魂不朽”（自我的终极理念）、“宇宙整体”（现象界的终极理念）——这些都是康德说的 “理念”。</li></ul><p>:yellow_heart:知性用范畴加工经验，产生“零散知识”；理性想把这些知识整合，就会产生“理念”（追求终极）；如果理性脱离经验，只用逻辑推导理念，就成了“纯粹理性”，最终陷入 “无限追溯” 的悖论 ——这正是康德《纯粹理性批判》的核心逻辑线。</p><p><strong>辩证法</strong>：核心是用<strong>联系、发展、矛盾</strong>的眼光看问题，不是孤立静止地判断对错。</p><ol type="1"><li>矛盾是事物发展的动力，任何事物都包含相互依存又相互对立的两面（比如“好与坏”“进步与问题”）。</li><li>事物是普遍联系的，不是孤立存在的，一个变化会带动相关事物的改变（比如环境变化影响生物生存）。</li><li>事物永远处于发展变化中，通过否定旧事物、保留合理部分，不断向新状态演进（比如技术更新迭代）。</li></ol><p>:yellow_heart:辩证法不是 “非黑即白”，而是承认事物的复杂性 ——比如一件事可能既有积极影响也有消极影响，要结合具体条件分析；同时相信变化的可能性，比如困难中可能蕴藏机遇。</p><p>《纯粹理性批判》核心就讲 3 件事，搞懂这 3点，就抓住了全书要传达的核心：</p><ol type="1"><li><strong>我们能知道什么？</strong> 只能知道“通过感官看到、摸到的现象”（比如苹果的颜色、硬度），没法知道“事物本身是什么样”（苹果的 “本质”），因为我们的认知会自带“时间、空间、范畴” 这些先天框架，就像戴有色眼镜看世界，看到的是“经过眼镜过滤的样子”，不是 “世界原本的样子”；</li><li><strong>知识怎么来的？</strong>不是光靠经验（比如只看苹果），也不是光靠理性（比如只靠想），而是“感性接收经验素材（看苹果）+ 知性用范畴加工（判断这是苹果、是甜的）”结合出来的，缺了哪一步都成不了可靠知识；</li><li><strong>理性要注意什么？</strong> 别瞎琢磨“上帝存不存在”“宇宙有没有尽头” 这类超出现象界的问题，理性一旦去碰这些“没经验支撑的事”，就会陷入自相矛盾（比如 “宇宙有开端” 和 “宇宙没开端”都能证明），所以要给理性划定边界，让它只在 “能验证的经验范围内”干活，同时为道德、信仰留下合理空间。</li></ol><p>简单说，这本书就是帮我们搞懂 “认知的规则、能力和边界”，让我们既清楚“怎么获得可靠知识”，也明白 “哪些问题不该硬钻牛角尖”。</p><p><strong>道德</strong>：对他人或社会有益的行为准则</p><p><strong>幸福</strong>：对自己有益的行为准则</p><h3 id="先验感性论">先验感性论</h3><p>​感性的形式框架就是<strong>时间和空间</strong>。任何感觉、知觉、印象，有一点是不能否认的，就是它都必须在时间和空间之中。就算承认休谟所讲的，我们能直接感觉到的只能是知觉、印象，但如果你感觉到一种红色，人家马上就会问：这红色有多大？它持续了多久？如果你说这个红色没有空间，这个红色也没有持续，那你是否感觉到了这个红色呢？人家就怀疑了。你是在说瞎话吧，你说的红色既没有空间也没有时间，那你感觉到了吗？你不可能感觉到。所以，时间和空间是人预先设定的一种感性形式结构。</p><p>​如果把时间和空间作为一种先天的直观形式，单独从知识里抽出来加以考察，就可以解决一个问题，就是数学如何可能、几何学和算术如何可能。康德时代所谓的数学包括两个方面：一个是几何学，就是关于空间的知识；一个是算术，是关于时间的知识。</p><h3 id="先验逻辑之一先验分析论">先验逻辑之一：先验分析论</h3><p>​先验逻辑、理性知识，也是一切自然科学知识之所以可能的先天条件。知识里肯定有理性层面的知识。不是说看见了红色就是知识，还要对红色做判断，光是一个感性的接受那不叫知识，只有做判断才是知识。一切知识都是判断。玫瑰花的表象、红色的表象，我们都不能说它们是对还是错，但如果说“这朵玫瑰花是红的”，那么玫瑰花是不是红的，红的是不是玫瑰花，就有对错的问题。一旦下判断就有对错的问题，但如果不下判断，不管是一个感觉的印象也好，一个知觉也好，一个概念也好，一个幻想也好，就都不存在对错的问题。</p><p>​在康德看来，知识的细胞、知识的基本要素就是判断。要做判断就要有逻辑，一切知识里面都包含判断、逻辑、理性知识。即使是经验的知识、后天的知识，也包含理性的先天知识。</p><h4 id="先验分析论之一概念分析论">先验分析论之一：概念分析论</h4><p>:star:<strong>分析</strong>：就是将一个复杂的事物拆解成多个部分，再逐一研究这些部分的属性、关系，最终理解事物整体本质或规律的过程。</p><p><strong>分析的核心目的</strong></p><ol type="1"><li><strong>化繁为简</strong>：把模糊、复杂的问题或对象，拆解成清晰、可处理的小模块，降低理解和解决的难度。</li><li><strong>找到关键</strong>：在拆解后，识别出影响事物发展或问题解决的核心要素，排除无关或次要信息。</li><li><strong>发现关联</strong>：研究各个部分之间的相互作用、因果关系等，理解它们如何共同构成并影响整体。</li></ol><p><strong>分析的常见场景</strong></p><ul><li><strong>学习场景</strong>：分析一篇文章的结构，拆解为引言、论点、论据、结论，以理解作者的核心观点。</li><li><strong>工作场景</strong>：分析一个项目的失败原因，从团队协作、资源分配、市场判断等多个维度查找问题。</li><li><strong>生活场景</strong>：分析每月开支，拆分为房租、饮食、交通等类别，找出可优化的消费项。</li></ul><p>:star:<strong>知性</strong>：其功能是加工感觉材料让其成为<strong>知识</strong>。所用的<strong>工具</strong>有（逻辑功能表）：</p><ul><li><p><strong>判断的量</strong>：全称的、特称的、单称的</p></li><li><p><strong>判断的质</strong>：肯定的、否定的、无限的</p></li><li><p><strong>判断的关系</strong>：定言的、假言的、选言的</p></li><li><p><strong>判断的模态</strong>（人思维的三个环节，第一个环节是或然的，第二个环节则实然的认为它是真的或是假的，第三个环节就是必然和无可置疑的判断。）：或然的、实然的、必然的</p></li></ul><p>:star:<strong>知性</strong>：其功能是加工感觉材料让其成为<strong>知识</strong>。其原始的<strong>综合概念</strong>有以下（范畴表）：</p><p>​康德用的时间框架来解释12种范畴，对于没有实体的概念时，在<strong>量的范畴</strong>里面需要找到概念的<strong>核心本质</strong>，<strong>质的范畴</strong>解释概念的内容（有什么，没有什么，限制什么），量和质两个范畴解释了概念<strong>是什么</strong>。对于没有实体的概念，<strong>关系范畴</strong>的实体性实际上就是该概念之所以能存在的载体（这个载体是不可消灭的，比如人只要存在就会有人的意识），因果性就是在时间中的前后相继，共联性（协同性）就是在时间中的同时性（比如作用力和反作用力）。<strong>模态的范畴</strong>里面的<strong>可能性</strong>就是讲在任意时间都会发生但此刻没有发生，存在与不存在性（现实性）实际上就是讲在此刻、当下时间存在和不存在，不是讲未来，也不是说过去。<strong>必然性</strong>这是在任意时间必然发生。</p><ul><li><strong>量的范畴</strong>：单一性、复多性、全体性</li><li><strong>质的范畴</strong>：实在性、否定性、限定性（功能性：这里可以理解成能做什么，不能做什么，有哪些限制）</li><li><strong>关系的范畴</strong>：依存性与自存性、因果性与隶属性、共联性（实体、因果、协同）</li><li><strong>模态的范畴</strong>：可能性与不可能性、存在与不存在（不是未来也不是过去，就是此刻、当下）、必然与偶然</li></ul><h5 id="范畴的演绎">范畴的演绎</h5><p>​一切我们已经形成的对象、经验都逃不了有范畴。为什么逃不了有范畴呢？因为这些范畴代表了主体的一种能动的综合能力，知识是通过人能动地综合起来才形成的。如果没有人的<strong>主体能动性</strong>，一切知识的材料都成了碎片，那就连一个梦都比不上。你要把它构成为知识，就必须有主体能动性，把知识的材料组织起来。<strong>主体能动性简单来就就是人的自我意识先验的能动作用</strong>。</p><p>​这个演绎最后追溯到的就是这个最高点——<strong>先验自我意识的统觉</strong>（指一种能动的综合作用）。</p><h5id="star利用范畴框架建立对象的全面科学的知识练习">:star:利用范畴框架建立对象的全面科学的知识练习</h5><h5 id="关于-范畴练习-的具体建议从-小对象-开始循序渐进">关于 “范畴练习”的具体建议：从 “小对象” 开始，循序渐进</h5><p>比如：</p><ol type="1"><li><strong>第一阶段（练 “量 + 质”）</strong>：每天选一个简单对象（比如“保温杯”“中性笔”），只用“量的范畴”（它由几个部分组成？是单一整体还是多个部件？）和“质的范畴”（它有什么功能？没有什么功能？功能有什么限制？）来拆解，用一两句话写下来；</li><li><strong>第二阶段（加 “关系”）</strong>：熟练后加入“关系范畴”，比如分析 “保温杯” 时，思考“它的实体是什么？（杯身）”“什么原因会让它保温效果下降？（密封垫老化）”“它需要和什么协同使用？（热水）”；</li><li><strong>第三阶段（全范畴）</strong>：最后加入 “模态范畴”，比如“保温杯可能用来装冰水吗？（可能性）”“实际装冰水后确实能保冷吗？（实然性）”“只要密封好，它必然能保冷6 小时吗？（必然性）”。</li></ol><h5 id="用范畴拆解抽象概念以-道德-为例">用范畴拆解抽象概念：以 “道德”为例</h5><ol type="1"><li><strong>量的范畴（单一 / 复多 / 全体）</strong>：<ul><li>单一性：道德的 “核心本质” 是 “对他人或社会有益的行为准则”（比如“不伤害别人” 是道德的单一核心）；</li><li>复多性：道德包含“家庭道德（孝）、社会道德（诚信）、职业道德（敬业）”等多个具体领域；</li><li>全体性：这些具体领域的道德准则，共同构成“人类社会普遍认可的道德体系”—— 先从 “核心→分支→整体”理清概念的范围。</li></ul></li><li><strong>质的范畴（实在 / 否定 / 限制）</strong>：<ul><li>实在性：道德的 “实在属性” 是“能引导人做出利他行为”（比如道德会让人主动帮助弱者）；</li><li>否定性：道德 “不包含伤害他人的行为”（比如 “欺骗、暴力”不属于道德）；</li><li>限制性：道德的作用有边界 —— 它不能强制他人遵守（比如不能用 “道德”强迫别人捐款），也不能替代法律（道德管 “该做什么”，法律管“不能做什么”）—— 明确概念的 “肯定属性、否定属性、边界范围”。</li></ul></li><li><strong>关系的范畴（实体 / 因果 / 协同）</strong>：<ul><li>实体性：道德的 “载体” 是“人的意识和社会共识”（不是具体物体，而是人脑中的观念和社会约定）；</li><li>因果性：遵守道德会带来“他人信任、社会和谐”（比如诚信待人会收获朋友），违背道德会导致“他人排斥、社会冲突”（比如欺骗会失去信任）；</li><li>协同性：道德需要和 “法律、教育” 协同作用 ——教育让人理解道德，法律约束不道德行为，三者一起维持社会秩序 ——理清概念和其他事物的 “依存、因果、配合关系”。</li></ul></li><li><strong>模态的范畴（可能 / 实然 / 必然）</strong>：<ul><li>可能性：道德 “可能随着社会发展变化”（比如古代 “女性守节”是道德，现在不认可）；</li><li>实然性：当前社会 “确实存在普遍认可的道德准则”（比如“尊重他人、诚实守信” 在多数国家都被认可）；</li><li>必然性：只要人类社会存在，“维护群体利益的道德就必然存在”（没有道德，社会会因冲突瓦解）——判断概念的 “变化可能性、当前实际状态、必然存在的条件”。</li></ul></li></ol><h5 id="再试一个用范畴拆解-贪婪">再试一个：用范畴拆解 “贪婪”</h5><ol type="1"><li><strong>量的范畴</strong>：单一性（核心是 “过度追求利益，不满足”）→复多性（表现为 “贪钱、贪权、贪名”）→ 全体性（所有过度追求的表现，统称“贪婪”）；</li><li><strong>质的范畴</strong>：实在性（会让人忽视他人利益）→否定性（不包含 “合理追求”，比如想赚钱不是贪婪，过度赚钱才是）→限制性（只存在于“有利益追求的意识活动中”，比如动物抢食物不算贪婪，因为没有 “过度”的主观意识）；</li><li><strong>关系的范畴</strong>：实体性（载体是 “人的欲望和主观意识”）→因果性（贪婪会导致 “决策失误、人际关系破裂”，比如贪钱会让人铤而走险）→协同性（贪婪需要和 “自制力缺失、价值观偏差”一起才会导致恶果，有自制力的人能克制贪婪）；</li><li><strong>模态的范畴</strong>：可能性（贪婪 “可能被教育或经历改变”）→实然性（当前社会 “确实有人因贪婪犯错”）→必然性（只要有利益存在，“贪婪的可能性就必然存在”，但不是所有人都会贪婪）。</li></ol><h4 id="先验分析论之二原理分析论">先验分析论之二：原理分析论</h4><p>​原理分析就是这些概念要按照一种什么样的原理来运用于具体对象。这个原理分析相当于形式逻辑里的判断的学说，就是说你把一个概念运用于一个经验对象，这就是在做判断；把一个纯粹概念、一个范畴运用于具体场合，这也是在做判断。康德认为，判断力是人的一种天生能力，也是一种高级能力，但是判断力不可教。一个医生在医学院里学到很多书本上的知识，这是可教的，但如何把这些东西运用到具体的临床实践中，这是不可教的，只有靠自己去练习。</p><p>​原理分析论就是要弄清楚在进行具体判断的时候是采用一种什么样的方法、什么样的原理来进行这种判断的。原理分析论是探讨范畴与经验对象间如何能够相适合，如何能把范畴运用于经验对象的这样一些原理。康德认为，这种运用需要一个中介，因为范畴来自知性，是先天的，先验的知性范畴来自主体认识的先天结构，而经验的东西来自后天，就是物自体刺激我们的感官在我们心中所造成的那些知觉、印象，所接受下来的那些感性经验的质料，这两方面结合起来才能构成知识。</p><h4 id="star纯粹知性的四大原理体系">:star:纯粹知性的四大原理体系</h4><p>康德通过图型法（架构）把范畴运用到经验对象之上，通过这种运用可以建立起一整套人为自然界立法的法规。</p><h5 id="量的原理直观的公理">量的原理——直观的公理</h5><p>​世界上的万事万物都在直观中，都处于直观的综合之中。这里其实就是把一些科学知识首先建立在<strong>定量分析</strong>之上，这才是科学的。定性分析是通过定量分析决定的。《康德哲学演讲录》里面举了个古代中医的例子，（寒、热、湿、火等），少许、若干等等，就是只有定性分析没有定量分析，所以形成不了西方意义上的科学。</p><h5 id="质的原理知觉的预测">质的原理——知觉的预测</h5><p>​这里的预测并不是无中生有那种预测，而是在质的范畴内（限制性就是在否定性和实在性之间）的预测，:smile:比如，看到一个红色，就可以预测这个红色在红色波长的<strong>量的程度</strong>，就可以判断是浅红色还是深红色，实际上就是<strong>量的一个程度</strong>所给我们的反应，质本身无法预测，但是量的程度是可以预测的，因此我们需要把质还原成量的程度。:smile:再比如，我觉得今天天气很凉，凉到什么程度我说不出来，但是用温度计我就可以说出来：今天13摄氏度，比昨天的15摄氏度降低了2度。</p><p>​可以从量的方面来测定一个事物的质，这就是知觉的预测。既然是预测，它就是按照一种规律来推算的。也有句老话叫量变引起质变。</p><h5id="关系的原理经验的类比包含实体性因果性交互性协同性">关系的原理——经验的类比，包含实体性、因果性、交互性（协同性）</h5><p>​实体性易于理解，任何事物都有它的实体性，即在时间中的持存性。这里我讲一点，比如道德、贪婪、幸福等等这些虽然没有实体性的概念，但是他们通过人（实体性）作为载体而出现的，在关系范畴的协同性里面也可以作为研究对象。</p><p>​因果性就是在时间中的相继性，当然并非所有在时间中相继的东西都具有因果性。一座房屋有左边和右边之分，我们可以从左看到右，也可以从右看到左，但是这个房子的左边并不是它右边的原因，它的右边也不是它左边的结果。我在内心的时间中可以进行这样前后相继的排列，但这样做的时候我会意识到这只是我主观的一种排法。如果要把时间的流逝看作一种客观的现象，就要运用因果性范畴。<strong>比如，船从上游到下游。</strong>先发生的事情在前，后发生的事情在后，不可能倒置，不可能倒因为果。当然，我可以不把它看作是客观的，而仅仅是主观上做游戏，我可以任意地转动我的眼球，怎么转动全由我高兴，但只要是想把看到的东西当作是客观的过程，那就要运用因果范畴。它从上游到下游，从此地到彼地，总有原因在里面，这无法否认，要将其看作客观的过程就必须用因果性范畴进行规范，至于规范得好不好、对不对，那是另外一个问题。只有用<strong>因果性范畴，才能把事物看作一个客观的流逝过程</strong>。因果性，在时间中的相继，这是人为自然界立下的又一条法规。作为客观现象，一切发生的事情都在时间中前后相继。</p><p>​如果一个事物与其他任何事物都不发生作用，那么它就是不存在的，或者至少是不可认识的，像物自体一样。凡是能够认识的事物都要跟其他事物发生作用，事物只有在交互性中才现实地存在。遥远的天体所发出的光线（通过望远镜）到达我们的眼睛，我们就能确定它的存在，因为它通过光线对我们发生了作用。我们承认，还有其他一些天体存在而没有被发现，但原则上它们是可以被我们发现的，因为它们能被我们感知到，能够作用于我们。<strong>交互性</strong>是万物存在的根本大法。恩格斯也说，<strong>交互作用</strong>是一切自然科学追踪的最终知识，在交互性之后再没有其他知识，不需要再追溯了。</p><h5id="模态的原理一般经验思维的公设">模态的原理——一般经验思维的公设</h5><p>​模态范畴与其他范畴不同，其他范畴讲的是自然界本身的构成方式，<strong>模态范畴</strong>讲的则是人（主体）对自然界（客体）采取的<strong>态度</strong>。可能的还是不可能的，现实性的还是非现实的，必然的还是偶然的，自然界本身不需要这些。自然本身有什么可能不可能、现实不现实呢？只是对人来说才有这些问题。它们是主体与客体间的关系，不是自然界本身的原理，而是<strong>认识的原理</strong>。这种主观性的态度也很重要，它把自然科学知识提升到了认识论的层面，并且在认识论中建立起了认识的界限。如“可能性一不可能性”把所有自然规律限定在可能经验的范围，超出可能经验的范围是不能认识的，认识物自体必然导致谬误。“现实性一非现实性”、“必然性—偶然性”也是这样，即超越了一定范围的知识是不现实的、偶然的。例如独断的“知识”就是不现实的，由物自体刺激人的感官所获得的感性材料，单独来看是偶然的，不是真正的知识，并将导致伪科学或非科学。模态范畴有一种超越性的作用，把知识提升到更高的层次——<strong>哲学层次</strong>，而不只是某种技术层次的分析。这是康德的先验分析论，是<strong>认识论的主体部分</strong>。</p><h3 id="先验逻辑之二先验辩证论">先验逻辑之二：先验辩证论</h3><p>​人在哪些范围为自然界立法，这是先验分析论的积极作用。超出哪些范围不能为自然界立法，即使立法也是伪科学？这就需要先验辩证论的消极作用来加以澄清。消极作用也是一种作用，一种警示、警戒的作用。先验辩证论分三个层次：先验心理学、先验宇宙论、先验神学。</p><h4 id="先验心理学谬误推理">先验心理学：谬误推理</h4><p>康德通过批判笛卡尔通过“我思故我在”来确立思维主体，并规定思维主体的属性，如能思维、感知，具有单一性（不占空间，只占时间）等。这都是凭空想出来的，他却自认为是通过逻辑推理出来的。其三段论式的推论过程如下：</p><ul><li>大前提：实体是指一切思维的主体。</li><li>小前提：我是思维的主体（我思）。</li><li>结论：我是实体（我在）。</li></ul><p>大前提中“一切思维的主体”是指在判断中作为考察的中心的主词（如“这朵花”），它是一切宾词描述的持存的对象，所以是实体，而这个主词的意思就是一个个别实在的“主体”;小前提中“我思”的“我”则是先验的我，即仅仅是一种思维所必须预设的逻辑前提（一切思维都是“我思”），因此只是一个单纯的主词，而不是实在的经验的“我”。</p><p>康德认为，灵魂不是现象世界的东西，而是自在之物<strong>（物自体）</strong>，因此，关于灵魂是什么、灵魂是灭还是不灭在理论上都是说不清楚的，是不可知的。不过，康德在否定了灵魂的可知性的同时，又一再表白，“灵魂不灭”这个论点虽然在理论上说不通，但在实践中，即在道德生活中，还是应当作为道德假设而存在。它在实践理性中有价值，但在理论理性中造成了一些<strong>谬误推理</strong>。</p><p>康德指出，理性心理学者混淆概念的原因不在于他们逻辑不熟练，他们对逻辑是非常精通的，而在于他们没有区分<strong>物自体和现象</strong>。康德对于理性心理学的批判不单纯是逻辑上的批判，而且是一种<strong>认识论和本体论</strong>上的批判，即<strong>批判他们把不可认识的东西和可以认识的东西混淆起来了</strong>。即形成了康德称为的一种<strong>“理念”</strong>，理念具有一种不可达到的超验性的特点。超验和先验是有区别的：先验的东西虽然超越于经验之上，却要应用于经验之中；而超验的东西超越于经验之上，却不能应用于经验之中，而是完全脱离经验的。:face_with_thermometer:狭义的理性要比知性更高一个层次，高到要形成一个无条件的前提，要在一切有条件的东西中去追溯这个无条件的前提，然后就陷入了形而上学的悖论（无限向上追溯）。我们对世界整体有没有一种知识？这就是理性所提出来的理念了。人的灵魂也是。所有的知识都是“我”的知识，但是对于“我”本身，我们有没有一种知识呢？主观上对于灵魂有没有一种知识呢？客观上对于整个世界宇宙有没有一种知识呢？这就提出一种理念了。<strong>理念既然脱离一切经验</strong>，它是不可能被看作一种知识的，唯理论将理念看作知识就导致了先验的“幻象”。对“我”本身的知识，就是理性心理学提出的关于灵魂的知识；其实它只是一个理念，你把它当作知识就会变成一种理性的“幻象”。</p><p>:thinking:在这里我提出一点疑问，佛家说的<strong>明心见性</strong>是不是在追求看到这个“我”呢？下面我做一个简单的回答。</p><p>佛家说的 “明心见性”，核心是 “破除‘我执’”，而不是 “找一个纯粹的‘我’”——这和理性心理学的 “找实体‘我’” 完全是反方向：</p><ol type="1"><li><strong>“心性” 不是 “实体”，而是 “离执的觉知”</strong>：佛家说的“心”，不是 “能思考的实体”，而是指 “对事物的觉知能力”；“见性” 见的是“心性本空、无固定实体” 的本质 —— 比如你看到花，“觉知花存在” 的能力是“心”，但这个 “心” 没有一个 “固定不变的自己”（不是“我有一个心，所以我能觉知”，而是“觉知本身就是心的作用，没有独立的‘心实体’”）。</li><li><strong>目标是 “破执”，不是 “求知识”</strong>：理性心理学想通过“推理” 获得 “关于‘我’的知识”（比如 “灵魂是不朽的”），而佛家 “明心见性”是通过 “修行（比如观照、禅修）”，破除 “误以为有一个固定‘我’” 的执着 ——它不是 “追求一个看不见的‘我’”，而是“发现根本没有一个固定的‘我’”，以此摆脱烦恼（因为烦恼源于“执着于‘我’的利益、感受”）。</li><li><strong>不陷入 “无限追溯”，而是“回归当下觉知”</strong>：理性心理学因为要找“无条件的‘我’”，才会无限追溯；而佛家 “明心见性” 是“在当下的觉知中，直接体认心性无执的本质”—— 不用追溯 “前提”，而是通过放下“推理、思辨”，在经验（比如呼吸、感受）中直接觉悟，和理性心理学“脱离经验搞推理” 完全不同。</li></ol><ul><li><p>理性心理学：把 “我思” 的逻辑主语，错当成“独立的‘我’实体”，想通过理性推理，获得 “关于这个实体‘我’的知识”，本质是“执着于‘有一个固定的我’，并想认知它”；</p></li><li><p>佛家 “明心见性”：通过修行发现 “没有一个固定的‘我’实体”，“心性”是无执的觉知，本质是 “破除‘有我’的执着，而不是追求‘我’”。</p></li></ul><h4 id="先验宇宙论四个二律背反">先验宇宙论：四个二律背反</h4><p>:star:<strong>二律背反</strong>：二律背反就是两个截然相反的观点各自成理，但在逻辑上又是不可并存的，是互相消灭、互相背反的。</p><p>我们可以带着这个观念去这一小节，就是这个二律背反实际上就是把<strong>现象和物自体混淆了</strong>，一个是可以经验到的知识，一个是不可以认识的。</p><p>我们可以试试通过知性范畴来获得对于宇宙的一种知识，提问如下：</p><ul><li><p>宇宙是有限的还是无限的？（量的范畴）</p><blockquote><p>理性派主张宇宙是有限的，经验派主张宇宙是无限的，他们谁也说服不了谁，康德认为是因为他们都脱离了经验的证据，有限与无限都没有证据能够证明。按照自然科学的原则，一个判断应该有它的经验的内容，但是这两种判断都脱离了经验的内容，都超出了一切可能的经验范围去对整个宇宙进行判断，所以这两方面都是错误的，宇宙既不是有限的也不是无限的。</p></blockquote></li><li><p>构成宇宙的最基本的单位是单一的还是复杂的？（质的范畴）</p><blockquote><p>要描述一种知识，就应该守住现象的领域，不要涉及不可知的物自体领域。构成宇宙的究竟是单一的还是复合的东西，这个争论同样超出了经验的范围，断言是单纯的还是复杂的都是错误的。</p></blockquote></li><li><p>宇宙中有自由还是没有<strong>自由</strong>，抑或一切都是由<strong>必然</strong>因果性决定的？（关系的范畴）</p><blockquote><p>从现象上看，宇宙的一切都合乎因果必然性，没有自由，看不到自由，这是对的；但如果从本体上看，它就可能是有自由的，这种论断你也不能说是错的。也就是说，从物自身角度来说，宇宙中是可以有自由的。比如，你把人看作一个自在之物——人作为现象也受因果律的支配，但是人作为自在之物，他有自由，只不过这种自由是一种设定，不可能用经验来证明，但用经验也反驳不了。</p><p>自由是一种理念，康德把它称为“先验自由”。我们既没办法证实它，也没办法否定它，但因此我可以允许自己设定这样一个理性的理念，虽然它在知识的范围内是没用的，但它在实践的范围内是有用的，在实践中我可以把它加以实行。一旦把它实行出来，我就成为一个自由的主体，成为一个责任主体、一个义务主体，我做的事情是好是坏你们就可以追究了。如果我没有自由意志，我的一切都是必然做出来的，那我就是个机器，机器做任何事情不管好坏都是不能追究的。所以，在实践方面，比如在道德、宗教、法律方面，自由的理念是很有用的，必须保留，而且在理论的领域也没有理由取消它。</p><p><strong>简单讲就是在宇宙中我们人的生、老、病、死都是合乎因果必然性的没有自由，但是作为物自体，我们是有自由的。所以，自由与必然的二律背反，在不同的意义上都是对的。</strong></p></blockquote></li><li><p>宇宙本身是必然存在的还是偶然存在的？（模态的范畴）</p><blockquote><p>从现象层面看，宇宙的存在是 “一串偶然因果的集合”，我们永远找不到一个“绝对必然的起点”。</p><p>理性之所以会想到 “上帝”，是因为它总想给 “偶然的现象链” 找一个“终极的必然原因”（不然因果链就会无限追溯，理性无法满足）。它只是理性为了“终结无限追溯” 而设定的 “理想概念”，不是真实存在的对象。</p><ul><li>人类的知识只能来自 “范畴 + 经验”，但 “上帝”这个概念，没有任何经验素材可以对应（我们没法用感官观察、用经验验证上帝），只是理性“脱离经验” 凭空推导出来的；</li><li>理性错把 “‘设定一个必然上帝’的逻辑需求”，当成了“‘上帝真的必然存在’的知识”，这就是 “理性越界”——把<strong>物自体</strong>领域的 “理想概念”，当成了现象界的“认知对象”，最终陷入无法证明也无法证伪的困境。</li></ul><p>实际上这个问题就是形而上学悖论的问题，无限追溯，但又无法做到，就凭人的自由意志（物自体）想象出一个可以终结追溯的理念（上帝）来。但在另外一种意义上，<strong>上帝</strong>又是有作用的，和上面的<strong>自由</strong>一样，<strong>在实践领域可以充实知识界限外的领域。</strong></p><p>康德说划定的范围是，知识只能是范畴+经验，超过这个范围就不可认知了，就是物自体了。</p></blockquote><p>先验宇宙论的二律背反是理性派与经验派之间长期争论的问题：前两个二律背反，双方都<strong>混淆了现象和物自体</strong>，因而都是错的；后两个二律背反，双方可以<strong>从现象和物自体两个不同的立场来看</strong>，因而也可以都是对的。这里关键是要注意划清一个界限：<strong>现象和物自体不可混淆</strong>。</p></li></ul><h4 id="先验神学">先验神学</h4><p>先验神学提出的理念，就是上帝存在。理性派认为看到的东西都是现象不是本质，从逻辑推出的东西才是本质的东西。虽然看不到上帝的存在，但本质上上帝是存在的，因为从形式逻辑的角度已经证明其存在，不可能不存在，否则就会导致上帝概念本身的自相矛盾。</p><p>康德把所有的这些证明归结为三种证明：目的论证明、宇宙论证明、本体论证明。</p><ul><li>目的论证明是诉诸人的一厢情愿的情感的，是不足为凭的。</li><li>宇宙论证明好像讲一点逻辑，讲一点因果性，要寻求一个充足的理由、原因的原因等。但这还是不够，它顶多能够证明世界有一种充足的理由，而不能证明世界之外有一位上帝。要从世界之内的充足理由推出世界之外的上帝，还得凭借一种违背逻辑的跳跃。</li><li>本体论从概念推出存在的一个最大的弊病就是撇开了说一个事物“存在”的必要条件，也就是经验的内容。</li></ul><p>这里康德举了一个例子：我有上帝存在的观念并不证明上帝就存在了，就像我有100块钱的观念并不证明我的口袋里就有100块钱一样。这是康德很著名的一个论证。</p><p>:star:先验感性论解决的是数学先天综合判断是如何可能的。</p><p>:star:先验逻辑分为先验分析论和先验辩证论。先验分析论就是讲自然科学如何可能的问题。</p><p>:star:先验辩证论解决的第三个问题就是以往的形而上学是如何可能的。以往的形而上学之所以可能，是因为理性派的哲学家们的一种谬误推理、一种逻辑错误。这种逻辑错误，主要是基于对现象和物自体的混淆。</p><h3 id="先验方法论">先验方法论</h3><p>要提供未来形而上学的一种可能性，就必须有一种新的方法。康德认为，通过前面的先验要素论中的有关批判，首先要在方法上进行一种训练，这就是方法论。</p><h4 id="纯粹理性的训练">1、纯粹理性的训练</h4><p>纯粹理性的训练主要有两个方面：一是独断论的训练，一是怀疑论的训练。</p><ul><li><p>独断论方面的训练就是要注意区分哲学和数学，从而排除独断论。</p></li><li><p>纯粹理性的训练必须首先在方法上经得住敲打，才能有可靠的方法去建立形而上学。</p><blockquote><p>要建立科学的形而上学、未来的形而上学，必须经过怀疑论的洗礼和锻炼。怀疑论要进行一种辩驳，凡是你想提供一种正面的定理或一种观点，它就要辩驳，指出你的反面，摧垮你的基础。要是你能够经受住怀疑论的质疑，那么你建立的未来形而上学就是可靠的；如果没有经受过怀疑论的质疑，你自以为这一切都是无可怀疑的，那么你所提供的定理或观点就会像以往的一切形而上学一样是谬误的。</p></blockquote></li></ul><p>这里康德还讲了“假设的训练”和“证明的训练”。</p><p>:star:<strong>假设的训练</strong>：我们在<strong>物自体</strong>的领域虽然不能证明什么，却并非不能做出某些假设，而是可以为了另外的<strong>非认识的目的</strong>，即<strong>为了实践的目的</strong>，而做出某些假设，如实践理性的三大悬设：意志自由、灵魂不死、上帝存在。:smile:只要我们不把这些假设视为<strong>知识</strong>，而只是视为我们为了道德和宗教的目的而建立的一些<strong>行为规范</strong>，它们就是允许的，并且是大有好处的。</p><p>:star:<strong>证明的训练</strong>：在形而上学的问题上不能单凭逻辑上的不矛盾就证明一个结论，也不能单凭逻辑上的矛盾就证伪一个结论，而必须区分<strong>现象和物自体</strong>。<strong>真正的证明，只能是在现象中有经验证据的证明，脱离了经验直观而滥用逻辑上的反证法或归谬法是无效的。</strong></p><h4 id="纯粹理性的法规">2、纯粹理性的法规</h4><p>纯粹理性的法规在认识论方面已经限定了它的范围。就是只能运用于经验和现象界。这种法规并不具有绝对的普遍性，严格来说还不是理性的法规，而只是知性的法规。范畴的运用范围也不具有绝对的普遍性，它有它的限制，它不能运用于物自体。</p><p>纯粹理性是不是有一种法规可以具有绝对的普遍性，并适用于任何对象？</p><ul><li>作为<strong>认识</strong>来看待，这种法规是没有的</li><li>作为<strong>实践</strong>的法规来看待，则是有的。纯粹理性的法规作为一种普遍的法规，只能从实践的意义上去理解，就是行动的法规。</li></ul><p>纯粹理性的法规就从<strong>认识理性</strong>过渡到<strong>实践理性</strong>，最终通过实践理性的“悬设”（即意志自由、灵魂不朽和上帝存在），达到认识和实践、幸福和道德相统一的“至善”。因此，真正的法规就是实践理性的法规，实践理性才是严格意义上的纯粹理性，它是完全不受感性的东西约束的。</p><h4id="纯粹理性的建筑术纯粹理性的整体性">3、纯粹理性的建筑术（纯粹理性的整体性）</h4><p>康德所谓的建筑术是和一般的机械的技术相对立的。建筑术不是一种技术，它有点类似于艺术，它是一个有机的整体，各方面是相互呼应、不可分割的。它跟一般的技术不一样，一般的技术就是局部的，这个地方和那个地方并拢来就够了，至于这个地方跟前提有什么关系可以不考虑。:smile:这好比一个建筑设计师跟一个泥瓦匠的区别：一个泥瓦匠在盖房子的时候砌好每一块砖，那就是一般的技术；但在建筑师心目中，每一块砖都牵涉整个建筑物。建筑物是一个有机的整体，多一块不行，少一块也不行。</p><p>康德的范畴表是非常严密的，恰好是12类范畴，多一个不行，少一个也不行，而且一旦范畴表确立，它就有很强的作用，每一个地方都要按照量、质、关系和模态这样一种形式排列。比如理性心理学、灵魂的特点，都是按照量、质、关系和模态这样一种程式来进行分析的。</p><p><strong>康德的方法论</strong>就是这样一种四个层次划分的方法，他认为这是科学方式。看待任何一个对象，比如牛顿物理学，康德在《自然科学的形而上学基础》里面也是分四章来探讨牛顿物理学的：第一章探讨动量学，第二章探讨动力学，第三章探讨力学，第四章探讨现象学。它们分别相当于<strong>量、质、关系和模态四个方面。要采取一种科学的态度，那就是这样一种态度；经过了这四个阶段，你对这个对象就完全把握了。</strong></p><h4 id="纯粹理性的历史">4. 纯粹理性的历史</h4><p>他本身是经验派和理性派的一个中和，于是他就追溯了经验派和理性派的历史。理性派他从古代追溯到柏拉图，经验派他追溯到古代的伊壁鸠鲁。用我们的话来说，就是一个是唯心主义，一个是唯物主义。康德认为，他一劳永逸地把这两派的纠纷理清了。对于伊壁鸠鲁派，虽然他不赞成，但是他认为里头有值得吸取的地方；对于柏拉图主义，虽然他出身于理性派，出身于柏拉图传统、理性传统，但是他认为柏拉图主义有待改进，有一些毛病有待克服。真正的未来形而上学必须在这两派之间保持一种平衡。</p><p>:star:先验方法论的四个层次，每一个层次都导向未来形而上学的建立。</p><h3 id="纯粹理性批判的意义">《纯粹理性批判》的意义</h3><p>康德的《纯粹理性批判》解决了什么问题？它对我们今天有什么样的意义？根据前面的讨论、分析，我们可以看出来，《纯粹理性批判》的一个很重要的观点就是<strong>现象</strong>和<strong>物自体</strong>的区分。我们的认识都只适用于现象，至于物自体，我们的认识达不到。这个结论在我们今天看来当然是荒谬的，按照马克思主义的观点，现象和物自体中间没有绝对的、必然的一条鸿沟，它是可以克服的，是可以跨越的。怎么跨越？康德没有提供跨越的手段，因为这个鸿沟是不可调和的，现象和物自体一个在此岸，一个在彼岸，但他暗示了跨越的方式，就是<strong>辩证法</strong>。</p><p>如果你把这个矛盾看作万事万物的本质，如果你认为矛盾是不可避免的而且是积极的，那么，它就提供了一种方法，可以从现象进入本质的方法。自在之物通过人的能动的实践可以变成为我之物。所谓通过能动的实践，就是要通过辩证法。通过能动的实践变成为我之物，说明自在之物并不是不可超越的。辩证法强调的是能动性，人的能动性以及能动的实践。康德已经提出人的能动性了，在人的认识领域他提出了先验自我意识的能动的统觉、综合统一。人在认识世界的时候不是被动接受的，在每一个层次上都有人的能动性，哪怕是在感性的层次上，人也不是完全被动的，不是洛克所讲的“一块白板”。人心并不是一块白板，人心有它固有的结构，有它的主体，有它的主动性。</p><p>为什么不把这两个能动性合而为一呢？认识的能动性不就是实践的能动性吗？认识也是一种实践活动嘛。但康德始终试图把这两方面区分开来，现象是现象，物自体是物自体。康德在范畴表里已经提出了第三项——既是这个，又是那个，已经开始突破二分法了。但在这个根本问题上，他还是采取了二分法，只有现象和物自体，没有第三者。</p><p>康德处处存在矛盾，他解决的方式无非就是把现象和物自体区分开，不让它们接触，他以为这样就可以避免矛盾了。他恰好暗示了后来的人，推动了辩证法的产生。积极意义上的辩证法，就是从康德那里脱颖而出的。</p><p>费希特是康德的学生，他怎么走出康德观点的呢？自然规律和道德规律不再是毫不相干的，道德律可以在自然界实现出来，你可以采用自然的手段去实现道德的目的。难道一定要“杀身成仁”、“舍生取义”吗？按照历史的规律来实现道德的目的也是可以的嘛。</p><p>后来历史主义就产生出来了，特别是<strong>黑格尔</strong>以后，历史主义着重从历史的角度来分析精神，不仅仅是人，而且是绝对精神，人是绝对精神的代表。绝对精神在历史过程中能够创造整个世界。怎样创造世界？不仅道德理念的那个彼岸世界，而且我们生活的这个现实世界，都是由人的自由的能动性创造出来的。<strong>黑格尔后来把辩证法发展为一种能动的、创造的学说。但它是从康德那里发展出来的，只不过康德把它当作一种消极的意义来看待。</strong>这可能是《纯粹理性批判》最重要的贡献。</p><p>:star:康德认为二律背反的矛盾是“理性越界的错误”，要避免；但黑格尔觉得，矛盾不是错误，而是“事物自身运动的动力”—— 比如 “存在” 和 “非存在” 的矛盾，推动出“变易”；“正题” 和 “反题” 的冲突，最终会融合成“合题”，然后合题又会成为新的正题，继续矛盾运动，这就是 “否定之否定”的辩证逻辑。</p><p>有人说，康德就像一个蓄水池，所有以往的哲学都流向他这里，所有后来的哲学都从他这里流出来。直到今天，全世界的人都公认，康德在哲学史上的地位是非常崇高的。</p><h2 id="实践理性批判">《实践理性批判》</h2><p><strong>纯粹实践理性为标准去衡量各种实践行为。</strong></p><ul><li>一般实践理性：动机来自<strong>经验欲望</strong>（饿、渴、想赚钱），目标是经验结果（填饱肚子、赚大钱），是“为了某个外在目的而行动”；</li><li>纯粹实践理性：动机来自<strong>先天法则</strong>（诚实、善良、不伤害他人），目标是“意志本身的自律”（做对的事，因为它是对的），是“为了遵循法则而行动”，不依赖任何外在经验目的。</li></ul><p>:star:<strong>先天道德法则</strong>：你的行为准则，能不能被普遍化成为所有人都遵循的法则？</p><p>这里有个方法就是说先天法则是一个<strong>检验工具</strong>，并不是内容：<strong>行为准则化----普遍化----结果是否矛盾</strong></p><p>先天道德准则不是每个人都能达到，但是他是理性人的一个最高追求，不是人人都能登顶，但“顶峰” 依然是登山者的终极目标。</p><p>康德的贡献在这里体现在为这个先天法则找到理性可依的标准，有逻辑、可验证的理性方向。</p><p>《实践理性批判》不能从感性的经验世界出发，而必须自上而下，从上面出发，再降下来。这与《纯粹理性批判》是从下面升上去不同。《实践理性批判》一开始就要从最高的地方降下来，它要从分析论中的<strong>原理分析</strong>出发——分析论中的原理分析是最高境界，然后从原理分析降下来，进入<strong>概念分析</strong>。它不叫概念分析，而叫纯粹实践理性的对象概念，其实也就是概念分析了。就是说，纯粹实践理性有了这些原理，它所作用的这个对象不是现实的感性经验的对象，而是一个概念的对象。这就是善和恶。善和恶是一对概念，康德把善恶当成对象。</p><h3id="实践理性批判与纯粹理性批判不同的程序">《实践理性批判》与《纯粹理性批判》不同的程序</h3><ul><li><p>《纯粹理性批判》是探讨知性的认识能力，人的认识能力。认识能力要从感性出发，所以它一开始是先验感性论。从感性出发上升到先验逻辑，先验逻辑包括先验分析论和先验辩证论。先验分析论分为概念分析和原理分析。这是层层上升的，从感性到知性、知性概念，再从知性概念上升到知性的原理，然后从辩证论进入知性所使用的范围和限度，最后上升到理性的各种理念。</p></li><li><p>《实践理性批判》不同，因为实践理性的出发点跟感性的世界没有关系，它涉及的是<strong>物自体</strong>的问题，涉及的是人的自由、人的实践能力、人的意志、人的欲望等问题。不是从认识出发，不需要先积累大量的经验，然后才有意志，才有欲望。人一开始就有欲望，就有意志，然后把自己的欲望和意志表现在经验世界里，体现并实现在自己的实践活动中，对感性的世界造成影响。</p></li></ul><p><strong>纯粹实践理性</strong>还有一个辩证论，谈人在实践中的两种取向——<strong>道德和幸福</strong>。两者之间，你是从幸福出发去建立自己的道德，还是从道德出发，把道德当成自己的幸福？这两种伦理学派历来争论不休。斯多葛派是主张道德本身就是幸福，认为你做了一件好事，心里肯定感到非常幸福，这就够了，至于外在的幸福，那是身外之物，不要去考虑它。这是斯多葛派的禁欲主义的道德观，也是一种理性派的道德观。而伊壁鸠鲁主义是一种经验派的道德观——幸福主义，认为幸福本身就是道德。这个二律背反如何解决呢？两派都很有道理，都振振有词，谁也驳不倒谁。康德认为，这是一个辩证的二律背反。</p><p><strong>纯粹实践理性</strong>和<strong>一般的实践理性</strong>是不一样的。一般的实践理性包括我们通常所讲的日常实践，也就是马克思所讲的那种实践，包括生产劳动、日常生活等，非常世俗化，当然也包括道德。纯粹实践理性是一般实践理性中最纯粹的部分，它仅仅包含道德。<strong>道德就是最纯粹的实践理性，它的根基是纯粹的自由意志。一般实践理性的根基是一般的欲望。欲望跟意志还不一样，欲望里面可能包含一些感性的成分，一些本能的东西。</strong>人的欲望能力里最高级的就是人的意志能力，意志能力就是纯粹实践理性。</p><p>意志是<strong>目的活动</strong>，意志先有一个有关对象的观念。这是意志和自然界的活动的一个根本区别。:smile:我要制造一个产品，这个产品还没制造出来，但我心目中已经有了一个产品的观念，我按照这个观念去制造它。这就是目的活动。这个目的活动是对象的观念在先，对象产品在后。我的行为不是由这个产品推动的，而是由这个产品的观念推动的，这个产品的观念是我的动机。</p><p>可以看出，《实践理性批判》与《纯粹理性批判》的结构有很多相似之处，但程序上是相反的。康德的“建筑术”也体现在这个方面。</p><p>做事不管符不符合外在的规律，首先要对得起人，对得起自己的良心。这是根据一种<strong>内在的目的来影响外部世界</strong>，这种能力是每个人都有的。每个人都不否认人有良心——尽管有的人否认这一点，但实际上他是不能否认的——我们经常说，人都是有良心的嘛，你问问自己的良心看。如果人真的问问自己的良心，就会发现自己本来是有这样一种纯粹实践理性的能力的。这种<strong>实践理性的能力不需要批判，我们不需要考察它何以可能，这种良心何以可能。良心直接地就在人心中，只要你不把它遮蔽，不把良心喂狗。你是一个人，你就有良心，因为你有理性。这是可以直接确定的。康德在导言里阐明的就是这个道理。</strong></p><h3 id="分析论之一原理分析">分析论之一：原理分析</h3><p>:star:实际上可以用上面的<strong>检验工具</strong>：<strong>准则----普遍化----结果</strong>。如果一个行为在这个逻辑推理中没有矛盾，他就有可以成为法则，如果有矛盾就不会成为法则。</p><h4 id="法则和准则的区分">1、法则和准则的区分</h4><p>一种是主观有效的准则，一种是对一切意志普遍有效的法则。法则是客观的、普遍的，它对任何人都有效，而准则是主观有效的。每个人的准则都是一次性的，都只适用于自私的目的，而法则是可以成为普遍的道德律的。</p><h4 id="纯粹实践理性的四条定理">2、纯粹实践理性的四条定理</h4><p>康德用了四条定理区分<strong>法则和准则</strong>：</p><ul><li><p>你不能把你现实的欲望的对象作为你的意志的动机，你的意志的动机不能建立在现实的对象上。比如功利主义。</p><blockquote><p>我们说一个人很实在、很现实，表现在什么地方呢？他讲了一大堆道德、正义，最后落实到他得到了多少利益，这就是功利主义。从功利主义的角度来衡量一个事物的好和坏、善和恶。获得最大利益的，就是好的；有损害的、受了损失的，就是不好的。</p></blockquote></li><li><p>个人的幸福也不能成为法则。幸福主义和功利主义其实是不可分的，获得功利最后还是为了实现人的幸福。幸福感也不能作为普遍的法则，因为你的幸福很可能建立在他人的痛苦之上，即使最大多数人的最大幸福也不行。</p></li><li><p>要使你个人的准则成为普遍的法则。你要能够做到，所有人都能够做到。实际上就是上面的检验工具。</p></li><li><p>使你的意志的准则任何时候都能同时成为一条普遍的立法原则。这样一条道德律，<strong>是自律而不是他律</strong>，不是为别的目的，就是为道德而道德。</p></li></ul><p>自律的原则是康德的最高原则。自由意志自己给自己立法。为什么要给自己立法？不是为了治国平天下，不是为了当皇帝，也不是为了搞好人际关系，好从中获利，而是为了<strong>自由意志能够始终是自由意志而不沦为其他目的的手段</strong>。</p><p>一个前后一贯的人才有坚定的人格，才有他自己的意志。在日常生活中，我们经常是这样的，为了现实的目的，必须适应环境，适应具体的情况。我们总是在改变我们的初衷，不能保持意志的始终一贯。但有一点是可以保持一贯的，就是为自由而自由，为意志而意志。不管选择什么，我都要自己选择，自己立定目的。我自己立定目的，坚持不懈，贯彻下去，我就是一个有意志的人。</p><p>可见，在意志中，纯粹意志是最高的，是人生的最终的意志。人必须有一个一贯的原则，而不总是片断地使用自己的自由。如果那种片断的准则支配了一切行为，那么人的一生都会在动摇，并表现出双重人格或多重人格。这看起来很灵活，其实是远远谈不上自由的。可见，在意志中，纯粹意志是最高的，是人生的最终的意志。人必须有一个一贯的原则，而不总是片断地使用自己的自由。如果那种片断的准则支配了一切行为，那么人的一生都会在动摇，并表现出双重人格或多重人格。这看起来很灵活，其实是远远谈不上自由的。</p><h4 id="演绎自律可以可能">3、演绎：自律可以可能</h4><p>:smile:这部分对<strong>道德律</strong>这个词用得比较多，我解释下：实际上这个道德律是我们人在<strong>实践过程中遵循的和上面的检验工具一样的判断框架</strong>（准则----普遍化----结果）产生出的<strong>“本来应该如何做”</strong>，这里我<strong>举个例子</strong>：比如我为了满足我的食欲，我去偷了一个包子，我自己会判断，如果把这个行为普遍化，就是说所有人为了满足食欲都去偷包子，那么就没有人做包子了，就和“我去偷包子”矛盾了，那么这个行为就不会成为法则。也就是和我上面所说的一样：先天道德准则不是每个人都能达到，但是他是理性人的一个最高追求，不是人人都能登顶，但“顶峰” 依然是登山者的终极目标。</p><p>实践理性批判中的演绎，则是考察道德律——前面讲的第三、第四条定理——如何必然地在日常的实践行为中成为纯粹意志的规定性的根据，即成为人们日常实践活动中一条必然的根据。</p><p>人在生活中很可能大多数时候都没有按良心办事，特别是在当今物欲横流的时代，但良心总在心中发出呼唤，影响我们。在不按良心办事的时候，我们会感到一种愧疚。这种愧疚有大有小，但只要是人，总会感到愧疚。这就是良心在起作用。我做这件事是伤天害理的，是不对的，但是没办法，所以我要给自己找种种理由。之所以要找种种理由，就是因为还有点愧疚，不然找理由干吗？当你抓住一个卖假货的，或是一个诈骗的，他总是会说活不下去了，家里还有孩子啊、老母啊……找各种理由来解释，因为他知道他的行为是不对的。而且他也知道他再怎么推诿，最终还是要负责的，他总是要怪罪于自己，感到愧疚。这说明良心总是在人的现实的实践活动中起作用的。</p><p>这种良心就是对自己按照道德律<strong>“本来应该如何做”</strong>的意识，也就是对自己本来可以做什么的“自由”的意识。人内心的道德律是和对自由的意识不可分割地联系着的。康德说道德律是自由的“认识理由”，<strong>我们通过心中有道德律，恰好就直接地“认识”到我们人是自由的了，哪怕我没有按照道德律做，我也意识到我“本来”是可以按照道德律做的。</strong></p><p>当自由被赋予我们时，就把我们置于这种更高的秩序中了。所以，这个法则必定不是通过经验而被给予我们的，但它却是通过自由而可能的，正是我们已经有自由了，我们才可以用我们的自由来解释道德律的可能性：我们为什么有道德律，为什么可以按照道德律来行动，仅仅是因为人是自由的。</p><h3 id="分析论之二概念分析">分析论之二：概念分析</h3><h4 id="善和恶的概念">1、善和恶的概念</h4><p>纯粹实践理性的<strong>对象</strong>相当于纯粹理性批判中的<strong>范畴</strong>。善和恶只关乎纯粹实践理性的概念，而跟它里面所包括的经验材料没有关系。这跟纯粹理性批判中的范畴不一样，范畴是不能脱离经验材料单独形成知识的，而善和恶的概念不需要经验材料，它只涉及人的动机，至于这个动机所造成的后果，则不构成善和恶的材料。康德在动机中已经预先考虑了效果。就是说，在设定动机的时候，必须把效果考虑在内，使它成为一条普遍的立法原则。这就是效果。</p><p>这里又要提一下这个检验工具：<strong>准则----普遍化----结果</strong></p><p><strong>善和恶只涉及动机</strong>，这有它的道理。这件事之所以是善或恶的，还是因为它的动机的善或恶。如果是一个自然灾害，那就没有善和恶的问题。比如，山体滑坡压死了人，没有人说这个自然灾害非常恶，没有人说这座山有罪。要有动机才能谈得上善和恶。</p><h4 id="自由的范畴表">2、自由的范畴表</h4><ul><li><p>量（执意、规范、法则）：准则----普遍化----结果</p><blockquote><p>这些范畴都是自由的，无论是<strong>执意</strong>——一开始想干什么就干什么的“执意”——还是规范。规范是自由的——不能太执意呀，在执意想干什么就干什么的时候总要碰到一些<strong>规范</strong>，规范自己的行为。我想要干一件事，要达到一定的目的，都要遵守一定的规范，所以我自愿遵守这种规范。通过遵守这种规范，我意识到有一种<strong>法则</strong>。这个法则命令我干什么，或者禁止我干什么，命令和禁止都是要求我自愿遵守。这是更高层次的自由，更高的自由范畴。</p></blockquote></li><li><p>质（践行、制止、例外）</p><blockquote><p>命令和禁止以外，我发现例外更能够发挥我的自由，我这只是一次例外，下不为例。我这次获得了这样一个例外的特许，就觉得自己的自由既不违背命令又不违背禁令，我能得到更大的自由。</p></blockquote></li><li><p>关系（与人格的关系、与人格状态的关系、人格与其他人格的状态的交互关系）</p><blockquote><ul><li>人格的每一种状态中，人都要能够使其成为自由意志的结果，能够把这种自由意志的状态考虑在动机里面。这就是与人格状态的关系，相当于因果性。</li><li>与人格的关系则相当于实体性。人有独立的人格、自由的人格，那就必须表现出一种自由的状态。</li><li>人格状态的交互关系，就是说你有一种状态要表现出来，别人也要表现自己的自由，那么相互之间就有一种交互关系，互相依存。</li></ul></blockquote></li><li><p>模态（允许的事和不允许的事、义务的事和违背义务的事、完全的义务和不完全的义务）</p><blockquote><p>在人与人的交互关系中，人们发现有些事是<strong>允许</strong>做的，有些事是<strong>不允许</strong>做的，这是必须意识到的一种关系。当允许做这件事的时候，人要意识到自己的<strong>义务</strong>；当不允许做这件事的时候，人要意识到什么是<strong>违背义务</strong>的。在具体的应用中，又有完全的义务，有不完全的义务。比如，不要害人，在任何情况下都不要害人，<strong>这是完全的义务</strong>；至于帮助别人——有能力的时候要尽量去帮助别人，没有能力的时候也可以不帮助别人——<strong>这是不完全的义务</strong>，是相对的。沉船的时候，大家各自逃命，你没有能力帮助别人，你首先要把自己的命救出来，当然你也有义务拯救别人，但这不是强制性的。完全义务和不完全义务有一点区别。</p></blockquote></li></ul><p>行为的善恶是由一些自由范畴来确立的。这个范畴表，每一项都是自由的，并且都涉及善和恶：实现了自由就是善，违背了自由就是恶。</p><p>自由的范畴表的排列是有意义的。它不是随便排列的，而是指导人们怎样在<strong>一般实践理性的活动中逐步上升到纯粹实践理性，实现真正的自由意志</strong>。人们的感性活动其实已经包含着纯粹的成分，只不过我们没有意识到而已；经过实践理性层次的提高和境界的提升，人们会越来越意识到自己的纯粹实践理性。就想我上面的笔记：这个范畴表是帮助我们登上“顶峰”的一个工具。</p><h3 id="纯粹实践理性的动机">纯粹实践理性的动机</h3><p>:star:自由意志是由情感驱动的。</p><p>意志的自由，既然是从带有更多的感性一直上升到最高的境界，上升到排除了一切感性成分的义务、为义务而义务的这样一种境界，那么它就是没有感性的。但作为感性存在的人，总要把纯粹实践理性在现实生活中实现出来（意志就是把自己的原则实现出来），总要在现实中表现出行动，那么<strong>在表现出行动的时候，就必须有一个感性的动机</strong>。道德律对人有一种震慑感，使人产生一种敬重。这种敬重是否定了人的一切世俗情感的，但它还是感性的，它立足于人是感性的存在。</p><p>人出于敬重感，做到为义务而义务，为道德而道德。但正因如此，道德的<strong>动因</strong>就是情感，而是自由意志。自由意志有一个“为”，如何才能“为”？如何为义务而义务？要有情感的驱动，要有敬重感的驱动，才能做出纯粹道德的事情。</p><p>但这种情感不是<strong>道德的源泉</strong>，而只是<strong>道德实现自身的一种动机</strong>，一种现实的手段。</p><p>道德的源泉只能是<strong>纯粹实践理性</strong>（自由意志）。</p><h3 id="纯粹实践理性的辩证论">纯粹实践理性的辩证论</h3><p>辩证论讲到两种善——<strong>幸福和德性</strong>。这两方面本来是不同的，不可混淆，但按照康德的看法，真正的<strong>至善</strong>应该同时包含这两方面。中国人讲“止于至善”，就是说没有一点人欲之私，极尽天理，其实就是在讲一种道德上的最高的善。但康德讲的至善不是这样的，它是一种<strong>完满的善</strong>，除了有道德上的高尚以外，还要善有善报。就是说，<strong>你在道德方面高尚，你也能够得到与你的道德相称的幸福</strong>。我们都希望好人一生平安，总觉得一个有道德的人如果遭遇了不幸，是不完满的，是悲剧。我们总是希望，越是有道德的人越能得到更大的幸福。如果他能够得到更大的幸福，那就是完满的了。这个意义上的至善，是幸福和道德相配。</p><p>就想我上面多次提及的检验工具：准则----普遍化----结果，你的行为是好的，但是结果可能对你不好，在康德这里就是不完满的善，如果你的行为是对别人有益，普遍化后，得到的结果也是别人的行为对你有益，那么这就是完满的善。</p><p>斯多葛派的 “道德即报偿”、康德的 “为法则而行动”、佛家的“行善即结果”，本质都是 “把道德 / 行善从‘工具性行动’变成‘终极性价值’”——过程即目的，行为即报偿，不需要外在的额外回馈，这正是人类对 “纯粹道德”的共同追求，跨越了西方哲学和东方佛学的界限。</p><p>斯多葛派和伊壁鸠鲁派都把道德和幸福的关系看作是一个分析的关系，但在康德看来，这是一个综合判断，“德福一致”是一个先天综合判断。德福一致的两个条件——灵魂不死和上帝存在——在纯粹理性批判那里已经作为一种先验的幻象被批倒了。但在实践理性批判这里又恢复了，并被作为实践理性批判的两大悬设。在这两大悬设之外还有第三大悬设，或者说最根本的悬设——自由意志。有了自由意志的人就会有信仰，所以康德认为宗教是从道德里推出来的，有了道德就一定会有宗教。但道德比宗教更基本，道德立足于人的自由意志，道德是宗教的基础（这是康德的断言）。</p><h2 id="判断力批判">《判断力批判》</h2><p><strong>判断力就是把知性运用到感性对象之上的那样一种能力。</strong></p><p>在理论理性和实践理性之间必须有一个中介，能够把有知识的人逐步引向有道德的人，通过人的知识和人的知识能力逐渐引导人意识到有自由，有执行道德律的一种能力。必须有中介，不然人的行为就无法解释。既然所有的人都不能认识人的本体，你怎么会认识的呢？所以，判断力批判的提出除补充康德人类学的缺陷以外，给前面两个批判也搭起了一个桥梁，以解释人类为什么越来越趋向于道德。</p><p>《纯粹理性批判》是关于认识论的</p><p>《实践理性批判》是关于道德以及宗教的。</p><p>《判断力批判》的主体部分是关于审美的，除了审美以外还有一个目的论——自然目的论，所以《判断力批判》分成两大部分：第一部分是审美判断力批判，第二部分是目的论判断力批判。</p><h3 id="审美判断力批判">审美判断力批判</h3><p>康德最核心的洞见 —— 人既属于 “自然界”（受必然因果支配），又属于“自由界”（有自由意志、道德法则），而审美判断力刚好填补了两者的鸿沟：</p><ol type="1"><li>自然界的经验是 “必然的、零散的”，自由界的道德是“普遍的、抽象的”，审美让 “必然” 和 “普遍” 有了衔接点；</li><li>审美时，我们在自然对象中感受到“无目的的和谐”，这种和谐会让我们隐约觉得“自然界仿佛是为了人的理性而存在的”—— 这就为“从自然的必然，过渡到自由的道德” 提供了可能；</li><li>人趋向审美，本质是在追求 “感性与理性的和谐统一”——这种统一是人的终极精神诉求：既不想只做被因果支配的“自然动物”，也不想只做被道德法则约束的“理性机器”，而审美刚好让两者完美融合，带来精神上的圆满。</li></ol><p>人趋向审美，是因为审美能带来“感性与理性的和谐愉悦”，满足精神圆满的诉求；而审美有普遍要求，是因为人类共享相同的判断力结构，且<strong>审美能连接自然与自由</strong>，是所有人都能共情的“精神桥梁”—— 这正是康德解释审美普遍性的核心逻辑。</p><h4 id="两种不同的判断力">两种不同的判断力</h4><h5 id="规定性的判断力">规定性的判断力</h5><p>知性的范畴有了，如何能够恰当地把这个范畴运用到感性对象上去？这就需要判断力。判断力本身是一种中介能力，把感性和知性连接起来。在这种场合的判断力，康德称之为“规定性”的判断力。</p><p>对具体的场合进行规定。规定性的判断力有一个特点，它是<strong>从普遍到特殊</strong>，先有普遍，然后把普遍运用于特殊的场合。康德认为，这种判断力的结果是<strong>形成知识</strong>。</p><h5 id="反思性的判断力">反思性的判断力</h5><p>先有特殊的具体的感性对象，然后从这个具体的感性对象出发，寻求一般的原则，也就是<strong>从特殊到普遍</strong>，从特殊的情况到普遍的原则，这也是判断力。这时候普遍的原则还没有，还有待去寻找，但是特殊的对象已经有了，放在你面前，你无条件地接受了这个特殊的现象，你的任务就是从中发现普遍的原则。这种判断力叫作“反思性”的判断力。</p><p>我们通常习惯于把美看作对象身上的一种客观性质，因为大家公认一朵花是美的，就像大家公认一朵花是红的一样。其实，真正的原因是大家内心都有共同的审美原则，审美是人性不可分割的一部分。我们从一个审美对象身上进行完整的观照，而不从这个对象身上取出某种东西进行规定性的判断，我们完整地把所有感性的特质尽收眼底，全身心向它敞开，沉浸于其中，力图感受到某种主观中的普遍性的东西、人性化的东西。这就是反思性的判断力。</p><p>那么，我们从审美中感到的愉快是什么东西引起来的呢？康德认为，我们的各种认识能力在全身心地投入对象的感性特质中的时候，也是在进行一种相互之间的自由协调活动。也就是说，人的直观能力、想象力、知性能力、理性能力等，在欣赏一个对象的时候相互适合，处于一种无拘无束的协调游戏之中，而这种无拘无束的游戏活动是任凭自己的自由来进行的。想象力和知性能力之间进行一种自由协调的活动，不是为了认识某个对象，而只是一种能力的活动；不需要用范畴，不需要用任何概念，它只是一种直观能力和概念能力的活动。<strong>概念和概念的能力</strong>在康德看来是不同的。比如知性的概念就是范畴，范畴的后面是<strong>自我意识能动的把握能力</strong>，这种能力本身还不是范畴，它没有固定下来。</p><p>严格说“审美判断”这个翻译是不太准确的，它容易让人想起这是对一个对象的“审查”，好像要去“看一个对象美不美”，其实审美并不是“看”一个对象是否美，而是“希望”一个对象能使我感受到美。</p><p>“这朵花是美的”是一个先天综合判断，“这朵花”里面没有包含“美”的概念，但我看到这朵花后，我就说这朵花是美的，把一个“美”的概念加到花的身上，而“美的”的意思就包含着别人也会赞同。<strong>只有你一人觉得美，那还不算美。所以，这个判断同时是先天地断言对我这个判断人人都应当认可。这是一个先天综合判断。</strong></p><h4 id="分析论之一美的分析">分析论之一：美的分析</h4><p>康德对美进行分析，仍然是按照其范畴表来进行的——他的范畴表可以说是无所不在，量、质、关系和模态这四个范畴顺次排下来。</p><h5 id="美的四个契机">美的四个契机</h5><ul><li><p>第一个契机是<strong>质</strong>的契机。我们首先考虑，审美中我们所获得的这种感受、感动的性质是怎么样的。康德分析后认为，它的性质应该是无目的的合目的性（它不是为了一个具体的目的，但它具有合目的性。）。这是质的契机。</p><blockquote><p>人的感性、人的想象力、人的知性和人的理性，全部的认识能力都会合起来了，好像是去干一件事情，但又不是去干一件事情，只是为了它们能够在一起游戏，在一起好玩。这些认识能力碰到一起后拧成了一股绳，好像是去追求某个目的，具有合目的性，但又没有具体的目的。应当撇开的有目的的活动有两类：一类是快适，另一类是善。这里的区分就是，快适和善实际上都是有目的的，比如吃一顿美餐，做成一件好事，这都是有目的性的。<strong>审美就是这样，只有无目的、无利害，才能够进行鉴赏。</strong></p></blockquote></li><li><p>第二个契机是<strong>量</strong>的契机，所谓“无概念的普遍性”。审美是有普遍性的，美的东西人人都爱。</p><blockquote><p>审美与科学知识不同的地方，就是审美的普遍性人人认同，但它不是通过概念达到的。牛顿物理学大家都承认，是因为牛顿物理学的概念具有普遍性，大家认识到的是同一个对象。《蒙娜丽莎》大家都认同，很美，但它不是通过概念，而是通过感受。所以，不认清审美的这个特点，想要通过一个概念来说明对象如何如何美，就走入误区了。</p></blockquote></li><li><p>第三个契机是关系契机。关系方面的特点是一个美的对象具有形式的合目的性，主观形式的合目的性。</p><blockquote><p>也就是说，在欣赏一个对象的时候，我们欣赏的不是它的内容，而是它的形式。</p></blockquote></li><li><p>最后一个契机是模态契机。什么是模态呢？模态是讲必然性的。</p><blockquote><p>审美有没有必然性呢？有，它的根据就是共通感。模态的契机就是基于共通感，就是说一切审美的判断，如果它是美的，都必然有一种共通感，都必然能激起一种共通感，大家都会认为它美。在达不到的情况下，我们就会争论。为什么争论？就是我们认为应该有共通感。审美应该有共通感，虽然事实上不见得有，但审美的目的是必然要趋向于共通感的。所以，<strong>共通感</strong>是审美的第四个很重要的特点。</p></blockquote></li></ul><h5 id="各认识能力的自由协调活动">各认识能力的自由协调活动</h5><p>这四个方面的契机是怎么造成的？康德做了一些说明。我们感到一个东西美，是因为诸认识能力的自由协调活动。那么，在感受美的时候，是哪些认识能力的自由协调活动？康德认为，主要是两种能力的自由协调活动：</p><p>:smile:<strong>一是想象力</strong>，<strong>一是知性</strong>。</p><p>对美的鉴赏就是<strong>想象力和知性的自由协调活动</strong>。想象力是一种直观的能力，我们看到一个东西，就可以发挥自己的想象。看到一朵红色的玫瑰花，我们可以想到很多，想到火一样的热情、太阳的热量甚至初升的朝霞，还可以想到红颜，一位美丽小姐的红润的脸，等等。我们的知性能力也伴随着这种想象力在活动，知性能力努力地把握这种想象力，把它凝聚起来。我们前面讲了，<strong>知性是形成概念的能力。但此时它不形成概念，而只是对想象力进行约束，使想象力成形。</strong></p><h4 id="分析论之二崇高的分析">分析论之二：崇高的分析</h4><p>知性提出的是范畴，是把握有限的对象的，比如一个实体、实体的原因、实体的属性、实体的交互关系，但知性不足以把握无限的对象。因此，当面对一个具体的对象时，我们可以进行审美欣赏，可以运用我们的想象力和知性来获得一种美的感受，但面对无限的对象的时候，我们的知性感到自己没有办法约束我们的想象力了，这想象力跟着无限的大海、无限的沙漠狂奔，驰骋，无拘无束。--风平浪静的时候看大海，是很单调的；太阳出来的时候大海是很美的，但那不是崇高；我们要去看大海，要看大海的本相、大海的威力，那才是崇高。</p><p>如何才能达到这样一种审美呢？必须调动你心中的另外一种能力，那就是<strong>理性</strong>。<strong>理性是把握无限的，你只有知性而理性不强，就欣赏不了崇高</strong>。理性未经锻炼，你也欣赏不了崇高。日常生活中有很多人不欣赏崇高，不欣赏崇高的自然景象，也不欣赏崇高的艺术品。像非常残酷的、血淋淋的小说，悲壮的、动人心魄的影视作品，很多人是不愿意看的。哪怕到了展览馆、美术馆，也会回避，觉得有些作品太血淋淋了，不看；看到这样的小说，哎呀，太悲惨了，不看。很多人不喜欢看《悲惨世界》，因为内容太悲惨了。</p><p>所谓的崇高，其中必须包括某种痛苦的因素，如果忍受不了这种痛苦，就欣赏不了崇高。也就是说，欣赏崇高首先要经过一种<strong>痛苦，就是知性面对无限感到无能为力的痛苦</strong>。然后，经过理性训练的人能够调动自己更高的理性能力来把握无限，他的<strong>理性</strong>与<strong>想象力</strong>达成了一种自由协调的活动。</p><p><strong>崇高主要有两种</strong>：</p><ul><li><p>一是数学的崇高</p><blockquote><p>康德举了个例子，我们欣赏埃及金字塔，在一定的距离欣赏的时候，我们可以感到埃及金字塔是美的。许多明信片上都是这样，几个金字塔按照一定的位置出现，两匹骆驼从旁边走过。这样的风景，从一定的角度拍下来是很美的。但我们走到金字塔跟前去会发现，抬头一看，看不到顶，我们的眼睛只能看到其中的一块砖。这个时候，我们已经不能把握金字塔的全貌了，我们感到的不是一种美，而是一种崇高。金字塔太大了，它以一种巨大的重量压在我们的心头，使我们有一种痛苦的感觉。这是数学的崇高，以它的体积、以它的数量的无限来压迫人。</p></blockquote></li><li><p>一是力学的崇高</p><blockquote><p>力学的崇高就是对力量的一种畏惧。</p><p>大自然的力量不如理性的力量，但是大自然的力量可以被看作是理性的力量的一种形象化的表达。如高尔基的《海燕》，呼唤“让暴风雨来得更猛烈些吧”，把大海的力量以及海燕在大海的风暴中勇敢翱翔的风度人格化了。</p></blockquote></li></ul><h4 id="审美盘点的演绎">审美盘点的演绎</h4><p>所谓演绎，就是说美的判断都是先天综合判断。先天综合判断如何可能？它的根据何在？这要从美的判断的性质入手。审美判断首先具有这样的性质：它是主观的，但看起来好像是客观的。审美判断还具有这样的性质：虽然它好像是客观的，但这种客观又是一种主观的客观。也就是说，这种客观并不是这个事物的属性，而是因为人人都感到美，都表示认同，才显得好像是“客观”的。</p><p>审美判断还有另一方面的演绎。就是说，要证明审美的普遍性，除了鉴赏的时候，有一种<strong>共通感</strong>作为我们主观中的一种先天的条件，使我们能够达成共识，在现实的社会生活中，我们还有一种客观的经验手段，使我们能够现实地达成共识，这就是艺术。这种演绎就是经验性的演绎。</p><h4 id="艺术理论">艺术理论</h4><p>略过</p><h4 id="审美判断力的辩证论">审美判断力的辩证论</h4><p>对艺术品好坏的评价，大致会形成一个标准，但在历史的发展过程中会有所改变：有的当时认为好得不得了的作品，过了几百年以后消失了，人们都不说了；有些原来人们认为是不怎么样的作品，后来突然发现是了不得的艺术品。这都有可能。但在一定的时间跨度之内，毕竟有一个<strong>相对的好坏标准、美丑标准，这些标准是通向审美的理念的</strong>。</p><p>用这种方式来解决在艺术标准方面的二律背反，到底是有标准还是没有标准呢？没有固定的标准，但是有相对的标准、有无限的标准，这就是康德的回答。</p><h3 id="目的论判断力批判">目的论判断力批判</h3><p>略过</p><p>“我就是我”。单说“我就是我”，这是认识不到“我”的。怎样才能认识到自我呢？只有把你的自我对象化。也就是说，只有把你的本质力量实现出来，去改造一个对象，在对象上打上你的<strong>意志的烙印</strong>，你是什么样的人就显现出来了。要认识一个人（包括自己）不是看他想什么、说什么，<strong>而是看他做什么，那个才是真正的他</strong>。</p><hr /><h2 id="综合三者">综合三者</h2><p>简单说，认识论的核心不是只回答 “是什么”，而是回答更根本的<strong>“人能知道什么”“人如何知道”“知道的边界在哪里”</strong> ——这三个问题贯穿了休谟、笛卡尔、康德和温伯格的思考，只是他们从不同角度给出了答案。我们用“层层递进” 的逻辑串起来，就很好理解：</p><h3 id="笛卡尔先解决-知道的基础-人得先有-可靠的认知起点">1.笛卡尔：先解决 “知道的基础”—— 人得先有 “可靠的认知起点”</h3><p>笛卡尔的时代，人们要么靠 “感官经验”（比如看到苹果是红的就信），要么靠“权威说法”（比如教会说什么就信），但这些都可能出错（感官会骗你，权威也会错）。</p><p>所以他先搞 “普遍怀疑”：怀疑一切能怀疑的 ——我看到的世界是不是真的？我是不是在做梦？甚至数学公式是不是绝对对？</p><p>最后他找到一个 “不能怀疑的起点”：<strong>“我在怀疑这件事本身不能怀疑”</strong> → 也就是“我思故我在”（我思考，说明 “我” 至少是存在的）。</p><p>基于这个起点，他再用 “理性推理”（比如从 “我存在” 推导出“上帝存在”，再推导出 “外部世界可靠”），试图搭建一套“靠理性就能确定的知识体系”。</p><p>一句话总结笛卡尔的认识论：<strong>“想知道什么，先找个绝对可靠的起点（我思），再用理性推，别轻易信感官和权威”</strong>。</p><h3 id="休谟拆笛卡尔的台-理性没那么万能经验才是根">2. 休谟：拆笛卡尔的台——“理性没那么万能，经验才是根”</h3><p>休谟是 “经验论” 代表，他直接挑战笛卡尔的 “理性至上”：</p><p>他说 “所有观念都来自感官经验”（比如 “苹果”的观念，来自你看它的颜色、摸它的硬度、尝它的味道），没有“脱离经验的理性起点”。</p><p>更狠的是，他连 “因果关系” 都怀疑：你看到 “太阳晒→石头热”，就说“太阳晒导致石头热”，但这只是 “你多次看到两者先后出现，形成的习惯联想”——你没法用理性证明“太阳晒必然导致石头热”，万一某天太阳晒了石头不热呢？</p><p>他还提出“观念的联系原则”（相似、接近、因果），说人理解事物，本质就是靠经验里的观念互相勾连。</p><p>一句话总结休谟的认识论：<strong>“人能知道的，都来自感官经验；理性只是整理经验的工具，没法搞出‘绝对必然’的知识（比如因果）”</strong>。</p><h3 id="康德调和两人-经验和理性缺一不可人自带认知框架">3. 康德：调和两人——“经验和理性缺一不可，人自带‘认知框架’”</h3><p>休谟把 “理性” 的作用贬得太低，笛卡尔又把 “理性” 抬得太高，康德出来“拉架”：</p><p>他说 “没有经验的理性是空洞的，没有理性的经验是盲目的”—— 比如你看到“苹果”（经验），但得靠大脑里“自带的认知框架”（比如时间、空间、因果性）才能理解它：你知道苹果在“空间里存在”，知道它 “现在存在、之前不存在”（时间），知道“吃了它会饱”（因果）。</p><p>这些“认知框架”（比如因果）不是来自经验（反驳休谟），也不是凭空的理性（反驳笛卡尔），而是人“先天就有的”—— 是人类理解世界的 “工具”，没有它，你连 “苹果是个东西”都理解不了。</p><p>但他也划了边界：人只能理解“经验到的现象”（比如苹果的颜色、味道），没法理解“事物本身”（比如苹果不被人感知时到底是什么样）—— 这就是 “现象界” 和“物自体” 的区别。</p><p>一句话总结康德的认识论：<strong>“人靠‘先天认知框架’（因果、时空等）整理‘感官经验’，才能获得知识；但知识有边界，只能到‘经验现象’为止”</strong>。</p><h3 id="温伯格把认识论落地-面对复杂系统得用系统思维去知道">4.温伯格：把认识论落地 ——“面对复杂系统，得用‘系统思维’去知道”</h3><p>前面三位都在谈 “人如何理解单个事物 / 抽象知识”，温伯格则聚焦“人如何理解复杂事物（比如生态、社会、技术系统）”—— 这是认识论在“复杂世界” 里的延伸。</p><p>他说，面对 “系统”（比如一个公司、一片森林），你不能像笛卡尔那样“拆成零件看”（比如只看公司的员工，不看员工间的关系），也不能像休谟那样“只靠经验联想”（比如只看森林里的树，不看树和动物、气候的关联）。</p><p>你得用 “系统思维”：关注“整体大于部分之和”（比如公司的效率，不是单个员工能力的总和，而是协作关系决定的），关注“反馈回路”（比如森林里 “兔子多→狼多→兔子少→狼少”的循环，这是复杂版的因果），关注“边界”（比如你研究森林，得先明确是研究一片树林，还是整个生态）。</p><p>一句话总结温伯格的认识论：<strong>“理解复杂系统，不能靠‘拆零件’或‘简单经验’，得看‘整体关联、动态反馈’，这是面对复杂世界的‘认知方法’”</strong>。</p><h3 id="最后串成一句话">最后串成一句话：</h3><p>从笛卡尔 “找理性起点”，到休谟 “靠经验勾连”，再到康德“用先天框架整合经验”，最后到温伯格 “用系统思维理解复杂”——认识论的核心始终是<strong>“人如何靠谱地‘知道’”</strong>，只是不同人面对不同问题（简单 vs复杂、抽象 vs 具体），给出了不同的 “认知方法”。</p>]]></content>
    
    
    <categories>
      
      <category>哲学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原理</tag>
      
      <tag>哲学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>投资学习指南</title>
    <link href="/2026/01/09/2026-01-09-%E6%8A%95%E8%B5%84%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"/>
    <url>/2026/01/09/2026-01-09-%E6%8A%95%E8%B5%84%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="投资学习指南">投资学习指南</h1><hr /><h2id="第一章投资基础知识与投资思维的建立">第一章：投资基础知识与投资思维的建立</h2><p><strong>目标</strong>：了解投资的基本概念、术语、主要资产类别和市场运作方式，树立正确的投资心态。</p><h3 id="第一节什么是投资">第一节：什么是投资？</h3><p>在开启投资之旅的初期，我们首先需要明确一个最基本的问题：<strong>什么是投资？</strong>这个问题看似简单，但清晰地理解其内涵，是构建正确投资观念的基石，也是区分投资与赌博、投机的关键。</p><h4 id="是什么-what投资的本质让钱为你工作">是什么(What)：投资的本质——让钱为你工作</h4><p><strong>投资，从本质上讲，是把今天的资源（通常是资金）投入到特定的标的中，期望在未来获得合理的回报，从而实现财富的保值和增值。</strong>这个过程不是一蹴而就的，它需要耐心、智慧和对风险的理解。</p><p>正如本杰明·格雷厄姆在其经典著作<strong>《聪明的投资者》</strong>中明确指出的：“<strong>投资操作是基于透彻的分析，确保本金安全并能获得满意回报的行为。不满足这些条件的操作就是投机。</strong>”这句话为我们清晰地划出了投资与投机的界限：</p><ul><li><strong>投资（Investment）</strong>：强调的是<strong>“分析”</strong>、<strong>“本金安全”</strong>和<strong>“满意回报”</strong>。投资者如同企业的拥有者，关注的是资产的内在价值和长期盈利能力。他们购买的是企业的一部分，期望分享企业成长的果实。例如，经过深入研究一家公司的财务状况、行业前景和管理团队后，购买其股票并长期持有，期待公司发展带来的股息和股价上涨。</li><li><strong>投机（Speculation）</strong>：则更多地关注价格的短期波动，试图从买卖差价中快速获利，其行为往往不完全基于对标的物内在价值的深入分析。例如，仅仅因为听到某个“内幕消息”或者看到某只股票短期内暴涨就跟风买入，期望快速卖出获利，这更接近投机。历史上著名的“荷兰郁金香狂热”就是一次典型的集体投机行为，最终以泡沫破裂告终。————<em>郁金香热是指17世纪30年代在荷兰对郁金香价格的高风险投资热。</em></li></ul><p><strong>《富爸爸穷爸爸》</strong>的作者罗伯特·清崎则从另一个角度阐释了投资的重要性，他强调要区分“资产”和“负债”。<strong>投资就是购买能把钱放进你口袋里的“资产”</strong>，比如能产生租金的房产、能分红的股票、能产生利息的债券等。目标是让你的钱为你工作，而不是你永远为钱工作。</p><p>而投资的魅力，很大程度上源于<strong>复利的力量</strong>。查理·芒格在其<strong>《穷查理宝典》</strong>中多次强调复利是“世界第八大奇迹”。复利，简单来说就是“利滚利”，不仅本金产生回报，之前产生的回报也会在下一期继续产生回报，像滚雪球一样，越滚越大。</p><ul><li><strong>例</strong>：假设你在30年前用1000元投资于一个年均回报率为10%的资产，并且将每年的收益再投资。30年后，这1000元会增长到约17449元。如果回报率达到15%，则会增长到约66211元。时间越长，回报率越高，复利效应就越显著。这就是为什么巴菲特能积累如此巨大财富的核心秘诀之一——他很早就开始投资，并坚持长期持有优质资产，让复利充分发挥其魔力。</li></ul><h4 id="怎么做-how如何理解和初步接触投资">怎么做(How)：如何理解和初步接触投资？</h4><p>理解了什么是投资后，“怎么做”的初步阶段并非指立刻投入真金白银，而是从思维和知识层面开始：</p><ol type="1"><li><strong>区分投资与投机</strong>：在每一次考虑投入资金前，问问自己：我是在投资还是在投机？我的决策是基于深入分析还是市场情绪？我关注的是资产的长期价值还是短期价格波动？这是实践格雷厄姆教诲的第一步。</li><li><strong>认识复利的价值</strong>：<ul><li><strong>计算与感知</strong>：尝试用计算器或电子表格模拟不同回报率和时间长度下的复利增长情况，直观感受其威力。</li><li><strong>耐心是关键</strong>：理解复利需要时间来发挥作用，这有助于培养长期持有的耐心，避免因短期市场波动而做出错误决策。正如芒格所说，获得巨额财富需要“坐等”。</li></ul></li><li><strong>学习资产的定义</strong>：在生活中辨别哪些是真正的资产（能带来现金流或增值），哪些是负债（会消耗现金流）。例如，一套用于出租的房子是资产，而一套仅仅自住且贷款压力巨大的房子，在现金流层面可能更像负债（尽管它也可能增值）。这种思维有助于你未来选择正确的投资标的。</li><li><strong>从思想上成为“所有者”</strong>：当你考虑购买一只股票时，想象自己是这家公司的部分所有者，而不仅仅是代码的买家。你会关心这家公司的产品、服务、盈利能力、竞争优势和管理层吗？这种所有者心态是价值投资的核心。</li></ol><h4 id="为什么-why我们为什么要投资">为什么(Why)：我们为什么要投资？</h4><p>理解了投资是什么以及如何初步接触后，我们还需要明确投资的动机和重要性：</p><ol type="1"><li><strong>对抗通货膨胀，实现财富保值</strong>：通货膨胀是无形的财富窃贼。如果你把钱仅仅存在银行活期，其购买力会随着时间的推移而下降。例如，30年前的100元和今天的100元，能买到的东西天差地别。通过合理的投资，我们可以期望获得超过通货膨胀率的回报，至少保持财富的实际购买力。</li><li><strong>实现财务目标，提升生活品质</strong>：无论是为了舒适的退休生活、子女的教育基金、购买房产，还是实现财务自由，投资都是达成这些长期财务目标的重要途径。仅仅依靠工资收入，对于大多数人而言，很难积累足够的财富。</li><li><strong>让财富持续增长，享受复利效应</strong>：如前所述，复利是财富增长的加速器。通过长期、持续的投资，我们可以让积累的财富产生更多的财富，实现“钱生钱”的良性循环。这不仅关乎个人的财务状况，也可能为下一代创造更好的起点。</li><li><strong>获得被动收入，增加财务安全感</strong>：成功的投资可以带来股息、租金、利息等被动收入。当被动收入足以覆盖日常开支时，你就获得了更高程度的财务自由和安全感，不必完全依赖主动工作的薪水。这正是我们要达到的“<strong>财务自由</strong>”。</li></ol><p><strong>小结</strong></p><p>总之，投资并非富人的专利，也不是遥不可及的神秘技能。它是每个人都可以学习和实践的，旨在通过智慧和耐心，让辛勤赚来的钱更好地为自己服务，从而抵御风险，实现人生不同阶段的财务目标。理解其与投机的区别，并认识到复利的巨大潜力，是我们迈向成功投资的第一步。</p><h3 id="第二节基本金融工具">第二节：基本金融工具</h3><p>在理解了投资的本质和重要性之后，我们需要认识投资世界中的基本“工具”或“积木”——也就是常见的金融资产类别。了解这些工具的特性，就像木匠了解不同木材的质地，厨师了解不同食材的风味一样，是进行有效投资的前提。本节将介绍几种最核心的金融工具：股票、债券、基金和现金等价物。</p><h4 id="一股票-stocks-equities">一、股票 (Stocks / Equities)</h4><p><strong>是什么 (What)：拥有一家公司的一部分</strong></p><p>股票，也称为股权，代表着对一家上市公司所有权的一小部分。当你购买一家公司的股票时，你就成为了这家公司的股东之一，拥有该公司相应份额的资产和利润的索取权。</p><ul><li><strong>通俗理解</strong>：想象你和朋友合伙开了一家奶茶店。如果把奶茶店的总价值分成100份，你出资购买了其中的10份，那么你就拥有这家奶茶店10%的股份（股票）。如果奶茶店赚钱了，你可以按比例分红；如果奶茶店未来发展壮大，价值提升，你持有的那10份的价值也会随之增加。</li><li><strong>现实实例</strong>：当你购买了苹果公司（AAPL）的股票，你就成为了苹果公司成千上万股东中的一员，理论上拥有了苹果公司极小一部分的所有权。</li></ul><p><strong>风险特征 (RiskCharacteristics)：高风险，高潜在回报</strong></p><ol type="1"><li><strong>市场风险 (MarketRisk)</strong>：股票价格会受到整个市场情绪、宏观经济状况（如经济增长、通货膨胀、利率变化）、政策变动等多种因素影响而波动。即使是优质公司的股票，在大盘下跌时也可能难以幸免。<ul><li><strong>历史实例</strong>：2008年全球金融危机期间，全球股市大幅下跌，许多优质公司的股票也未能幸免，市值大幅缩水。</li></ul></li><li><strong>公司特定风险 (Company-Specific Risk / IdiosyncraticRisk)</strong>：公司的经营状况、管理层决策、行业竞争、技术革新、财务丑闻等因素都可能导致其股价剧烈波动，甚至血本无归。<ul><li><strong>历史实例</strong>：曾经的通讯巨头诺基亚，由于未能适应智能手机时代的变革，股价一落千丈。安然公司（Enron）因财务造假而破产，其股票最终变得一文不值。</li></ul></li><li><strong>流动性风险 (LiquidityRisk)</strong>：对于一些小型公司或交易不活跃的股票，你可能在想卖出时找不到足够的买家，或者不得不以远低于市场公允价的价格卖出。</li><li><strong>波动性(Volatility)</strong>：股票价格的短期波动通常较大，这意味着其价值可能在短时间内大幅上涨或下跌。</li></ol><p><strong>收益特征 (ReturnCharacteristics)：资本利得与股息收入</strong></p><ol type="1"><li><strong>资本利得 (CapitalGains)</strong>：股票的主要收益来源是股价上涨带来的差价。当你以高于买入价的价格卖出股票时，所获得的利润就是资本利得。<ul><li><strong>现实实例</strong>：如果在2010年以约20美元/股的价格买入亚马逊（AMZN）的股票并持有至今（经过拆股调整），其价值已经增长了数十倍。</li></ul></li><li><strong>股息收入(Dividends)</strong>：一些盈利稳定且成熟的公司会将其部分利润以现金或股票的形式分配给股东，这就是股息。股息为投资者提供了相对稳定的现金流。<ul><li><strong>现实实例</strong>：可口可乐公司（KO）、强生公司（JNJ）等都是历史上著名的持续派发并增加股息的公司。</li></ul></li><li><strong>长期较高回报潜力</strong>：从长期历史数据来看，股票类资产通常能提供相较于其他资产类别更高的平均回报率，但同时也伴随着更高的风险。</li></ol><h4 id="二债券-bonds-fixed-income">二、债券 (Bonds / Fixed Income)</h4><p><strong>是什么 (What)：借钱给他人并获取利息</strong></p><p>债券是一种债务工具。当你购买债券时，你实际上是把钱借给债券的发行方（如政府、金融机构或企业）。发行方承诺在未来的特定日期（到期日）偿还你借出的本金，并在此期间定期或一次性支付给你约定的利息（票息）。</p><ul><li><strong>通俗理解</strong>：这就像你借钱给你的朋友，朋友承诺一年后还你本金，并且在这一年里会定期付给你一些利息作为你出借资金的报酬。</li><li><strong>现实实例</strong>：你购买了中国财政部发行的国债，意味着你把钱借给了中国政府，政府承诺到期还本付息。或者你购买了某家公司（如阿里巴巴、腾讯）发行的企业债券。</li></ul><p><strong>风险特征 (RiskCharacteristics)：相对稳健，但并非无风险</strong></p><ol type="1"><li><strong>利率风险 (Interest RateRisk)</strong>：当市场利率上升时，已发行债券的吸引力会下降（因为新发行的债券会提供更高的票息），导致其市场价格下跌。反之，利率下降则债券价格上升。<ul><li><strong>历史实例</strong>：在美联储快速加息的周期中，已发行的长期固定利率债券价格往往会承受较大压力。</li></ul></li><li><strong>信用风险/违约风险 (Credit Risk / DefaultRisk)</strong>：债券发行方可能因财务困境无法按时支付利息或偿还本金。政府债券（尤其是主权国家发行的本币债券）通常被认为信用风险较低，而公司债券（特别是评级较低的“垃圾债券”）信用风险较高。<ul><li><strong>历史实例</strong>：阿根廷曾多次出现主权债务违约。一些经营不善的公司也可能发生债券违约，如2008年金融危机中的雷曼兄弟。</li></ul></li><li><strong>通货膨胀风险 (InflationRisk)</strong>：如果通货膨胀率高于债券的票面利率，那么投资债券的实际购买力可能会下降。</li><li><strong>流动性风险</strong>：与股票类似，一些非主流或规模较小的债券可能在二级市场上交易不活跃，难以按期望价格快速变现。</li></ol><p><strong>收益特征 (ReturnCharacteristics)：固定的利息收入和本金返还</strong></p><ol type="1"><li><strong>利息收入 (CouponPayments)</strong>：债券的主要收益来自于发行方定期支付的利息。对于固定利率债券，这部分收入是可预期的。</li><li><strong>本金返还 (PrincipalRepayment)</strong>：在债券到期时，投资者可以收回其投资的本金（面值）。</li><li><strong>资本利得/损失</strong>：如果在债券到期前在二级市场交易，其价格可能会因利率波动等因素高于或低于面值，从而产生资本利得或损失。</li><li><strong>相对稳定性</strong>：相比股票，债券的收益通常更加稳定和可预测，风险也相对较低，因此常被用作投资组合中的“压舱石”。</li></ol><h4 id="三基金-funds">三、基金 (Funds)</h4><p><strong>是什么 (What)：集合投资，专家管理</strong></p><p>基金（投资基金）是将众多投资者的资金汇集起来，由专业的基金管理人进行投资管理，投向股票、债券、货币市场工具或其他资产的一种集合投资工具。投资者通过购买基金份额来间接投资于一揽子资产。</p><ul><li><strong>通俗理解</strong>：就像你参加一个“团购”，大家把钱凑在一起，请一位经验丰富的“采购专家”（基金经理）去市场上挑选和购买各种商品（股票、债券等）。你按出资比例分享最终的收益或承担损失。</li><li><strong>现实实例</strong>：<ul><li><strong>共同基金 (MutualFunds)</strong>：如国内的天弘余额宝（本质是货币市场基金）、易方达蓝筹精选混合等。</li><li><strong>交易所交易基金 (ETFs - Exchange TradedFunds)</strong>：如跟踪沪深300指数的华泰柏瑞沪深300ETF（510300），或跟踪美国标普500指数的SPDRS&amp;P 500 ETF Trust (SPY)。</li></ul></li></ul><p><strong>风险特征 (RiskCharacteristics)：分散风险，但风险水平取决于投向</strong></p><ol type="1"><li><strong>基础资产风险</strong>：基金的风险主要取决于其投资标的。股票型基金的风险类似于股票，债券型基金的风险类似于债券。</li><li><strong>管理风险 (ManagementRisk)</strong>：对于主动管理型基金，基金经理的投资决策水平直接影响基金业绩。如果基金经理判断失误，可能导致基金表现不佳。</li><li><strong>费用风险 (ExpenseRisk)</strong>：基金会收取管理费、托管费等费用，这些费用会从基金资产中扣除，直接影响投资者的实际回报。</li><li><strong>跟踪误差风险 (Tracking ErrorRisk)</strong>：对于指数基金，其目标是复制特定指数的表现，但由于各种原因（如费用、现金拖累、成分股调整等），基金表现可能与指数产生偏离。</li></ol><p><strong>收益特征 (ReturnCharacteristics)：分享组合收益，实现分散化</strong></p><ol type="1"><li><strong>分散投资(Diversification)</strong>：基金通常投资于多种资产，这有助于分散单一股票或债券的非系统性风险。对于小额投资者而言，通过基金可以轻松实现难以通过直接投资达成的资产分散。</li><li><strong>专业管理 (ProfessionalManagement)</strong>：投资者可以将资金交给专业的基金经理打理，省去了自己研究和选择具体投资标的的时间和精力（尤其对于主动型基金）。</li><li><strong>流动性较好</strong>：大多数开放式基金和ETF都具有较好的流动性，投资者可以根据基金公司的规定或市场交易规则进行申购、赎回或买卖。</li><li><strong>收益来源多样</strong>：基金的收益来源于其投资组合中股票的资本利得和股息、债券的利息收入等，扣除费用后分配给投资者或反映在基金净值的增长上。</li></ol><h4id="四现金及现金等价物-cash-and-cash-equivalents">四、现金及现金等价物(Cash and Cash Equivalents)</h4><p><strong>是什么 (What)：高度流动，本金安全</strong></p><p>现金及现金等价物是指可以直接使用的现金，以及那些具有高度流动性、易于转换为已知金额现金、且价值变动风险很小的短期投资。</p><ul><li><strong>通俗理解</strong>：就是你钱包里的现金、银行活期存款、短期内（通常三个月内）就能无损或极小损失变现的资产。</li><li><strong>现实实例</strong>：<ul><li>银行活期存款、通知存款。</li><li>货币市场基金（如余额宝、零钱通）。</li><li>短期国库券（如美国3个月期Treasury Bills）。</li><li>期限非常短的银行定期存单（CDs）。</li></ul></li></ul><p><strong>风险特征 (RiskCharacteristics)：极低风险，主要考虑通胀侵蚀</strong></p><ol type="1"><li><strong>通货膨胀风险 (InflationRisk)</strong>：这是现金及现金等价物最主要的风险。如果其收益率低于通货膨胀率，那么其实际购买力会随着时间的推移而下降。<ul><li><strong>历史实例</strong>：在高通胀时期，如上世纪70年代的美国，或近年来的某些新兴市场国家，持有大量现金意味着财富的快速缩水。</li></ul></li><li><strong>机会成本风险 (Opportunity CostRisk)</strong>：将过多资金长期配置于现金等价物，可能会错失其他高收益资产的投资机会。</li><li><strong>极低的违约风险</strong>：对于银行存款（有存款保险制度）和短期国债，本金损失的风险极低。</li></ol><p><strong>收益特征 (ReturnCharacteristics)：本金安全，收益有限</strong></p><ol type="1"><li><strong>高度安全性 (Safety ofPrincipal)</strong>：首要目标是保本。</li><li><strong>高度流动性 (HighLiquidity)</strong>：可以随时或在极短时间内转换为现金，以备不时之需或抓住突现的投资机会。</li><li><strong>较低的收益率 (LowReturns)</strong>：其收益率通常仅略高于活期存款，难以带来显著的财富增值。</li><li><strong>主要用途</strong>：通常用于满足日常开支、作为应急储备金、或在市场前景不明朗时作为资金的临时停泊港。</li></ol><p><strong>小结</strong></p><p>理解股票、债券、基金和现金等价物这四类基本的金融工具及其风险收益特征，是构建投资组合、进行资产配置的基石。它们各有优劣，适用于不同的投资目标和风险承受能力。在后续的章节中，我们将更深入地探讨如何运用这些工具。记住，<strong>“理解先于行动”</strong>，充分了解你所投资的工具，才能做出更明智的决策。</p><h3 id="第三节市场基础">第三节：市场基础</h3><p>了解了基本的投资工具后，我们还需要对这些工具进行交易的“场所”以及市场的“情绪”有一个基本的认识。本节将介绍交易所的概念、股价波动的驱动因素，以及描述市场整体趋势的术语——牛市和熊市。</p><h4 id="一什么是交易所-exchange">一、什么是交易所 (Exchange)？</h4><p><strong>是什么 (What)：金融工具的交易市场</strong></p><p><strong>交易所是一个有组织、受监管的市场，提供买卖双方进行金融工具（如股票、债券、期货、期权等）交易的平台和设施。</strong>它们为交易提供了透明度、流动性和价格发现机制。</p><ul><li><strong>通俗理解</strong>：想象一个大型的、标准化的农产品批发市场。农民（卖家）把他们的农产品（股票、债券等）带到这里，采购商（买家）也来到这里。市场提供场地、称重工具、信息公告牌（显示价格），并制定交易规则，确保交易公平有序地进行。交易所就是金融产品的“批发市场”。</li><li><strong>现实实例</strong>：<ul><li><strong>股票交易所</strong>：<ul><li><strong>纽约证券交易所(NYSE)</strong>：位于美国纽约，是全球市值最大的股票交易所之一，许多历史悠久的大型蓝筹公司在此上市，如可口可乐、强生、沃尔玛。</li><li><strong>纳斯达克证券交易所(NASDAQ)</strong>：同样位于美国，以科技股为主，如苹果、微软、亚马逊、谷歌母公司Alphabet等。</li><li><strong>上海证券交易所 (SSE)</strong> 和 <strong>深圳证券交易所(SZSE)</strong>：中国大陆的两个主要股票交易所。</li><li><strong>香港交易所(HKEX)</strong>：亚洲重要的金融中心，连接中国内地与国际市场。</li></ul></li><li><strong>债券交易所</strong>：虽然很多债券交易也通过场外市场（OTC）进行，但交易所也提供债券交易平台。</li><li><strong>期货交易所</strong>：如芝加哥商品交易所(CME)，交易农产品、能源、金属、利率、股指等期货合约。</li></ul></li></ul><p><strong>怎么做 (How)：交易所如何运作？</strong></p><ol type="1"><li><strong>挂牌上市(Listing)</strong>：公司需要满足交易所的一系列标准（如财务状况、公司治理、股权结构等）才能获准其证券（如股票）在交易所公开交易。这个过程称为首次公开募股（IPO）或上市。</li><li><strong>交易撮合 (OrderMatching)</strong>：投资者通过其经纪商（证券公司）向交易所提交买入或卖出指令。交易所的交易系统会按照价格优先、时间优先等原则，将买卖双方的订单进行匹配成交。<ul><li>例如，你想以每股10元的价格买入100股某公司股票，而另一位投资者想以每股10元的价格卖出200股该公司股票，交易所系统就会撮合你们的交易，你会买到100股，对方卖出100股。</li></ul></li><li><strong>价格发现 (PriceDiscovery)</strong>：通过众多买家和卖家的持续报价和交易，市场会形成一个相对公允的价格，反映了当前市场对该证券价值的集体判断。</li><li><strong>信息披露 (InformationDisclosure)</strong>：上市公司必须按照交易所的规定，及时、准确、完整地披露其财务报告、重大事件等可能影响股价的信息，以保证市场的透明度和公平性。</li><li><strong>监管与清算结算 (Regulation &amp; Clearing andSettlement)</strong>：交易所有自身的监管规则，并受到国家证券监管机构（如美国的SEC、中国的证监会）的监督。交易完成后，还有专门的清算和结算机构确保资金和证券的顺利交割。</li></ol><p><strong>为什么 (Why)：交易所的重要性</strong></p><ol type="1"><li><strong>提供流动性(Liquidity)</strong>：交易所汇集了大量的买家和卖家，使得投资者可以相对容易地以公允价格买入或卖出证券，提高了资产的变现能力。</li><li><strong>提高透明度(Transparency)</strong>：交易价格和交易量等信息是公开的，有助于投资者做出决策，并减少信息不对称。</li><li><strong>保证公平性(Fairness)</strong>：标准化的交易规则和监管有助于维护市场的公平竞争环境。</li><li><strong>促进资本形成 (CapitalFormation)</strong>：交易所为企业提供了一个有效的融资渠道，企业可以通过发行股票或债券筹集发展所需的资金，从而促进经济增长。</li><li><strong>风险管理 (RiskManagement)</strong>：交易所也提供如期权、期货等衍生品交易，这些工具可以被用来对冲风险。</li></ol><h4 id="二股价如何波动">二、股价如何波动？</h4><p><strong>是什么 (What)：供求关系与市场情绪的动态平衡</strong></p><p>股价的波动是股票市场最显著的特征之一。<strong>从根本上讲，股价是由该股票的供给和需求关系决定的。</strong>当想买入某只股票的人（需求）多于想卖出的人（供给）时，股价倾向于上涨；反之，则倾向于下跌。然而，影响供求关系的因素非常复杂。</p><p><strong>怎么做 (How)：驱动股价波动的因素</strong></p><ol type="1"><li><strong>公司基本面 (Company Fundamentals)</strong>：<ul><li><strong>盈利能力</strong>：公司的营收、利润增长、利润率等是核心驱动因素。盈利超预期的公司，股价通常会上涨。</li><li><strong>财务状况</strong>：负债水平、现金流、资产质量等。</li><li><strong>成长前景</strong>：新产品、新市场、行业地位、创新能力等。</li><li><strong>管理层能力与公司治理</strong>：优秀的管理团队和良好的公司治理能增强投资者信心。</li><li><strong>股息政策</strong>：稳定的股息支付通常受投资者青睐。</li><li><strong>历史实例</strong>：当苹果公司发布革命性的iPhone并持续报告强劲的季度盈利时，其股价在多年间持续上涨。相反，当一家公司爆出财务丑闻或业绩大幅下滑时，如瑞幸咖啡的财务造假事件，其股价会暴跌。</li></ul></li><li><strong>宏观经济因素 (Macroeconomic Factors)</strong>：<ul><li><strong>经济增长(GDP)</strong>：经济繁荣期，企业盈利普遍向好，股市通常表现积极。</li><li><strong>利率 (InterestRates)</strong>：利率上升会增加企业融资成本，也可能使债券等固定收益产品更具吸引力，从而对股市产生压力。反之，低利率环境通常有利于股市。</li><li><strong>通货膨胀(Inflation)</strong>：温和通胀可能伴随经济增长，但高通胀会侵蚀企业利润和消费者购买力，对股市不利。</li><li><strong>就业数据、消费者信心指数</strong>等。</li></ul></li><li><strong>行业趋势 (Industry Trends)</strong>：<ul><li>特定行业的技术革新、政策支持、竞争格局变化等都会影响该行业内公司的股价。</li><li><strong>现实实例</strong>：近年来，新能源汽车、人工智能等行业的公司由于行业前景广阔而受到市场追捧，相关股票表现强势。而传统零售业在电商冲击下可能面临压力。</li></ul></li><li><strong>市场情绪与投资者心理 (Market Sentiment and InvestorPsychology)</strong>：<ul><li><strong>《投资最重要的事》</strong>的作者霍华德·马克斯深刻地阐述了市场情绪的“钟摆效应”。他认为市场情绪像钟摆一样，在贪婪和恐惧两极之间摆动，很少停留在中间的“理性”位置。</li><li><strong>羊群效应(Herding)</strong>：投资者倾向于跟随他人的行为，无论其行为是否理性，这可能导致股价的非理性上涨（泡沫）或下跌（恐慌性抛售）。</li><li><strong>新闻与消息</strong>：重大利好或利空消息会迅速影响股价。分析师的评级调整、媒体报道、社交媒体讨论等都会影响短期市场情绪。</li><li><strong>历史实例</strong>：互联网泡沫时期（2000年前后），许多没有盈利甚至没有清晰商业模式的科技公司股价被炒到极高，最终泡沫破裂。2020年初新冠疫情爆发时，全球股市因恐慌情绪而大幅下跌。</li></ul></li><li><strong>资金流向 (Fund Flows)</strong>：<ul><li>大量资金流入股市（如机构投资者加仓、散户入场）会推高股价；资金流出则会打压股价。</li></ul></li></ol><p><strong>为什么 (Why)：理解股价波动的重要性</strong></p><ol type="1"><li><strong>认识风险与机会</strong>：理解股价波动的原因有助于投资者识别潜在的风险（如泡沫）和机会（如价值被低估的股票）。</li><li><strong>制定投资策略</strong>：长期投资者更关注公司基本面，而短期交易者可能更关注市场情绪和技术分析。理解波动有助于选择适合自己的策略。</li><li><strong>保持理性心态</strong>：认识到市场情绪的非理性波动是常态，有助于投资者在市场剧烈波动时保持冷静，避免追涨杀跌，坚持自己的投资原则。正如马克斯所强调的，控制情绪是成功投资的关键。</li><li><strong>避免被“噪音”干扰</strong>：短期股价波动中有很多是市场“噪音”，理解其驱动因素有助于我们区分哪些是真正影响公司长期价值的信息，哪些只是暂时的情绪宣泄。</li></ol><h4 id="三什么是牛市-bull-market-与熊市-bear-market">三、什么是牛市(Bull Market) 与熊市 (Bear Market)？</h4><p><strong>是什么 (What)：描述市场整体趋势的形象化表达</strong></p><p>牛市和熊市是用来描述金融市场（尤其是股票市场）整体价格趋势的术语。</p><ul><li><strong>牛市 (BullMarket)</strong>：指市场价格在一段较长时期内持续上涨的时期。通常伴随着投资者信心增强、经济前景乐观、企业盈利增长。之所以叫“牛市”，是因为公牛攻击时头往上顶，象征价格向上。</li><li><strong>熊市 (BearMarket)</strong>：指市场价格在一段较长时期内持续下跌的时期。通常伴随着投资者信心疲软、经济前景悲观、企业盈利下滑或预期下滑。之所以叫“熊市”，是因为熊攻击时掌往下拍，象征价格向下。<ul><li>一般认为，当主要市场指数从近期高点下跌20%或更多时，即可定义为进入熊市。反之，从低点上涨20%或更多则可能标志着新一轮牛市的开始。</li></ul></li></ul><p><strong>怎么做 (How)：识别牛市与熊市的特征</strong></p><p><strong>牛市特征</strong>：</p><ol type="1"><li><strong>股价普遍上涨</strong>：大多数股票价格上涨，市场指数持续创出新高。</li><li><strong>成交量放大</strong>：投资者交易活跃，市场参与度高。</li><li><strong>投资者信心高涨</strong>：市场普遍乐观，风险偏好提升，散户积极入市。</li><li><strong>经济基本面配合</strong>：通常伴随经济增长、企业盈利改善、失业率下降等积极的宏观经济数据。</li><li><strong>IPO市场活跃</strong>：更多公司选择在牛市期间上市。<ul><li><strong>历史实例</strong>：美国股市从2009年3月到2020年初，经历了一段长达十余年的大牛市。中国A股市场在2006-2007年以及2014-2015年也出现过显著的牛市行情。</li></ul></li></ol><p><strong>熊市特征</strong>：</p><ol type="1"><li><strong>股价普遍下跌</strong>：大多数股票价格下跌，市场指数持续走低。</li><li><strong>成交量可能萎缩或在恐慌时放大</strong>：初期可能成交量萎缩，因为买方意愿不强；但在恐慌性抛售阶段，成交量可能急剧放大。</li><li><strong>投资者信心低迷</strong>：市场悲观情绪弥漫，风险厌恶情绪上升，投资者纷纷离场或转向避险资产。</li><li><strong>经济基本面恶化或预期恶化</strong>：可能伴随经济衰退、企业盈利下滑、失业率上升等。</li><li><strong>利空消息频出</strong>：负面新闻更容易引发市场恐慌。<ul><li><strong>历史实例</strong>：2000-2002年的互联网泡沫破裂导致的熊市。2008年全球金融危机引发的全球性熊市。2022年，由于通胀、加息和地缘政治冲突，全球多个主要股指进入技术性熊市。</li></ul></li></ol><p><strong>为什么 (Why)：理解牛熊周期的意义</strong></p><ol type="1"><li><strong>调整投资策略</strong>：在不同的市场周期，适宜的投资策略可能不同。例如，牛市中成长型投资可能表现更好，而熊市中价值型投资或防御型资产可能更受青睐。</li><li><strong>风险管理</strong>：认识到熊市是市场周期的一部分，有助于投资者提前做好风险管理准备，避免在熊市底部因恐慌而割肉。</li><li><strong>把握投资机会</strong>：熊市往往会带来优质资产被错杀的机会。正如巴菲特所说：“在别人贪婪时恐惧，在别人恐惧时贪婪。”理解熊市的本质，才能有勇气在低谷时布局。</li><li><strong>保持长期视角</strong>：市场总是在牛熊之间转换。对于长期投资者而言，关键是穿越牛熊，而不是试图完美预测每一次转换。霍华德·马克斯也强调，我们无法准确预测市场，但可以为不同的市场环境做好准备。</li><li><strong>情绪管理</strong>：了解牛熊市是市场常态，有助于平复在牛市中的过度兴奋和在熊市中的过度沮丧，保持一颗平常心。</li></ol><p><strong>小结</strong></p><p>了解交易所的运作、股价波动的驱动因素以及牛熊市的特征，能帮助我们更好地理解市场的表象与内在逻辑，为后续的投资决策打下坚实的基础。记住，市场是复杂的，但其运行也有其基本规律和可被理解的方面。</p><h3 id="第四节基本经济概念">第四节：基本经济概念</h3><p>投资并非孤立存在，它深植于宏观经济的大背景之下。理解一些基本的经济概念，能帮助我们更好地把握市场脉搏，洞察投资机会与风险。本节将重点介绍三个与投资密切相关的核心经济指标：通货膨胀、利率和GDP，并探讨它们如何影响投资决策。正如曼昆在<strong>《经济学原理》</strong>中所阐述的，这些概念是理解经济如何运行的基础。</p><h4 id="一通货膨胀-inflation">一、通货膨胀 (Inflation)</h4><p><strong>是什么 (What)：物价总水平的持续上涨</strong></p><p><strong>通货膨胀是指在一个经济体中，商品和服务的总体价格水平在一定时期内持续、普遍地上涨的现象。</strong>换句话说，就是货币的购买力在下降，同样的钱能买到的东西变少了。</p><ul><li><strong>通俗理解</strong>：想象一下，去年你花10元能买到5个苹果，今年同样的10元只能买到4个苹果了，而且不仅仅是苹果，你常买的其他东西，比如面包、牛奶、汽油等价格也普遍上涨了，这就是通货膨胀。</li><li><strong>衡量指标</strong>：最常用的衡量通货膨胀的指标是<strong>消费者价格指数(CPI - Consumer PriceIndex)</strong>，它追踪一篮子具有代表性的消费品和服务的价格变化。此外，还有生产者价格指数(PPI) 等。</li><li><strong>现实实例</strong>：<ul><li><strong>温和通胀</strong>：大多数发达经济体通常会将2%左右的年通胀率视为健康的水平，认为这有助于刺激消费和投资。</li><li><strong>恶性通胀(Hyperinflation)</strong>：这是指通货膨胀率极高且失控的情况。例如，第一次世界大战后的德国魏玛共和国，津巴布韦在21世纪初，以及近年的委内瑞拉，都经历了货币价值急剧缩水、物价飞涨的恶性通胀，对经济和社会造成了灾难性的影响。人们甚至需要用手推车装着钞票去买面包。</li></ul></li></ul><p><strong>怎么做 (How)：通货膨胀如何产生及应对？</strong></p><p><strong>通货膨胀的成因复杂多样，主要包括：</strong></p><ol type="1"><li><strong>需求拉动型通胀 (Demand-PullInflation)</strong>：当总需求超过经济体的总供给能力时，过多的货币追逐过少的商品和服务，导致物价上涨。这通常发生在经济过热、消费和投资需求旺盛的时期。<ul><li>《经济学原理》中解释道，当总需求曲线向右移动，超过了短期总供给能力时，价格水平就会上升。</li></ul></li><li><strong>成本推动型通胀 (Cost-PushInflation)</strong>：由于生产成本上升（如原材料价格上涨、工资上涨、能源价格上涨等）导致企业提高产品价格，从而引发物价总水平上涨。<ul><li>例如，石油价格大幅上涨会导致运输成本和许多工业品成本增加，进而推高整体物价。</li></ul></li><li><strong>货币超发 (Excessive MoneySupply)</strong>：当中央银行印制过多的货币，超过了经济增长的实际需要时，会导致货币贬值，物价上涨。米尔顿·弗里德曼有句名言：“通货膨胀无论何时何地都是一种货币现象。”</li><li><strong>结构性通胀</strong>：由于经济结构失衡（如某些关键行业产能不足）导致的物价上涨。</li><li><strong>输入性通胀</strong>：对于开放经济体，如果进口商品价格大幅上涨，也会传导至国内，引发通胀。</li></ol><p><strong>投资者如何应对通货膨胀？</strong></p><ul><li><strong>投资于能够抵御通胀的资产</strong>：<ul><li><strong>股票</strong>：从长期来看，优质公司的盈利和股息增长通常能够超过通货膨胀率，因此股票被认为是较好的抗通胀资产。</li><li><strong>房地产</strong>：房地产的价值和租金通常会随着通货膨胀而上涨。</li><li><strong>大宗商品</strong>：如黄金、石油等，在通胀时期往往表现较好，因为它们本身就是构成CPI的重要部分，或者被视为价值储存手段（如黄金）。</li><li><strong>通胀保值债券 (TIPS - Treasury Inflation-ProtectedSecurities)</strong>：这类债券的本金会根据CPI进行调整，从而保护投资者免受通胀侵蚀。</li></ul></li><li><strong>避免持有过多现金</strong>：在高通胀环境下，现金的购买力会迅速缩水。</li><li><strong>关注实际回报率</strong>：即名义回报率减去通货膨胀率。投资的目标应该是获得正的实际回报。</li></ul><p><strong>为什么 (Why)：通货膨胀对投资的影响</strong></p><ol type="1"><li><strong>侵蚀投资回报</strong>：如果投资回报率低于通货膨胀率，那么投资者的实际购买力反而在下降。这是投资的首要敌人之一。</li><li><strong>影响资产定价</strong>：高通胀通常会导致更高的不确定性，增加企业的经营成本，并可能迫使央行加息，这些都会对股票和债券的估值产生负面影响。</li><li><strong>改变消费者和企业行为</strong>：在高通胀预期下，消费者可能倾向于提前消费，企业可能囤积原材料，这会进一步加剧通胀。</li><li><strong>影响不同资产类别的表现</strong>：如前所述，不同资产类别在通胀环境下的表现各异。理解通胀有助于投资者进行更合理的资产配置。</li></ol><h4 id="二利率-interest-rates">二、利率 (Interest Rates)</h4><p><strong>是什么 (What)：资金的价格</strong></p><p><strong>利率是借贷资金的价格，通常以年百分比表示。</strong>对于借款人来说，利率是他们使用资金所需支付的成本；对于贷款人（储蓄者或投资者）来说，利率是他们出借资金所能获得的回报。</p><ul><li><strong>通俗理解</strong>：就像你去银行贷款买房，银行会向你收取利息，这个利息的比例就是利率。或者你把钱存入银行，银行也会付给你利息，这也是一种利率。</li><li><strong>关键利率</strong>：<ul><li><strong>中央银行政策利率 (PolicyRate)</strong>：如美联储的联邦基金利率 (Fed FundsRate)、中国人民银行的贷款市场报价利率 (LPR)引导利率（间接通过MLF等工具影响）。这是央行调控宏观经济最重要的工具之一，会影响整个经济体系的利率水平。</li><li><strong>市场利率</strong>：如银行间拆借利率、债券收益率、抵押贷款利率等，它们会受到政策利率和市场供求关系的影响。</li></ul></li><li><strong>现实实例</strong>：<ul><li>当美联储宣布加息（提高联邦基金利率目标区间）时，意味着银行间借贷成本上升，进而会传导至企业的贷款成本和个人的消费贷款、抵押贷款利率上升。</li><li>2008年金融危机后，全球主要央行纷纷将政策利率降至历史低位（甚至负利率），以刺激经济复苏。</li></ul></li></ul><p><strong>怎么做 (How)：利率如何变动及影响？</strong></p><p><strong>利率的变动主要受以下因素影响：</strong></p><ol type="1"><li><strong>中央银行货币政策</strong>：这是最主要的决定因素。央行通过调整政策利率、存款准备金率、公开市场操作等手段来影响市场流动性和利率水平，以达到控制通胀、促进就业、稳定经济增长等目标。<ul><li>当经济过热、通胀高企时，央行通常会<strong>加息</strong>（提高利率）以抑制需求、收紧信贷。</li><li>当经济疲软、面临衰退风险时，央行通常会<strong>降息</strong>（降低利率）以刺激借贷、投资和消费。</li></ul></li><li><strong>资金供求关系</strong>：在资金市场上，如果资金需求大于供给，利率倾向于上升；反之则下降。</li><li><strong>通货膨胀预期</strong>：如果市场预期未来通胀会走高，贷款人会要求更高的名义利率以弥补购买力损失，从而推高市场利率。</li><li><strong>经济增长前景</strong>：经济增长强劲时，投资机会增多，资金需求旺盛，可能推高利率。</li><li><strong>风险溢价 (RiskPremium)</strong>：对于风险较高的借款人或投资项目，贷款人会要求更高的利率作为风险补偿。</li></ol><p><strong>利率变动对投资的影响：</strong></p><ul><li><strong>对债券市场</strong>：利率与债券价格通常呈反向关系。当利率上升时，新发行的债券票息更高，已发行的固定利率债券吸引力下降，其市场价格下跌。反之，利率下降则债券价格上涨。这是债券投资中最重要的风险之一（利率风险）。</li><li><strong>对股票市场</strong>：<ul><li><strong>融资成本</strong>：利率上升会增加企业的借贷成本，侵蚀利润，对股价不利。</li><li><strong>估值影响</strong>：在贴现现金流（DCF）等估值模型中，利率是重要的折现率。利率上升，未来现金流的现值下降，股票估值承压。</li><li><strong>经济信号</strong>：持续加息可能预示着经济降温，对企业盈利前景构成压力。反之，降息可能刺激经济。</li><li><strong>资金流向</strong>：利率上升可能使债券等固定收益资产更具吸引力，导致部分资金从股市流出。</li></ul></li><li><strong>对房地产市场</strong>：抵押贷款利率是影响购房需求和房地产价格的重要因素。利率上升，月供增加，购房能力下降，可能抑制房价。</li><li><strong>对现金及储蓄</strong>：利率上升，储蓄的回报增加；利率下降，储蓄回报减少。</li></ul><p><strong>为什么 (Why)：理解利率的重要性</strong></p><ol type="1"><li><strong>资产配置决策</strong>：利率水平和预期变动是进行大类资产配置（如在股票、债券、现金之间分配资金）时需要考虑的关键因素。</li><li><strong>评估投资风险</strong>：理解利率如何影响不同资产的价格，有助于评估投资组合的利率风险。</li><li><strong>把握经济周期</strong>：利率政策是反映和调控经济周期的重要工具。通过观察利率变动，可以感知宏观经济的温度。</li><li><strong>公司价值分析</strong>：在对公司进行估值时，利率是不可或缺的参数。</li></ol><h4 id="三国内生产总值-gdp---gross-domestic-product">三、国内生产总值(GDP - Gross Domestic Product)</h4><p><strong>是什么 (What)：衡量经济活动的总量指标</strong></p><p><strong>国内生产总值 (GDP)是指一个国家或地区在一定时期内（通常是一年或一个季度）所有最终产品和服务的市场价值总和。</strong>它是衡量一个经济体整体经济规模和健康状况最重要的指标。</p><ul><li><strong>通俗理解</strong>：GDP就像一个国家在一年内“生产出来的所有东西和提供的所有服务的总价值”。比如，生产的汽车、面包、电脑，提供的医疗服务、教育服务、理发服务等等，把它们的价值加起来（扣除中间投入）。</li><li><strong>计算方法</strong>：<ul><li><strong>支出法</strong>：GDP = 消费 (C) + 投资 (I) + 政府购买 (G) +净出口 (NX = 出口 - 进口)。这是最常用的计算方法。</li><li><strong>收入法</strong>：GDP = 工资 + 利息 + 租金 + 利润 +间接税和企业转移支付 + 折旧。</li><li><strong>生产法</strong>：从各产业增加值的角度计算。</li></ul></li><li><strong>名义GDP vs. 实际GDP</strong>：<ul><li><strong>名义GDP (NominalGDP)</strong>：用当期价格计算的GDP，包含了价格变动的因素。</li><li><strong>实际GDP (RealGDP)</strong>：用基期价格计算的GDP，剔除了价格变动的影响，更能反映真实的产出增长。我们通常更关注实际GDP增长率。</li></ul></li><li><strong>现实实例</strong>：<ul><li>中国国家统计局每季度和每年都会公布GDP数据及其增长率。例如，如果新闻报道“中国第二季度GDP同比增长6.3%”，指的就是实际GDP的增长。</li><li>美国商务部经济分析局 (BEA) 也会定期发布美国的GDP数据。</li></ul></li></ul><p><strong>怎么做 (How)：GDP如何影响投资？</strong></p><ol type="1"><li><strong>企业盈利 (Corporate Earnings)</strong>：<ul><li>GDP增长通常意味着整体经济活动扩张，企业销售额和利润随之增长。这是支撑股市长期上涨的根本动力。</li><li><strong>周期性行业</strong>（如汽车、航空、大宗商品）的盈利与GDP周期高度相关。经济扩张期，这些行业盈利大幅改善；经济衰退期，则受冲击较大。</li><li><strong>防御性行业</strong>（如公用事业、必需消费品）的盈利受GDP波动影响相对较小。</li></ul></li><li><strong>投资者信心 (Investor Confidence)</strong>：<ul><li>强劲的GDP增长数据通常会提振投资者对经济前景的信心，从而更愿意投资于风险资产如股票。</li><li>疲弱的GDP数据或经济衰退的信号则会打击信心，导致投资者转向避险资产。</li></ul></li><li><strong>就业与消费 (Employment and Consumption)</strong>：<ul><li>GDP增长与就业率正相关。高就业率意味着居民收入增加，消费能力增强，进一步推动经济增长和企业盈利。</li></ul></li><li><strong>利率与通胀预期 (Interest Rate and InflationExpectations)</strong>：<ul><li>快速的GDP增长如果伴随着通胀压力，可能促使央行加息。</li><li>GDP增长放缓或衰退则可能促使央行降息。</li></ul></li><li><strong>国际资本流动 (International Capital Flows)</strong>：<ul><li>一个国家强劲的经济增长和稳定的投资环境会吸引外国资本流入，利好本国资产价格。</li></ul></li></ol><p><strong>为什么 (Why)：理解GDP的重要性</strong></p><ol type="1"><li><strong>判断经济周期阶段</strong>：GDP增长率是判断经济处于复苏、繁荣、放缓还是衰退阶段的核心指标，这对于制定投资策略至关重要。</li><li><strong>行业选择</strong>：不同行业在经济周期的不同阶段表现各异。理解GDP及其构成，有助于投资者选择景气度较高的行业。</li><li><strong>预测企业盈利趋势</strong>：GDP是企业盈利的宏观基础。关注GDP数据有助于预测整体市场和特定行业的盈利前景。</li><li><strong>评估国家风险与机遇</strong>：对于进行全球资产配置的投资者，不同国家和地区的GDP增长状况是评估其投资潜力和风险的重要依据。</li><li><strong>理解政策走向</strong>：政府和央行的经济政策（财政政策、货币政策）通常会根据GDP等宏观经济指标进行调整。</li></ol><p><strong>小结</strong></p><p>通货膨胀、利率和GDP是理解宏观经济环境的三把钥匙。它们相互关联，共同塑造着投资市场的生态。</p><ul><li>GDP增长是经济的“发动机”，为企业盈利和资产增值提供基础。</li><li>通货膨胀是衡量“发动机”是否过热或过冷的“温度计”，直接影响购买力和投资的实际回报。</li><li>利率则是调控“发动机”转速和“温度”的“油门”和“刹车”，深刻影响各类资产的估值和资金流向。</li></ul><p>作为投资者，虽然我们无法像经济学家那样精确预测这些指标的走向，但理解它们的含义、产生机制及其对投资市场的传导路径，将帮助我们做出更明智的、基于“<strong>理解先于行动</strong>”原则的投资决策。这要求我们保持对宏观经济动态的关注，并将其融入我们的投资分析框架中。</p><h3 id="第五节核心投资理念">第五节：核心投资理念</h3><p>在掌握了基础的金融工具和市场概念之后，我们需要进一步了解一些经过时间检验、并被投资大师们所推崇的核心投资理念。这些理念如同航海图和指南针，能帮助我们在波涛汹涌的投资海洋中指引方向。本节将介绍三种主流且影响深远的投资哲学：价值投资、成长投资和指数投资，并再次强调风险与回报的辩证关系。</p><h4 id="一价值投资-value-investing">一、价值投资 (Value Investing)</h4><p><strong>是什么 (What)：寻找“物超所值”的便宜货</strong></p><p><strong>价值投资的核心思想是寻找并买入那些当前市场价格低于其内在价值（IntrinsicValue）的证券（主要是股票）。</strong>价值投资者相信，市场有时会因为非理性情绪、短期波动或信息不对称而错误地定价某些资产，从而提供了以折扣价买入优质资产的机会。他们如同在市场上寻找打折商品的精明买家。</p><p><strong>关键人物与思想：</strong></p><ul><li><strong>本杰明·格雷厄姆 (BenjaminGraham)</strong>：被誉为“价值投资之父”，其著作《证券分析》和《聪明的投资者》是价值投资的奠基之作。<ul><li><strong>安全边际 (Margin ofSafety)</strong>：这是格雷厄姆价值投资思想的基石。他强调，只有当股票的市场价格显著低于其保守估计的内在价值时，才存在足够的安全边际，以应对未来可能出现的不可预见的负面因素或估算错误。安全边际越大，投资风险越小。<ul><li><strong>通俗理解</strong>：就像建造一座桥梁，如果预计最大载重是10吨，工程师会按照15吨甚至20吨的承载能力来设计，多出来的5-10吨就是安全边际。购买股票时，如果估算内在价值是10元，那么只在股价跌到7元甚至更低时买入，这3元的差价就是安全边际。</li></ul></li><li><strong>市场先生 (Mr.Market)</strong>：格雷厄姆将市场比作一个情绪化的“市场先生”。他每天都会报出不同的价格，有时兴高采烈报出高价，有时垂头丧气报出低价。聪明的投资者不应被市场先生的情绪所左右，而是利用他的非理性报价，在其报价过低时买入，在其报价过高时考虑卖出或持有。</li></ul></li><li><strong>沃伦·巴菲特 (WarrenBuffett)</strong>：格雷厄姆最著名的学生，也是全球最成功的投资者之一。巴菲特继承并发展了价值投资理念。<ul><li><strong>“以合理的价格买入优秀的公司，远胜于以便宜的价格买入平庸的公司。”</strong>这是巴菲特对格雷厄姆思想的升华。他更强调公司的质量，即拥有持久竞争优势（“护城河”）、优秀的管理层和良好的长期增长前景的公司。</li><li><strong>能力圈 (Circle ofCompetence)</strong>：巴菲特强调投资者应该只投资于自己能够理解的行业和公司。在自己的能力圈内投资，更容易做出正确的判断。</li><li><strong>长期持有 (Long-TermHolding)</strong>：一旦以合理价格买入优秀公司的股票，巴菲特倾向于长期持有，享受公司成长带来的复利效应，而不是频繁交易。</li><li><strong>历史实例</strong>：巴菲特旗下的伯克希尔·哈撒韦公司长期持有可口可乐、美国运通、苹果等公司的股票，并从中获得了巨额回报。例如，他在1988年开始大规模买入可口可乐，正是看中了其强大的品牌、全球分销网络和持续的盈利能力，即使当时市场并未给予其极高的估值。</li></ul></li></ul><p><strong>怎么做 (How)：价值投资的实践方法</strong></p><ol type="1"><li><strong>估算内在价值</strong>：通过分析公司的财务报表、盈利能力、现金流、资产状况、行业前景、竞争优势、管理层等因素，对公司的真实价值进行评估。常用的估值方法有市盈率(P/E)、市净率 (P/B)、股息收益率、自由现金流折现 (DCF) 等。</li><li><strong>寻找安全边际</strong>：将估算出的内在价值与当前市场价格进行比较，寻找价格远低于价值的投资标的。</li><li><strong>逆向投资</strong>：价值投资者往往在市场悲观、他人抛售时寻找机会，因为此时优质资产更容易出现被低估的情况。</li><li><strong>耐心等待</strong>：市场价格回归到内在价值可能需要较长时间，价值投资者需要有足够的耐心。</li><li><strong>关注基本面而非市场情绪</strong>：不为短期市场波动所干扰，专注于公司的长期基本面。</li></ol><p><strong>为什么 (Why)：选择价值投资的理由</strong></p><ol type="1"><li><strong>风险控制</strong>：安全边际是价值投资内置的风险控制机制，旨在保护本金安全。</li><li><strong>长期稳健回报</strong>：历史证明，价值投资策略在长期内能够提供相对稳健且可观的回报。</li><li><strong>基于理性分析</strong>：价值投资强调基于事实和数据的理性分析，而非情绪驱动的投机。</li><li><strong>适合普通投资者学习</strong>：其基本原则相对清晰，通过学习和实践可以逐步掌握。</li></ol><h4 id="二成长投资-growth-investing">二、成长投资 (GrowthInvesting)</h4><p><strong>是什么 (What)：投资于高速成长的明日之星</strong></p><p><strong>成长投资的核心思想是寻找并投资于那些预期未来盈利和收入将以远超市场平均水平的速度增长的公司。</strong>成长投资者更关注公司的成长潜力和未来前景，而非当前的估值是否“便宜”。他们愿意为未来的高增长支付相对较高的价格（即较高的市盈率等估值指标）。</p><ul><li><strong>通俗理解</strong>：就像投资一个有天赋、有潜力但尚不出名的年轻运动员，期望他未来能成为超级巨星。成长投资者寻找的是那些有潜力成为行业领导者、甚至开创新行业的“潜力股”。</li></ul><p><strong>关键人物与思想：</strong></p><ul><li><strong>彼得·林奇 (PeterLynch)</strong>：传奇基金经理，曾执掌富达麦哲伦基金，取得了惊人的投资业绩。他的著作《彼得·林奇的成功投资》(OneUp On Wall Street) 和《战胜华尔街》(Beating the Street)是成长投资的经典。<ul><li><strong>投资你所了解的 (Invest in what youknow)</strong>：林奇鼓励普通投资者从自己日常生活中熟悉的产品、服务和公司中寻找投资机会。因为你可能比华尔街的分析师更早发现这些公司的成长潜力。<ul><li><strong>现实实例</strong>：如果你发现一家连锁餐厅的食物特别好、顾客盈门、分店越开越多，或者你孩子用的某款教育产品非常好用且市场需求旺盛，这些都可能是潜在的投资线索。</li></ul></li><li><strong>“Tenbagger”(十倍股)</strong>：林奇用这个词来形容那些能让投资增值十倍的股票。他擅长挖掘这类具有巨大成长空间的公司。</li><li><strong>PEG 指标 (Price/Earnings to GrowthRatio)</strong>：林奇常用PEG来衡量成长股的估值是否合理。PEG = 市盈率 /(盈利年增长率%)。一般来说，PEG低于1表示估值可能较低，PEG接近1表示估值合理，PEG高于1则可能估值偏高。他认为，对于一家年增长率为20%的公司，市盈率在20倍左右是可以接受的。</li><li><strong>关注公司故事与数字</strong>：林奇强调既要理解公司的“故事”（即其业务模式、竞争优势、成长驱动力），也要仔细分析财务“数字”（如盈利增长、负债情况、现金流等）。</li><li><strong>历史实例</strong>：林奇在麦哲伦基金期间投资了许多后来成长为巨头的公司，如沃尔玛、家得宝、星巴克（在他投资时尚未像今天这样家喻户晓）。他通过深入研究和实地调研，发现这些公司具有强大的扩张能力和市场需求。</li></ul></li></ul><p><strong>怎么做 (How)：成长投资的实践方法</strong></p><ol type="1"><li><strong>识别高成长行业与公司</strong>：关注新兴行业、技术革新带来的机会，以及在成熟行业中仍能快速增长的公司。</li><li><strong>分析成长驱动力</strong>：理解公司高增长的原因，是来自于新产品、新市场、技术壁垒、强大的品牌、优秀的管理层，还是行业顺风？这种增长是否可持续？</li><li><strong>评估盈利质量与增长持续性</strong>：关注营收增长率、利润增长率、市场份额扩大等指标。同时警惕那些仅仅依靠并购或会计技巧实现的“伪增长”。</li><li><strong>合理估值</strong>：虽然成长股估值通常较高，但仍需判断当前价格是否过度透支了未来的增长。PEG是一个有用的参考工具。</li><li><strong>持续跟踪</strong>：成长股的经营环境和竞争格局变化较快，需要持续跟踪公司的发展，一旦发现成长逻辑发生改变或增长不及预期，应及时调整。</li></ol><p><strong>为什么 (Why)：选择成长投资的理由</strong></p><ol type="1"><li><strong>高回报潜力</strong>：成功的成长股投资能带来非常可观的回报，甚至远超市场平均水平。</li><li><strong>分享时代红利</strong>：成长投资往往能抓住时代发展的脉搏，投资于代表未来的新兴产业和创新技术。</li><li><strong>令人兴奋的过程</strong>：发掘并伴随一家优秀公司从小到大成长，本身就是一件充满成就感的事情。</li></ol><h4 id="三指数投资-index-investing">三、指数投资 (Index Investing)</h4><p><strong>是什么 (What)：搭乘市场平均收益的便车</strong></p><p><strong>指数投资是一种被动投资策略，其核心思想是购买并持有能够复制特定市场指数（如标普500指数、沪深300指数）表现的投资组合（通常是指数基金或ETF）。</strong>指数投资者不试图挑选个股或预测市场时机，而是寻求获得与整个市场（或特定市场板块）相当的平均回报。</p><ul><li><strong>通俗理解</strong>：就像你不想费心去挑选哪匹马能赢得赛马比赛，于是你干脆下注“所有参赛马匹的平均表现”。指数基金就是这样一个“平均表现”的打包产品。</li></ul><p><strong>关键人物与思想：</strong></p><ul><li><strong>约翰·博格 (John Bogle)</strong>：先锋集团 (The VanguardGroup)创始人，被誉为“指数基金教父”。他大力倡导低成本的指数化投资，彻底改变了基金行业。其著作《博格长赢投资之道》(TheLittle Book of Common Sense Investing) 是指数投资的经典。<ul><li><strong>成本是关键 (“CostsMatter”)</strong>：博格反复强调，投资成本（如基金管理费、交易佣金等）是侵蚀长期回报的巨大障碍。指数基金由于是被动管理，其管理费通常远低于主动管理型基金，这使得投资者能将更多的回报留在自己口袋里。<ul><li><strong>“大海捞针？何不把整个草堆都买下来！”</strong> (Don't lookfor the needle in the haystack. Just buy the haystack!)这是博格对指数投资精髓的形象比喻。与其费力去寻找少数能战胜市场的股票或基金经理（针），不如直接买入代表整个市场（草堆）的指数基金。</li></ul></li><li><strong>均值回归 (Reversion to theMean)</strong>：博格认为，从长期来看，绝大多数主动管理型基金难以持续战胜市场平均水平。许多短期表现优异的基金，长期来看其业绩往往会回归到市场平均值附近，甚至更差（扣除费用后）。</li><li><strong>简单即是美(Simplicity)</strong>：指数投资策略简单易懂，容易执行，不需要复杂的分析和频繁的操作。</li><li><strong>历史实例</strong>：先锋集团发行的标普500指数基金 (VFINX 或VOO ETF)是全球规模最大、最受欢迎的指数基金之一。在过去的几十年里，它为投资者提供了与美国大盘股市场相当的稳健回报，并且其费率极低。巴菲特也多次在公开场合推荐普通投资者选择低成本的标普500指数基金作为长期投资的主要方式。</li></ul></li></ul><p><strong>怎么做 (How)：指数投资的实践方法</strong></p><ol type="1"><li><strong>选择合适的指数</strong>：根据自己的投资目标和风险承受能力，选择想要跟踪的指数。可以是宽基指数（如标普500、沪深300、MSCI全球指数），也可以是行业指数、风格指数（如成长指数、价值指数）或债券指数等。</li><li><strong>选择低成本的指数基金或ETF</strong>：比较不同基金公司提供的同类指数产品的费率（管理费、托管费、跟踪误差等），选择费率最低、跟踪效果最好的产品。</li><li><strong>长期持有与定期投资</strong>：指数投资的核心是长期持有，分享市场长期增长的红利。通过定期定额投资（基金定投）的方式，可以平滑市场短期波动的影响，降低择时风险。</li><li><strong>保持纪律，避免情绪干扰</strong>：不要因为市场短期涨跌而频繁买卖指数基金。坚持既定的投资计划。</li></ol><p><strong>为什么 (Why)：选择指数投资的理由</strong></p><ol type="1"><li><strong>低成本</strong>：指数基金的费率通常远低于主动管理型基金，能显著提高长期回报。</li><li><strong>分散风险</strong>：通过一只指数基金就能投资于一篮子股票（或债券），有效分散了个股风险。</li><li><strong>省时省力</strong>：不需要花费大量时间和精力去研究个股和市场时机。</li><li><strong>大概率跑赢多数主动基金</strong>：大量研究数据表明，从长期来看，绝大多数主动管理型基金在扣除费用后难以持续战胜其基准指数。</li><li><strong>适合绝大多数普通投资者</strong>：对于缺乏专业知识和时间的普通投资者而言，指数投资是一种简单、有效、低成本的长期投资方式。</li></ol><h4 id="四风险与回报的关系-risk-and-return">四、风险与回报的关系 (Riskand Return)</h4><p><strong>是什么 (What)：投资世界永恒的权衡</strong></p><p><strong>风险与回报是投资中形影不离的两个方面，它们之间通常存在正相关关系：即追求越高的潜在回报，通常也需要承担越高的潜在风险。反之，风险较低的投资，其预期回报也往往较低。</strong>这并不意味着承担高风险就一定能获得高回报，高风险也可能意味着高损失。</p><ul><li><strong>通俗理解</strong>：就像你想爬一座高山，山越高，风景越壮丽（高回报），但攀登的难度和危险性也越大（高风险）。选择爬一座小土丘，风险很小，但看到的风景也有限（低回报）。</li><li><strong>没有免费的午餐 (No FreeLunch)</strong>：这是经济学和投资学的基本原则。如果有人向你推销一种“高回报、低风险”甚至“无风险”的投资产品，你一定要高度警惕，这往往是骗局或误导。</li></ul><p><strong>怎么做 (How)：理解和管理风险与回报</strong></p><ol type="1"><li><strong>识别不同资产的风险回报特征</strong>：如前几节所述，现金风险最低、回报也最低；债券风险和回报居中；股票风险最高、长期潜在回报也最高。</li><li><strong>了解自身的风险承受能力</strong>：这是进行投资决策的前提。你的年龄、财务状况、投资目标、投资期限、心理素质等都会影响你能承受的风险水平。</li><li><strong>资产配置 (AssetAllocation)</strong>：通过将资金分散投资于不同风险回报特征的资产类别（如股票、债券、现金），构建一个符合自身风险承受能力的投资组合。这是管理风险、争取合理回报的核心策略。</li><li><strong>分散投资(Diversification)</strong>：“不要把所有鸡蛋放在一个篮子里。”在同一资产类别内部（如投资多只不同行业、不同风格的股票）以及不同资产类别之间进行分散，可以降低整体投资组合的非系统性风险。</li><li><strong>理解不同投资理念的风险侧重</strong>：<ul><li><strong>价值投资</strong>：通过安全边际来控制风险，认为最大的风险是“买贵了”。</li><li><strong>成长投资</strong>：风险在于成长不及预期或为高成长支付了过高的价格。</li><li><strong>指数投资</strong>：承担的是整个市场的系统性风险，放弃了获取超额收益的机会，但也避免了选错股或择时失败的风险。</li></ul></li><li><strong>长期投资视角</strong>：对于高风险资产（如股票），长期持有可以平滑短期波动，提高获得正回报的概率。</li></ol><p><strong>为什么 (Why)：理解风险回报关系的重要性</strong></p><ol type="1"><li><strong>设定合理的预期</strong>：帮助投资者对不同投资的潜在回报和可能面临的风险有一个现实的预期，避免不切实际的幻想。</li><li><strong>做出明智的决策</strong>：在了解自身风险偏好的基础上，根据风险回报的权衡，选择适合自己的投资产品和策略。</li><li><strong>避免常见的投资错误</strong>：如盲目追求高收益而忽视高风险，或因过度厌恶风险而错失合理的增长机会。</li><li><strong>构建稳健的投资组合</strong>：通过有效的风险管理，力求在可承受的风险范围内实现投资目标。</li></ol><p><strong>小结</strong></p><p>价值投资、成长投资和指数投资代表了三种不同但都非常重要的投资哲学。它们并非相互排斥，很多成功的投资者会根据市场环境和自身理解，融合不同理念的元素。无论你倾向于哪种理念，或者未来形成自己独特的投资体系，<strong>“理解先于行动”</strong>始终是核心原则。同时，深刻理解并敬畏风险与回报之间的关系，是每一位投资者贯穿始终的必修课。选择与自己风险承受能力和投资目标相匹配的策略，并长期坚持，才能更有可能在投资的马拉松中胜出。</p><h3 id="第六节克服心理障碍">第六节：克服心理障碍</h3><p>即使掌握了丰富的投资知识和精密的分析工具，我们的投资决策依然常常受到自身心理偏误的干扰。人类在漫长的进化过程中形成的许多心理捷径和情绪反应，在现代金融市场中往往会成为投资的“绊脚石”。理解并努力克服这些心理障碍，是提升投资绩效的关键一环。本节将探讨几种常见的投资心理误区。</p><h4 id="一常见的投资心理误区">一、常见的投资心理误区</h4><p><strong>1. 追涨杀跌 (Herding &amp; Chasing Performance)</strong></p><ul><li><strong>是什么(What)</strong>：指投资者倾向于跟随大众的行为，在市场上涨时（“涨”）盲目买入，期望继续上涨；在市场下跌时（“跌”）恐慌性卖出，唯恐进一步亏损。这是一种典型的羊群效应。<ul><li><strong>《非理性繁荣》</strong>的作者罗伯特·希勒深入探讨了这种从众心理如何助长资产泡沫的形成和破裂。人们看到别人都在赚钱，便担心错过机会（FOMO- Fear Of MissingOut），于是纷纷涌入，进一步推高价格，脱离基本面；而当市场转向，恐慌情绪蔓延，又会争相出逃，加剧下跌。</li></ul></li><li><strong>怎么做 (How to avoid)</strong>：<ul><li><strong>独立思考，逆向操作</strong>：坚持基于基本面的独立判断，不轻易被市场情绪裹挟。巴菲特的名言“在别人贪婪时恐惧，在别人恐惧时贪婪”正是此道的精髓。</li><li><strong>制定并遵守投资纪律</strong>：在投资前设定好买入、卖出和止损的原则，并严格执行，避免情绪化决策。</li><li><strong>长期投资视角</strong>：关注资产的长期价值，而不是短期价格波动，可以减少追涨杀跌的冲动。</li></ul></li><li><strong>为什么 (Why it's atrap)</strong>：追涨往往买在阶段性高点，杀跌则往往卖在阶段性低点，长期如此操作，必然导致亏损。这种行为放弃了低买高卖的盈利本质。<ul><li><strong>历史实例</strong>：2000年互联网泡沫顶峰时期，大量散户蜂拥买入科技股，随后泡沫破裂，损失惨重。2008年金融危机底部，许多投资者因恐慌而抛售股票，错过了随后的市场大幅反弹。</li></ul></li></ul><p><strong>2. 过度自信 (Overconfidence Bias)</strong></p><ul><li><strong>是什么(What)</strong>：指投资者往往高估自己的知识、能力和预测市场的准确性，低估风险。他们可能认为自己能够比别人更准确地挑选出“牛股”或把握市场时机。<ul><li><strong>《随机致富的傻瓜》</strong>的作者纳西姆·尼古拉斯·塔勒布指出，许多所谓的成功，尤其是在金融市场，可能更多是运气（随机性）而非能力的结果，但人们倾向于将好结果归因于自己的高明。</li></ul></li><li><strong>怎么做 (How to avoid)</strong>：<ul><li><strong>保持谦逊，承认未知</strong>：认识到市场的复杂性和不可预测性，承认自己知识和能力的局限。</li><li><strong>记录并反思决策</strong>：定期回顾自己的投资决策及其结果，客观分析成功和失败的原因，有助于校准自信程度。</li><li><strong>寻求不同意见</strong>：主动听取与自己观点不同的意见，避免陷入“确认偏误”（只关注支持自己观点的信息）。</li><li><strong>分散投资</strong>：不要将所有赌注押在少数几个自认为“绝对正确”的投资上。</li></ul></li><li><strong>为什么 (Why it's atrap)</strong>：过度自信会导致投资者承担过高风险、交易过于频繁（增加成本）、以及在信息不足的情况下做出草率决策。<ul><li><strong>现实实例</strong>：许多新手投资者在牛市初期赚到一些钱后，容易变得过度自信，开始频繁交易、使用杠杆，结果在市场调整时遭受重大损失。</li></ul></li></ul><p><strong>3. 损失厌恶 (Loss Aversion)</strong></p><ul><li><strong>是什么(What)</strong>：指人们在心理上对“损失”的感受强度远大于对同等数量“收益”的感受强度。简单来说，损失100元带来的痛苦感，比得到100元带来的快乐感要强烈得多。<ul><li>行为经济学的先驱丹尼尔·卡尼曼和阿莫斯·特沃斯基通过前景理论（ProspectTheory）揭示了这一现象。</li></ul></li><li><strong>怎么做 (How to avoid/manage)</strong>：<ul><li><strong>关注长期目标，而非短期盈亏</strong>：将注意力从每日的账户波动上移开，聚焦于长期的财务规划。</li><li><strong>设定止损点</strong>：在投资前设定一个可承受的最大亏损幅度，一旦达到即执行卖出，避免因不愿接受小损失而最终酿成大亏损（“死扛”）。</li><li><strong>区分“账面浮亏”与“实际亏损”</strong>：对于优质资产的短期浮亏，如果其长期基本面未变，可能无需过度恐慌。但要警惕将此作为不止损的借口。</li><li><strong>小额实践，逐步适应</strong>：通过小额资金的实际投资，逐步体验和适应市场的波动和潜在的损失。</li></ul></li><li><strong>为什么 (Why it's a trap)</strong>：损失厌恶会导致投资者：<ul><li><strong>过早卖出盈利的股票</strong>：害怕已有的利润消失，急于“落袋为安”，错失更大的上涨空间（“截断利润”）。</li><li><strong>长期持有亏损的股票</strong>：不愿承认错误并“割肉”，期待股价反弹回本，结果可能越陷越深（“放任亏损”）。</li><li><strong>过度保守</strong>：因为害怕任何可能的损失，而选择过于保守的投资策略，导致长期回报不佳，无法实现财务目标。</li><li><strong>历史实例</strong>：许多投资者在股价下跌后，不是评估公司基本面是否恶化，而是仅仅因为不想“实现亏损”而继续持有基本面已经变坏的股票，最终可能导致本金大幅缩水甚至归零。</li></ul></li></ul><p><strong>4. 锚定效应 (Anchoring Bias)</strong></p><ul><li><strong>是什么(What)</strong>：指人们在做决策时，会过度依赖最先获得的信息（“锚”），即使这个信息与决策本身并不完全相关或已经过时。<ul><li>例如，投资者可能会以自己买入某只股票的价格作为“锚”，如果股价跌破买入价，就不愿卖出，认为“至少要回本再说”。或者以某只股票曾经达到过的最高价作为锚，认为它“应该”回到那个价格。</li></ul></li><li><strong>怎么做 (How to avoid)</strong>：<ul><li><strong>基于当前基本面和未来预期做决策</strong>：评估一项投资的价值时，应关注其当前的内在价值和未来的发展前景，而不是过去的价格。</li><li><strong>定期重新评估</strong>：对于持有的投资，要定期根据最新的信息进行重新评估，而不是固守最初的判断。</li><li><strong>多方获取信息，避免单一信息源</strong>。</li></ul></li><li><strong>为什么 (Why it's atrap)</strong>：锚定效应会阻碍投资者根据新的信息和变化的环境做出理性的调整，导致错失卖出时机或买入良机。</li></ul><p><strong>5. 处置效应 (Disposition Effect)</strong></p><ul><li><strong>是什么(What)</strong>：这是损失厌恶和锚定效应等心理结合的体现，指投资者倾向于过早地卖出正在上涨的“赢家”股票（兑现利润），而过久地持有正在下跌的“输家”股票（避免实现损失）。</li><li><strong>怎么做 (How toavoid)</strong>：同损失厌恶和锚定效应的应对方法。强调“让利润奔跑，及时止损亏损”。</li><li><strong>为什么 (Why it's atrap)</strong>：这种行为模式与获取长期良好回报的原则背道而驰。</li></ul><p><strong>6. 对“黑天鹅”事件的忽视与“反脆弱性”的缺乏</strong></p><ul><li><strong>是什么 (What)</strong>：<ul><li><strong>《黑天鹅》</strong>的作者塔勒布用“黑天鹅事件”来形容那些极其罕见、出乎意料，但一旦发生就会产生巨大影响的事件。人们往往低估这类事件发生的可能性及其冲击力。</li><li><strong>《反脆弱》</strong>进一步阐述了某些系统（包括个人投资组合）不仅能抵抗冲击，还能从冲击和波动中受益的特性。许多投资者在构建投资组合时，往往只考虑“平均状态”，缺乏应对极端事件的“反脆弱性”设计。</li></ul></li><li><strong>怎么做 (How to build resilience/anti-fragility)</strong>：<ul><li><strong>承认极端风险的存在</strong>：不要假设历史会简单重复，未来总会风平浪静。</li><li><strong>适度分散，配置避险资产</strong>：在投资组合中加入一些在市场剧烈动荡时可能表现较好或损失较小的资产（如黄金、某些类型的债券、现金）。</li><li><strong>避免过度杠杆</strong>：杠杆会放大收益，但也会在黑天鹅事件发生时急剧放大损失，甚至导致爆仓。</li><li><strong>保留一定的流动性（现金）</strong>：以便在市场恐慌、优质资产被错杀时有“弹药”买入。</li><li><strong>考虑购买“便宜的”期权等对冲工具（对专业投资者而言）</strong>。</li></ul></li><li><strong>为什么 (Why it'simportant)</strong>：金融市场历史上不乏黑天鹅事件（如1987年股灾、2008年金融危机、2020年新冠疫情冲击）。忽视它们可能导致投资组合在极端情况下遭受毁灭性打击。而构建具有一定反脆弱性的组合，则能在危机中更好地保全自己，甚至抓住机会。</li></ul><p><strong>7. 对“反馈”的误读与索罗斯的反身性理论</strong></p><ul><li><strong>是什么(What)</strong>：乔治·索罗斯在其<strong>《金融炼金术》</strong>中提出了“反身性理论(Reflexivity)”。他认为，市场参与者的认知（预期）和市场实际状况之间存在一个双向的反馈循环。参与者的偏见会影响市场价格，而变化了的市场价格反过来又会影响参与者的认知和基本面本身，形成一个不断互动、可能自我强化也可能自我毁灭的过程。<ul><li>这意味着市场并非总是有效地反映基本面，参与者的非理性预期本身就可以成为驱动市场走向的力量，尤其是在泡沫形成和破裂的过程中。</li></ul></li><li><strong>怎么做 (How to understand)</strong>：<ul><li><strong>警惕市场中的正反馈循环</strong>：当乐观情绪推动价格上涨，价格上涨又强化乐观情绪时，泡沫可能正在形成。反之亦然。</li><li><strong>理解市场情绪的重要性</strong>：除了基本面分析，也要关注市场参与者的集体情绪和预期。</li><li><strong>意识到自己的行为也是市场的一部分</strong>：你的买卖决策也会对市场产生微小的影响，并受到他人行为的影响。</li></ul></li><li><strong>为什么 (Why it's achallenge)</strong>：反身性理论挑战了传统金融理论中市场总是理性和有效的假设。它揭示了市场内在的不稳定性和不可预测性，提醒投资者不能简单地认为价格总会回归“公允价值”，因为这个“公允价值”本身也可能在被市场行为所改变。</li></ul><p><strong>小结</strong></p><p>克服投资中的心理障碍是一个持续修炼的过程，没有一劳永逸的解决方案。关键在于<strong>“认识你自己”</strong>——了解这些常见的心理偏误，时刻反省自己的决策过程是否受到了它们的影响，并有意识地采取措施加以规避或校正。这需要极大的<strong>耐心和好奇心</strong>，正如本书的核心原则所强调的，投资是终身学习的过程，其中也包括对自身心理的不断探索和完善。</p><hr /><h3id="总结投资基础知识与投资思维的建立">总结：投资基础知识与投资思维的建立</h3><p>在本章中，我们共同探索了投资的起点。我们的旅程从最基本的问题“<strong>什么是投资？</strong>”开始，明确了投资与投机的核心区别，并初步领略了<strong>复利</strong>这一世界奇迹的魔力。我们借鉴了《聪明的投资者》、《富爸爸穷爸爸》和《穷查理宝典》中的智慧，强调投资是基于分析、确保本金安全并获取满意回报的行为，是购买能带来现金流的“资产”。</p><p>接着，我们认识了构成投资世界基石的<strong>基本金融工具</strong>：代表所有权的<strong>股票</strong>（高风险高潜在回报）、代表债权的<strong>债券</strong>（相对稳健）、集合投资的<strong>基金</strong>（分散风险、专家管理）以及高度流动性的<strong>现金等价物</strong>（保本为主）。了解它们各自的风险与收益特征，是我们进行资产配置的前提。</p><p>然后，我们走进了<strong>市场基础</strong>，了解了进行金融工具交易的<strong>交易所</strong>是如何运作的，探讨了驱动<strong>股价波动</strong>的多种因素（基本面、宏观经济、行业趋势、市场情绪），并学习了描述市场整体趋势的<strong>牛市与熊市</strong>概念。引用《投资最重要的事》中关于市场情绪钟摆的观点，提醒我们警惕非理性波动。</p><p>为了更好地理解投资所处的大环境，我们学习了几个<strong>基本经济概念</strong>：<strong>通货膨胀</strong>（侵蚀购买力）、<strong>利率</strong>（资金的价格）和<strong>GDP</strong>（经济活动总量）。借鉴《经济学原理》的视角，我们分析了这些宏观指标如何产生以及它们对投资的深远影响。</p><p>随后，我们深入探讨了三种主流的<strong>核心投资理念</strong>：</p><ul><li><strong>价值投资</strong>：以格雷厄姆和巴菲特为代表，强调寻找安全边际，购买内在价值被低估的证券。</li><li><strong>成长投资</strong>：以彼得·林奇为代表，聚焦于投资高速成长的公司，分享其未来发展的红利。</li><li><strong>指数投资</strong>：以约翰·博格为代表，倡导通过低成本的指数基金获取市场平均回报。同时，我们再次强调了投资中永恒的权衡——<strong>风险与回报</strong>的关系，以及分散投资和资产配置的重要性。</li></ul><p>最后，我们直面投资中最具挑战性的部分——<strong>克服心理障碍</strong>。我们剖析了追涨杀跌、过度自信、损失厌恶、锚定效应等常见的投资心理误区，并借鉴了《反脆弱》、《黑天鹅》、《非理性繁荣》、《金融炼金术》、《随机致富的傻瓜》等著作中的洞见，强调了认识并管理这些心理偏误对于成功投资的极端重要性。</p><p>贯穿本章始终的是本书的四大核心原则：</p><ul><li><strong>理解先于行动</strong>：每一节内容都强调了“是什么、怎么做、为什么”，力求在行动之前建立清晰的认知。</li><li><strong>循序渐进</strong>：从最基本的概念入手，逐步引入更复杂的知识。</li><li><strong>理论结合实践</strong>：通过引用经典著作和列举现实与历史实例，将理论与实际联系起来。</li><li><strong>保持耐心和好奇心</strong>：认识到投资是一个需要不断学习和反思的长期过程，尤其是在面对市场波动和自身心理挑战时。</li></ul><p>通过第一章的学习，我们为后续更深入的投资探索打下了坚实的基础。我们不仅学习了“术”（是什么工具，怎么操作），更重要的是开始建立“道”（投资的思维方式和正确的心态）。记住，投资是一场马拉松，而不是百米冲刺。带着在本章建立的认知框架，我们将更有信心地迈向下一章的学习。</p><h2 id="第二章公司分析与估值基础">第二章：公司分析与估值基础</h2><p><strong>目标</strong>：学会阅读财务报表，理解公司基本面分析的核心要素，初步掌握估值概念。</p><h3 id="第一节财务报表入门">第一节：财务报表入门</h3><p>在上一章我们建立了投资的基础认知和思维框架后，现在我们将深入到投资决策的核心环节之一：<strong>理解一家公司</strong>。而理解一家公司最直接、最重要的方式，就是阅读它的“体检报告”——财务报表。正如<strong>《手把手教你读财报》</strong>的作者唐朝所言，财报是用来排除企业的，不懂财报，价值投资无从谈起。<strong>《巴菲特教你读财报》</strong>也强调，巴菲特之所以能持续做出成功的投资决策，很大程度上得益于他深厚的财务分析功底。本节将带你入门最重要的三张财务报表：资产负债表、利润表和现金流量表。</p><h4 id="一资产负债表-balance-sheet">一、资产负债表 (Balance Sheet)</h4><p><strong>是什么 (What)：公司的“家底”快照</strong></p><p><strong>资产负债表是一张在特定时间点（比如年末、季末）反映公司财务状况的快照。它清晰地展示了公司拥有什么（资产）、欠了什么（负债），以及真正属于股东的有多少（所有者权益）。</strong>它遵循一个最基本的会计恒等式：</p><p><strong>资产 (Assets) = 负债 (Liabilities) + 所有者权益(Shareholders' Equity)</strong></p><ul><li><strong>通俗理解</strong>：想象你要给自己的家庭拍一张“财务全家福”。<ul><li><strong>资产</strong>：就是你家拥有的所有值钱的东西，比如房子、车子、银行存款、股票、你借给别人的钱等。</li><li><strong>负债</strong>：就是你家欠别人的钱，比如房贷、车贷、信用卡账单、问亲戚朋友借的钱等。</li><li><strong>所有者权益（净资产）</strong>：就是把你家所有的资产变现，还清所有负债后，真正属于你自己的那部分钱。</li></ul></li><li><strong>《证券分析第五版》</strong>中，格雷厄姆和多德将资产负债表视为评估公司偿债能力和财务稳定性的重要依据。</li></ul><p><strong>怎么做 (How)：理解资产负债表的主要科目</strong></p><p>资产负债表通常分为左右两边（或上下两部分），左边（或上边）是资产，右边（或下边）是负债和所有者权益。</p><p><strong>1. 资产 (Assets)：公司拥有的资源</strong>资产通常按照其流动性（变现的难易程度）从上到下排列。</p><ul><li><strong>流动资产 (CurrentAssets)</strong>：预计在一年内或一个营业周期内可以变现或耗用的资产。<ul><li><strong>货币资金 (Cash and CashEquivalents)</strong>：公司银行账户里的现金、库存现金以及可以随时转换为现金的短期投资（如货币基金）。这是公司流动性最强的资产。<ul><li><strong>现实实例</strong>：一家公司银行账户上的存款1000万元。</li></ul></li><li><strong>交易性金融资产 (Trading FinancialAssets)</strong>：公司为了短期交易目的持有的股票、债券、基金等。</li><li><strong>应收票据及应收账款 (Notes Receivable and AccountsReceivable)</strong>：公司因销售商品或提供服务而应向客户收取的款项（客户打的“白条”）。如果这个科目金额巨大且增长过快，可能意味着公司产品不好卖，或者回款能力差。<ul><li><strong>现实实例</strong>：一家手机公司卖给经销商100万台手机，约定3个月后付款，这100万台手机对应的货款就是应收账款。</li></ul></li><li><strong>预付款项(Prepayments)</strong>：公司预先支付给供应商的款项，以获取未来的商品或服务。<ul><li><strong>现实实例</strong>：公司预付了下一年度的办公室租金。</li></ul></li><li><strong>存货(Inventories)</strong>：公司持有的准备出售的产成品、在产品、原材料等。存货过多可能意味着产品滞销或管理不善；存货过少则可能影响正常销售。对于不同行业，存货的意义也不同，例如茅台的存货（基酒）是越陈越香，而科技公司的电子产品存货则面临快速贬值的风险。<ul><li><strong>现实实例</strong>：一家服装厂仓库里待售的衣服、生产线上的半成品布料。</li></ul></li><li><strong>其他流动资产 (Other CurrentAssets)</strong>：如待摊费用等。</li></ul></li><li><strong>非流动资产 (Non-CurrentAssets)</strong>：变现或耗用周期超过一年的资产。<ul><li><strong>长期股权投资 (Long-Term EquityInvestments)</strong>：公司持有的对其他企业的股权投资，且不打算在短期内出售。</li><li><strong>固定资产 (Fixed Assets / Property, Plant, and Equipment -PP&amp;E)</strong>：公司为生产经营而持有的，使用寿命超过一年的有形资产，如土地（在中国通常是土地使用权）、厂房、机器设备、办公楼、运输工具等。固定资产会随着使用而折旧。<ul><li><strong>现实实例</strong>：一家制造企业的生产车间、生产线上的机器。</li></ul></li><li><strong>在建工程 (Construction inProgress)</strong>：正在建造尚未完工的固定资产项目。</li><li><strong>无形资产 (IntangibleAssets)</strong>：没有实物形态但能为企业带来经济利益的资产，如专利权、商标权、著作权、土地使用权（区别于厂房所占土地）、商誉（Goodwill，通常在企业并购时产生，指收购价格超过被收购方可辨认净资产公允价值的部分）。<ul><li><strong>现实实例</strong>：可口可乐的品牌、微软的软件著作权、辉瑞的药品专利。</li></ul></li><li><strong>长期待摊费用 (Long-Term DeferredExpenses)</strong>：已经支出但应由本期及以后各期分担的，分摊期限在一年以上的费用，如固定资产改良支出。</li><li><strong>递延所得税资产 (Deferred TaxAssets)</strong>：由于会计与税法差异，未来可以用来抵扣应纳税所得额的部分。</li></ul></li></ul><p><strong>2. 负债 (Liabilities)：公司欠的钱</strong>负债也通常按照其偿还期限的远近从上到下排列。</p><ul><li><strong>流动负债 (CurrentLiabilities)</strong>：预计在一年内或一个营业周期内需要偿还的债务。<ul><li><strong>短期借款 (Short-TermBorrowings)</strong>：公司从银行或其他金融机构借入的，期限在一年以内的款项。</li><li><strong>应付票据及应付账款 (Notes Payable and AccountsPayable)</strong>：公司因购买商品或接受服务而应向供应商支付的款项（公司给别人打的“白条”）。如果一家公司对应付账款的占用能力强，说明其在产业链中有较强的话语权。<ul><li><strong>现实实例</strong>：一家超市从食品供应商处进货，约定2个月后付款，这笔未付款项就是应付账款。</li></ul></li><li><strong>预收款项/合同负债 (Advances from Customers / ContractLiabilities)</strong>：公司预先向客户收取的款项，未来需要提供商品或服务来偿还。这通常是好事情，说明产品或服务受欢迎，客户愿意提前付款。<ul><li><strong>现实实例</strong>：航空公司预售的机票款；房地产公司预售楼盘收到的房款。茅台的预收款也一直是其强势地位的体现。</li></ul></li><li><strong>应付职工薪酬 (Salaries and WagesPayable)</strong>：公司应付给员工但尚未支付的工资、奖金、福利等。</li><li><strong>应交税费 (TaxesPayable)</strong>：公司应向税务机关缴纳但尚未缴纳的各种税款，如增值税、所得税等。</li><li><strong>一年内到期的非流动负债 (Non-Current Liabilities Due withinOne Year)</strong>：原为长期负债，但将在未来一年内到期的部分。</li></ul></li><li><strong>非流动负债 (Non-CurrentLiabilities)</strong>：偿还期限超过一年的债务。<ul><li><strong>长期借款 (Long-TermBorrowings)</strong>：公司从银行或其他金融机构借入的，期限在一年以上的款项。</li><li><strong>应付债券 (BondsPayable)</strong>：公司为筹集长期资金而发行的债券。</li><li><strong>长期应付款 (Long-TermPayables)</strong>：如融资租入固定资产的应付款项。</li><li><strong>递延所得税负债 (Deferred TaxLiabilities)</strong>：由于会计与税法差异，未来需要支付的所得税。</li></ul></li></ul><p><strong>3. 所有者权益 (Shareholders'Equity)：真正属于股东的净资产</strong>也称为股东权益或净资产，是公司总资产减去总负债后的剩余部分。</p><ul><li><strong>股本/实收资本 (Share Capital / Paid-inCapital)</strong>：股东投入公司的原始资本，按面值计算。<ul><li><strong>现实实例</strong>：一家公司发行了1亿股股票，每股面值1元，则股本为1亿元。</li></ul></li><li><strong>资本公积 (Capital Surplus / Additional Paid-inCapital)</strong>：股东投入的资金中超过股本面值的部分，以及其他非经营性活动产生的权益增加。<ul><li><strong>现实实例</strong>：上述公司以每股5元的价格发行股票，那么每股有4元（5元发行价- 1元面值）计入资本公积。</li></ul></li><li><strong>盈余公积 (Surplus Reserve / Retained EarningsAppropriated)</strong>：公司从税后利润中提取的，用于弥补亏损、扩大再生产或转增资本的积累。</li><li><strong>未分配利润 (Retained Earnings / AccumulatedProfits)</strong>：公司历年累积的净利润，在提取盈余公积和分配股利后剩余的部分，可用于未来分配或再投资。这是公司“家底”增厚的主要来源。</li><li><strong>归属于母公司所有者权益合计 (Total Equity Attributable toEquity Holders of theParent)</strong>：对于上市公司，这部分是主要关注的股东权益。</li><li><strong>少数股东权益 (Minority Interest / Non-ControllingInterest)</strong>：如果公司合并了其拥有多数股权但非全部股权的子公司，那么子公司中不属于母公司的少数股东所拥有的权益部分。</li></ul><p><strong>为什么 (Why)：资产负债表的重要性</strong></p><ol type="1"><li><strong>评估财务健康状况</strong>：通过分析资产负债表，可以了解公司的偿债能力（是债台高筑还是游刃有余？）、营运能力（资产周转效率如何？）、财务结构（是主要靠借钱发展还是靠自有积累？）。</li><li><strong>判断资产质量</strong>：资产中是“真金白银”多，还是“应收白条”和“积压存货”多？无形资产中是否有大量虚高的商誉？</li><li><strong>识别潜在风险</strong>：例如，过高的负债率、过多的短期借款、不良的资产结构等都可能是风险信号。</li><li><strong>价值评估的基础</strong>：如市净率 (P/B)估值法就是基于所有者权益（净资产）计算的。公司的资产质量和结构也是其他估值方法的重要考量因素。</li><li><strong>追踪公司发展</strong>：通过比较不同时期的资产负债表，可以看出公司规模、资产结构、财务策略的变化趋势。</li></ol><h4 id="二利润表-income-statement-profit-and-loss-statement">二、利润表(Income Statement / Profit and Loss Statement)</h4><p><strong>是什么 (What)：公司的“经营成绩单”</strong></p><p><strong>利润表（也称损益表）反映了公司在一定会计期间（如一年、一季度）的经营成果，即公司是赚钱了还是亏钱了，赚了多少或亏了多少。</strong>它展示了公司收入的来源、成本费用的构成，并最终得出净利润。</p><ul><li><strong>通俗理解</strong>：想象你开了一家小餐馆，利润表就像是你这个月（或这一年）的经营账本：<ul><li>记录了你卖了多少饭菜（营业收入）。</li><li>记录了你买菜、买米的成本（营业成本）。</li><li>记录了你付的房租、水电费、员工工资（销售费用、管理费用）。</li><li>记录了你借钱开店付的利息（财务费用）。</li><li>最后算出来你这个月是赚了还是亏了（净利润）。</li></ul></li><li><strong>《巴菲特教你读财报》</strong>中指出，巴菲特非常关注那些拥有持续稳定高毛利率和净利率的公司，这些信息都直接来源于利润表。</li></ul><p><strong>怎么做 (How)：理解利润表的主要科目</strong></p><p>利润表的结构通常是从上到下，层层扣减，最终得到净利润。</p><ol type="1"><li><strong>营业总收入 (Total Operating Revenue)</strong><ul><li><strong>营业收入 (OperatingRevenue)</strong>：公司通过主要经营活动（销售商品、提供劳务等）取得的收入。这是公司最主要的收入来源，其持续增长是公司健康发展的标志。<ul><li><strong>现实实例</strong>：一家汽车公司卖汽车获得的收入；一家软件公司销售软件授权和提供技术支持获得的收入。</li></ul></li></ul></li><li><strong>营业总成本 (Total Operating Cost)</strong><ul><li><strong>营业成本 (Cost of Goods Sold - COGS / Cost ofRevenue)</strong>：与主营业务收入直接相关的成本，如生产产品的原材料成本、直接人工成本等。对于零售企业，就是商品的进货成本。<ul><li><strong>现实实例</strong>：汽车公司的钢材、零部件成本；软件公司的研发人员部分工资（如果资本化处理不当，可能直接计入成本）。</li></ul></li><li><strong>营业税金及附加 (Taxes andSurcharges)</strong>：公司经营活动应负担的各种税费，如消费税、城市维护建设税、教育费附加等（注意区别于所得税）。</li><li><strong>销售费用 (SellingExpenses)</strong>：公司在销售商品和提供劳务过程中发生的费用，如广告费、促销费、销售人员工资、运输费、店铺租金等。<ul><li><strong>现实实例</strong>：化妆品公司的广告投入、电商平台的推广费用。</li></ul></li><li><strong>管理费用 (General and Administrative Expenses -G&amp;A)</strong>：公司为组织和管理生产经营活动而发生的费用，如公司高管工资、行政人员工资、办公费、折旧费（非生产用固定资产）、研发费用（如果费用化处理）等。<ul><li><strong>现实实例</strong>：公司总部的租金、CEO的薪水。</li></ul></li><li><strong>研发费用 (Research and Development Expenses -R&amp;D)</strong>：公司为获取新技术、新产品、新工艺而进行研究与开发活动所发生的费用。对于科技公司、医药公司等，研发投入的规模和效率至关重要。</li><li><strong>财务费用 (FinancialExpenses)</strong>：公司为筹集生产经营所需资金等而发生的费用，如利息支出（减利息收入）、汇兑损益、金融机构手续费等。<ul><li><strong>现实实例</strong>：公司向银行贷款支付的利息。</li></ul></li></ul></li><li><strong>其他经营项目产生的收益或损失</strong><ul><li><strong>其他收益 (OtherIncome)</strong>：与日常活动相关，但不在营业收入中反映的政府补助等。</li><li><strong>投资收益 (InvestmentIncome/Loss)</strong>：公司对外投资（如购买其他公司股票、债券、理财产品）所获得的收益或发生的损失。如果一家非投资型公司，其利润主要来源于投资收益而非主营业务，需要警惕。</li><li><strong>公允价值变动收益/损失 (Gains/Losses from Changes in FairValue)</strong>：公司持有的以公允价值计量的金融资产或负债，因公允价值变动而产生的未实现收益或损失。</li><li><strong>资产处置收益/损失 (Gains/Losses on Disposal ofAssets)</strong>：出售固定资产、无形资产等产生的净收益或净损失。</li><li><strong>营业外收入 (Non-OperatingIncome)</strong>：与公司日常经营活动无直接关系的各项利得，如政府奖励、债务重组利得、接受捐赠等。金额较大且不可持续的营业外收入，会影响利润的“含金量”。</li><li><strong>营业外支出 (Non-OperatingExpenses)</strong>：与公司日常经营活动无直接关系的各项损失，如公益性捐赠支出、非常损失（自然灾害损失）、罚款支出等。</li></ul></li><li><strong>利润总额 (Total Profit / Earnings Before Tax - EBT)</strong>= 营业利润（营业收入 - 营业成本 - 税金及附加 - 销售费用 - 管理费用 -研发费用 - 财务费用 + 其他收益 + 投资收益 + 公允价值变动收益 +资产处置收益等）+ 营业外收入 - 营业外支出<ul><li><strong>营业利润 (Operating Profit)</strong>是衡量公司主营业务盈利能力的核心指标。</li></ul></li><li><strong>所得税费用 (Income Tax Expense)</strong>公司根据应纳税所得额和适用税率计算的当期应缴纳的企业所得税。</li><li><strong>净利润 (Net Profit / Net Income)</strong> = 利润总额 -所得税费用。这是公司在一个会计期间最终的税后经营成果。<ul><li><strong>归属于母公司所有者的净利润 (Net Profit Attributable toEquity Holders of theParent)</strong>：上市公司财报中，这是计算每股收益（EPS）的基础。</li><li><strong>少数股东损益 (Minority InterestIncome/Loss)</strong>：合并报表中，归属于子公司少数股东的净利润或净亏损。</li></ul></li></ol><p><strong>为什么 (Why)：利润表的重要性</strong></p><ol type="1"><li><strong>评估盈利能力</strong>：这是利润表最直接的功能。通过毛利率（(营业收入-营业成本)/营业收入）、营业利润率、净利率等指标，可以判断公司的赚钱能力强弱和盈利质量高低。</li><li><strong>分析成本结构</strong>：了解公司的主要成本费用构成，有助于判断其成本控制能力和经营效率。</li><li><strong>判断利润来源与可持续性</strong>：利润是来自核心主营业务，还是来自偶然的投资收益或营业外收入？前者更具可持续性。</li><li><strong>追踪增长趋势</strong>：通过比较不同时期的利润表，可以分析公司收入和利润的增长速度、稳定性及驱动因素。</li><li><strong>价值评估的关键输入</strong>：市盈率 (P/E)估值法直接使用净利润（或每股收益）。现金流折现等更复杂的估值模型也需要预测未来的利润。</li></ol><h4 id="三现金流量表-cash-flow-statement">三、现金流量表 (Cash FlowStatement)</h4><p><strong>是什么 (What)：公司的“现金收支簿”</strong></p><p><strong>现金流量表反映了公司在一定会计期间内现金及现金等价物流入和流出的情况。它追踪了公司现金从哪里来，到哪里去。</strong>与利润表不同，利润表基于权责发生制（收入和费用在其发生时确认，不论现金是否收付），而现金流量表基于收付实现制（只记录实际的现金收付）。</p><ul><li><strong>通俗理解</strong>：利润表可能会记录一笔“应收账款”作为收入，但如果这笔钱没收回来，公司的银行账户里并没有增加现金。现金流量表则只关心真金白银的进出。比如，你卖了货，客户打了欠条（利润表可能确认收入），但客户没给钱，你的现金流量表上这笔销售的现金流入就是零。</li><li><strong>“利润是观点，现金是事实” (Profit is an opinion, cash is afact.)</strong>这句话凸显了现金流量表的重要性。公司可以短期内通过会计处理“创造”利润，但很难伪造持续健康的现金流。<strong>《巴菲特教你读财报》</strong>同样强调了自由现金流（Free CashFlow，通常从现金流量表数据计算得出）对于评估公司价值的重要性。</li></ul><p><strong>怎么做 (How)：理解现金流量表的主要构成</strong></p><p>现金流量表通常分为三个主要部分：</p><p><strong>1. 经营活动产生的现金流量 (Cash Flows from OperatingActivities - CFO)</strong>反映公司通过其核心业务（销售商品、提供劳务）产生的现金流入和流出。这是衡量公司主营业务造血能力的关键。</p><ul><li><strong>主要流入项目</strong>：<ul><li><strong>销售商品、提供劳务收到的现金</strong>：这是最重要的现金流入来源。</li><li><strong>收到的税费返还</strong>。</li><li><strong>收到其他与经营活动有关的现金</strong>。</li></ul></li><li><strong>主要流出项目</strong>：<ul><li><strong>购买商品、接受劳务支付的现金</strong>。</li><li><strong>支付给职工以及为职工支付的现金</strong>。</li><li><strong>支付的各项税费</strong>。</li><li><strong>支付其他与经营活动有关的现金</strong>（如付现的销售费用、管理费用）。</li></ul></li><li><strong>经营活动现金流量净额 (Net Cash from OperatingActivities)</strong>：如果持续为正且不断增长，通常表明公司主营业务健康，能产生足够的现金支持运营和发展。如果长期为负，或者远低于净利润，需要警惕。</li></ul><p><strong>2. 投资活动产生的现金流量 (Cash Flows from InvestingActivities - CFI)</strong>反映公司在长期资产（如固定资产、无形资产）和金融资产（如购买股票、债券）方面的投资和处置所产生的现金流入和流出。</p><ul><li><strong>主要流入项目</strong>：<ul><li><strong>收回投资收到的现金</strong>（如卖出股票、债券收到的钱）。</li><li><strong>取得投资收益收到的现金</strong>（如收到的股息、利息）。</li><li><strong>处置固定资产、无形资产和其他长期资产收回的现金净额</strong>。</li></ul></li><li><strong>主要流出项目</strong>：<ul><li><strong>购建固定资产、无形资产和其他长期资产支付的现金</strong>（资本性支出- Capex）。这是公司为维持和扩大再生产进行的投资。</li><li><strong>投资支付的现金</strong>（如购买股票、债券支付的钱）。</li></ul></li><li><strong>投资活动现金流量净额 (Net Cash from InvestingActivities)</strong>：对于成长型公司，该项目通常为负，表明公司在积极扩张。对于成熟型或收缩型公司，可能为正。需要结合公司战略来看。</li></ul><p><strong>3. 筹资活动产生的现金流量 (Cash Flows from FinancingActivities - CFF)</strong>反映公司与所有者（股东）和债权人之间发生的，导致公司资本和债务规模及构成发生变化的现金流入和流出。</p><ul><li><strong>主要流入项目</strong>：<ul><li><strong>吸收投资收到的现金</strong>（如发行新股收到的募集资金）。</li><li><strong>取得借款收到的现金</strong>。</li><li><strong>发行债券收到的现金</strong>。</li></ul></li><li><strong>主要流出项目</strong>：<ul><li><strong>偿还债务支付的现金</strong>。</li><li><strong>分配股利、利润或偿付利息支付的现金</strong>。</li></ul></li><li><strong>筹资活动现金流量净额 (Net Cash from FinancingActivities)</strong>：正值表明公司在从外部融资，负值表明公司在偿还债务或回报股东。</li></ul><p><strong>现金及现金等价物净增加额 (Net Increase/Decrease in Cash andCash Equivalents)</strong> = 经营活动现金流量净额 + 投资活动现金流量净额+ 筹资活动现金流量净额</p><p><strong>期末现金及现金等价物余额 (Cash and Cash Equivalents at End ofPeriod)</strong> = 期初现金及现金等价物余额 + 现金及现金等价物净增加额这个期末余额应该与资产负债表中的“货币资金”科目基本一致（需考虑现金等价物的范围）。</p><p><strong>为什么 (Why)：现金流量表的重要性</strong></p><ol type="1"><li><strong>评估公司真实的“造血”能力</strong>：经营活动现金流量净额是核心，它反映了公司主营业务自我维持和发展的能力。一家公司即使利润很高，但如果经营活动现金流很差（比如应收账款收不回来），也可能陷入困境。</li><li><strong>判断利润质量</strong>：将净利润与经营活动现金流量净额进行比较。如果两者长期相差过大（净利润远高于经营现金流），可能意味着利润的“含金量”不高，存在较多未收现的收入或通过非现金方式调节利润。</li><li><strong>分析公司的投资和融资策略</strong>：投资活动现金流可以看出公司是在扩张还是收缩，是在投资实体资产还是金融资产。筹资活动现金流可以看出公司的融资渠道、债务偿还压力以及对股东的回报情况。</li><li><strong>预测未来现金流和偿债能力</strong>：现金流量表是进行未来现金流预测和评估公司偿还短期及长期债务能力的重要依据。</li><li><strong>识别潜在的财务风险</strong>：例如，持续依赖筹资活动现金流入来弥补经营活动和投资活动的现金流出，可能意味着公司财务状况不可持续。</li></ol><p><strong>小结：三张报表的关联性</strong></p><p>资产负债表、利润表和现金流量表并非孤立存在，它们相互关联，共同描绘了公司的财务全貌：</p><ul><li>利润表中的<strong>净利润</strong>，在扣除股利分配后，会转入资产负债表中的<strong>未分配利润</strong>，从而影响<strong>所有者权益</strong>。</li><li>现金流量表中的<strong>期末现金及现金等价物余额</strong>，是资产负债表中<strong>货币资金</strong>项目的主要构成。</li><li>资产负债表中的资产（如固定资产、存货）和负债（如借款）的变化，会反映在现金流量表的投资活动和筹资活动中。例如，购买固定资产会减少投资活动现金流，并增加资产负债表中的固定资产。</li><li>利润表中的许多项目（如收入、成本）与现金流量表中的经营活动现金流项目有对应关系，但因会计确认基础不同（权责发生制vs. 收付实现制）而存在差异。</li></ul><p>学会阅读这三张财务报表，是进行基本面分析的第一步，也是最重要的一步。它需要耐心学习和不断实践。<strong>《手把手教你读财报》</strong>提供了许多实用的技巧和案例，帮助读者从细节中发现问题。而<strong>《证券分析》</strong>则从更宏观和审慎的角度，强调了通过财报分析来评估企业的内在价值和投资风险。鉴于本书的长度，本节说明的详细内容可以参考章节中提到的书籍进行详细了解。</p><h3 id="第二节关键财务指标">第二节：关键财务指标</h3><p>在学会阅读三张核心财务报表之后，我们还需要掌握一些关键的财务指标。这些指标就像医生的诊断工具，能够帮助我们从不同维度量化评估公司的经营状况、盈利能力、偿债能力、成长性和市场估值水平。单独看一个指标的绝对值意义有限，更重要的是进行<strong>趋势分析（与公司自身历史比较）*<em>和*</em>横向比较（与同行业竞争对手比较）</strong>，并理解每个指标背后的商业逻辑及其局限性。</p><h4 id="一盈利能力指标-profitability-ratios">一、盈利能力指标(Profitability Ratios)</h4><p>这些指标衡量公司从其经营活动中获取利润的能力。</p><p><strong>1. 毛利率 (Gross Profit Margin)</strong></p><ul><li><strong>是什么(What)</strong>：毛利率是衡量公司主营业务盈利空间的核心指标，反映了产品或服务的初始盈利能力，即扣除直接成本（如原材料、直接人工）后的利润占比。<ul><li><strong>计算公式</strong>：毛利率 = (营业收入 - 营业成本) / 营业收入× 100%</li><li>也等于：毛利率 = 毛利润 / 营业收入 × 100%</li></ul></li><li><strong>怎么做 (How to interpret)</strong>：<ul><li><strong>高毛利率</strong>通常意味着公司产品有较强的竞争力（如品牌优势、技术壁垒、独特资源），或者在产业链中有较强的议价能力。例如，高端白酒（如茅台）、软件行业（如微软）、医药行业（特别是专利药）通常具有较高的毛利率。</li><li><strong>低毛利率</strong>可能意味着行业竞争激烈、产品同质化严重，或者公司成本控制能力较弱。例如，大宗商品贸易、普通制造业、零售业的毛利率通常相对较低。</li><li><strong>趋势分析</strong>：持续稳定或上升的毛利率是积极信号；下降的毛利率则需要警惕，可能意味着竞争加剧或成本上升压力。</li></ul></li><li><strong>为什么 (Why it's important)</strong>：<ul><li>毛利率是企业利润的源头。没有足够的毛利空间，后续的费用（销售、管理、研发、财务）和税收就无从覆盖，更谈不上净利润。</li><li>巴菲特非常看重高且稳定的毛利率，认为这是公司拥有“经济护城河”的重要体现。</li></ul></li><li><strong>局限性</strong>：<ul><li>不同行业的毛利率水平差异很大，不能简单跨行业比较。</li><li>高毛利率不一定等于高净利润，如果后续费用控制不当，净利润依然可能很低。</li></ul></li><li><strong>现实实例</strong>：贵州茅台常年保持90%以上的毛利率，这得益于其强大的品牌和独特的酿造工艺。而许多超市零售行业的毛利率可能只有15%-25%。</li></ul><p><strong>2. 净利率 (Net Profit Margin)</strong></p><ul><li><strong>是什么(What)</strong>：净利率是衡量公司最终盈利能力的指标，反映了公司在扣除所有成本、费用和所得税后，每单位收入能产生多少净利润。<ul><li><strong>计算公式</strong>：净利率 = 净利润 / 营业收入 × 100%</li></ul></li><li><strong>怎么做 (How to interpret)</strong>：<ul><li><strong>高净利率</strong>表明公司综合盈利能力强，不仅产品有竞争力，而且在成本费用控制、运营效率等方面也表现出色。</li><li><strong>趋势分析</strong>：与毛利率类似，稳定或上升的净利率是好迹象。需要关注净利率变化的原因，是毛利率变化导致的，还是费用控制或税收政策变化导致的。</li><li><strong>与毛利率比较</strong>：如果毛利率很高，但净利率很低，说明公司的期间费用（销售、管理、研发费用）过高，需要分析其合理性和效率。</li></ul></li><li><strong>为什么 (Why it's important)</strong>：<ul><li>净利率直接关系到股东的回报。它综合反映了公司的经营效率和盈利水平。</li><li>投资者希望投资于那些能够持续创造高净利润的公司。</li></ul></li><li><strong>局限性</strong>：<ul><li>同样受行业特性影响。</li><li>一次性的非经营性损益（如资产处置、政府补助）可能会扭曲某一期间的净利率，需要剔除这些因素看核心盈利能力。</li></ul></li><li><strong>现实实例</strong>：苹果公司（AppleInc.）以其较高的净利率著称（通常在20%以上），这得益于其强大的品牌溢价、高效的供应链管理和高利润的生态系统。而航空公司由于高昂的燃油成本、维护费用和激烈的竞争，净利率通常较低。</li></ul><p><strong>3. 净资产收益率 (Return on Equity - ROE)</strong></p><ul><li><strong>是什么(What)</strong>：ROE是衡量公司利用股东投入的资本（净资产）创造利润的效率。它回答了“股东每投入1元钱，公司能赚回多少钱？”这个问题。ROE被认为是评估公司盈利能力和股东回报水平最重要的指标之一。<ul><li><strong>计算公式</strong>：ROE = 净利润 / 平均股东权益 × 100%<ul><li>（平均股东权益 = (期初股东权益 + 期末股东权益) / 2）</li></ul></li><li>巴菲特曾说，如果只能选择一个指标来判断一家公司的经营好坏，他会选择ROE。他偏爱那些能够持续创造高ROE（比如15%以上）且不需要过多负债的公司。</li></ul></li><li><strong>怎么做 (How to interpret)</strong>：<ul><li><strong>高ROE</strong>通常意味着公司具有良好的盈利能力和资本运用效率。</li><li><strong>杜邦分析 (DuPontAnalysis)</strong>：可以将ROE拆解为三个部分，以便更深入地分析其驱动因素：<ul><li><strong>ROE = 净利率 × 总资产周转率 × 权益乘数</strong><ul><li><strong>净利率</strong> (Net Profit Margin) = 净利润 / 营业收入(衡量盈利能力)</li><li><strong>总资产周转率</strong> (Total Asset Turnover) = 营业收入 /平均总资产 (衡量资产运用效率)</li><li><strong>权益乘数</strong> (Equity Multiplier) = 平均总资产 /平均股东权益(衡量财务杠杆，即公司用了多少倍的股东权益来撬动总资产，也反映了负债程度)</li></ul></li><li>通过杜邦分析，可以看出ROE的提升是来自于更高的利润率、更快的资产周转，还是更高的财务杠杆。健康的ROE提升应主要由前两者驱动。如果过度依赖高杠杆提升ROE，则风险较大。</li></ul></li></ul></li><li><strong>为什么 (Why it's important)</strong>：<ul><li>直接反映了股东投资的回报水平。</li><li>是衡量管理层为股东创造价值能力的重要标准。</li><li>长期保持高ROE的公司往往是优质的投资标的。</li></ul></li><li><strong>局限性</strong>：<ul><li>高ROE可能伴随着高负债（高权益乘数），需要结合负债率一起看。</li><li>净利润可能受到非经常性损益的影响，需要关注“扣非ROE”（扣除非经常性损益后的净利润计算的ROE）。</li><li>对于某些轻资产行业（如软件、咨询），ROE可能非常高，但不一定意味着比重资产行业（如制造业）的低ROE公司差，需要行业内比较。</li><li>如果公司大量回购股票导致股东权益减少，也可能推高ROE，需要具体分析。</li></ul></li><li><strong>历史实例</strong>：许多消费品巨头如可口可乐、宝洁，以及一些科技龙头如微软、谷歌，都曾在其黄金发展时期展现出持续较高且稳定的ROE水平。</li></ul><h4 id="二偿债能力指标-solvency-ratios">二、偿债能力指标 (SolvencyRatios)</h4><p>这些指标衡量公司偿还其债务的能力，关系到公司的财务安全和持续经营能力。</p><p><strong>4. 资产负债率 (Debt-to-Asset Ratio)</strong></p><ul><li><strong>是什么(What)</strong>：资产负债率是衡量公司总资产中有多少是通过负债筹集的，反映了公司的财务杠杆水平和偿债风险。<ul><li><strong>计算公式</strong>：资产负债率 = 总负债 / 总资产 × 100%</li></ul></li><li><strong>怎么做 (How to interpret)</strong>：<ul><li><strong>适度的负债</strong>可以利用财务杠杆效应，提高股东回报（如前面杜邦分析中的权益乘数）。</li><li><strong>过高的负债率</strong>则意味着公司偿债压力大，利息负担重，财务风险高，一旦经营出现问题或融资环境收紧，可能面临债务违约甚至破产的风险。</li><li>不同行业的合理负债率水平不同。资本密集型行业（如房地产、航空、银行）的负债率通常较高；而轻资产行业（如软件服务）的负债率通常较低。</li><li><strong>趋势分析</strong>：负债率持续快速上升需要警惕。</li></ul></li><li><strong>为什么 (Why it's important)</strong>：<ul><li>直接关系到公司的财务稳健性。</li><li>是债权人评估公司信用风险的重要指标。</li><li>也是股东评估投资风险的重要参考。</li></ul></li><li><strong>局限性</strong>：<ul><li>不能仅看绝对值，要结合行业特点和公司的具体情况（如负债结构、现金流状况）分析。</li><li>有些“优质负债”（如占用供应商资金的应付账款、客户预付的合同负债）可能反而体现了公司的强势地位。</li></ul></li><li><strong>现实实例</strong>：房地产开发企业通常资产负债率较高（如70%-80%甚至更高），因为其经营模式需要大量资金投入。而一些现金流充裕、盈利能力强的科技公司，如苹果，其资产负债率可能相对较低，或者即使较高，其偿债能力也因强大的现金储备而有保障。</li></ul><p><em>(除了资产负债率，还有流动比率、速动比率等衡量短期偿债能力的指标，这里先重点介绍资产负债率，其他可在后续章节或附录中补充)</em></p><h4 id="三市场估值指标-valuation-ratios">三、市场估值指标 (ValuationRatios)</h4><p>这些指标将公司的市场价格与其财务数据联系起来，用于评估当前股价是否合理，是“便宜”还是“昂贵”。</p><p><strong>5. 市盈率 (Price-to-Earnings Ratio - P/E)</strong></p><ul><li><strong>是什么(What)</strong>：市盈率是最常用也是最具争议的估值指标之一，它反映了投资者愿意为公司每1元净利润支付多少价格。可以理解为，在假设公司未来盈利不变的情况下，投资者需要多少年才能通过公司的盈利收回投资成本。<ul><li><strong>计算公式</strong>：市盈率 (P/E) = 每股市价 / 每股收益(EPS)</li><li>或者：市盈率 (P/E) = 公司总市值 / 公司净利润</li><li><strong>每股收益 (EPS)</strong> = 净利润 / 总股本</li></ul></li><li><strong>怎么做 (How to interpret)</strong>：<ul><li><strong>静态市盈率 (TrailingP/E)</strong>：用过去一年的每股收益计算。</li><li><strong>动态市盈率 (ForwardP/E)</strong>：用未来一年预测的每股收益计算。</li><li><strong>滚动市盈率 (TTMP/E)</strong>：用过去四个季度的每股收益计算。</li><li><strong>低市盈率</strong>可能意味着股票被低估，或者市场对公司未来增长前景不看好。</li><li><strong>高市盈率</strong>可能意味着股票被高估，或者市场对公司未来高增长有强烈预期（常见于成长股）。</li><li><strong>行业比较</strong>：不同行业的市盈率中枢不同。高成长行业（如科技、医药）的市盈率通常高于传统成熟行业（如银行、公用事业）。</li><li><strong>历史比较</strong>：将当前市盈率与公司自身的历史市盈率区间进行比较。</li><li><strong>PEG 指标</strong>：市盈率与盈利增长率的比值（P/E /G），用于评估成长股的估值合理性。彼得·林奇常用此指标，认为PEG接近1较为合理。</li></ul></li><li><strong>为什么 (Why it's important)</strong>：<ul><li>提供了一个快速衡量股票相对估值水平的工具。</li><li>是投资者进行投资决策的重要参考。</li></ul></li><li><strong>局限性</strong>：<ul><li><strong>不适用于亏损公司</strong>：净利润为负时，市盈率无意义。</li><li><strong>受会计政策影响</strong>：净利润的计算可能受到会计方法选择的影响。</li><li><strong>周期性行业</strong>：对于盈利波动较大的周期性行业（如钢铁、化工），在盈利高点时市盈率可能很低，但此时买入风险反而大；在盈利低谷甚至亏损时市盈率可能很高或无意义，但此时可能反而是投资机会。</li><li><strong>不能单独使用</strong>：需要结合公司的成长性、盈利质量、行业前景、风险等多种因素综合判断。</li></ul></li><li><strong>现实实例</strong>：在牛市中，许多热门科技股的市盈率可能高达数十倍甚至上百倍，反映了市场对其未来高速增长的极高预期。而在熊市或价值股中，一些盈利稳定的公司市盈率可能只有个位数或十几倍。</li></ul><p><strong>6. 市净率 (Price-to-Book Ratio - P/B)</strong></p><ul><li><strong>是什么(What)</strong>：市净率反映了投资者愿意为公司每1元净资产支付多少价格。<ul><li><strong>计算公式</strong>：市净率 (P/B) = 每股市价 / 每股净资产</li><li>或者：市净率 (P/B) = 公司总市值 / 公司净资产 (股东权益)</li><li><strong>每股净资产 (Book Value Per Share - BVPS)</strong> = 股东权益/ 总股本</li></ul></li><li><strong>怎么做 (How to interpret)</strong>：<ul><li><strong>P/B &lt;1</strong>：通常被认为股价低于其账面价值，可能存在低估（“破净”）。但这需要分析原因，是公司资产质量差、盈利能力弱，还是市场暂时错杀。</li><li><strong>P/B &gt;1</strong>：市场给予的估值高于其账面净资产，通常因为市场预期公司未来能通过这些净资产创造出超过其账面价值的回报（即ROE&gt; 市场要求的最低回报率）。</li><li><strong>适用行业</strong>：P/B更适用于那些资产价值相对稳定且易于衡量的重资产行业，如银行、保险、房地产、钢铁、公用事业等。因为这些行业的净资产（如贷款、厂房设备）对其盈利能力有直接影响。</li><li><strong>不适用行业</strong>：对于轻资产行业（如软件、咨询、品牌消费品），其核心价值往往在于无形资产（如技术、品牌、人力资本），这些很难在账面净资产中充分反映，因此P/B可能很高，参考意义不大。</li></ul></li><li><strong>为什么 (Why it's important)</strong>：<ul><li>提供了一个从资产角度评估公司价值的视角。</li><li>对于某些特定行业，是重要的估值参考。</li><li>在市场极端悲观时，P/B可以作为判断估值底线的一个参考（但不是绝对的）。</li></ul></li><li><strong>局限性</strong>：<ul><li><strong>账面价值的可靠性</strong>：净资产的账面价值可能与其实际市场价值或清算价值有较大差异（如存货积压、应收账款坏账、固定资产减值等）。</li><li><strong>忽略盈利能力和成长性</strong>：P/B主要关注存量资产，对公司的未来盈利能力和成长性反映不足。</li><li><strong>会计政策影响</strong>：不同的会计处理方法（如折旧方法）会影响净资产的计算。</li></ul></li><li><strong>现实实例</strong>：在金融危机期间，许多银行股的P/B一度跌破1，反映了市场对其资产质量和未来盈利能力的极度担忧。而一些高ROE的品牌消费品公司，其P/B可能常年保持在较高水平（如5倍以上）。</li></ul><p><strong>小结</strong></p><p>关键财务指标是投资者理解公司财务状况和投资价值的有力工具，但它们并非万能。每一个指标都有其特定的含义、适用范围和局限性。<strong>“理解先于行动”</strong>，在使用这些指标时，务必：</p><ol type="1"><li><strong>结合行业特点</strong>：不同行业的财务指标正常范围差异很大。</li><li><strong>进行趋势分析</strong>：观察指标在过去几年的变化趋势，比看单一时点的数据更有意义。</li><li><strong>进行横向比较</strong>：与同行业主要竞争对手进行比较，找出差异和原因。</li><li><strong>深入分析指标背后的驱动因素</strong>：不要满足于数字本身，要理解数字变化的原因。</li><li><strong>多个指标结合使用</strong>：综合运用多种指标，从不同角度印证判断，避免片面性。</li><li><strong>警惕财务粉饰</strong>：指标是基于财报数据计算的，如果财报本身存在水分，指标也会失真。</li></ol><p>通过本节的学习，我们掌握了分析公司财务状况的一些锐利“武器”。在下一节，我们将探讨如何将这些财务分析与对公司业务、管理、行业等方面的非财务因素分析结合起来，形成对公司基本面的完整认知。</p><h3 id="第三节定性分析入门">第三节：定性分析入门</h3><p>虽然财务报表和关键财务指标为我们提供了理解公司的量化视角，但数字本身并不能完全描绘一家公司的全貌，尤其是其未来的发展潜力和可持续性。<strong>定性分析</strong>关注的是那些难以用具体数字衡量，但对公司长期价值至关重要的因素，如公司的竞争优势（护城河）、管理层的能力与品格，以及所处行业的前景。这些因素共同构成了公司的“软实力”和“成长基因”。</p><h4 id="一护城河-economic-moat公司的持久竞争优势">一、护城河 (EconomicMoat)：公司的持久竞争优势</h4><p><strong>是什么 (What)：保护公司利润的无形壁垒</strong></p><p>“护城河”这个概念由沃伦·巴菲特发扬光大。他认为，优秀的公司就像一座坚固的城堡，能够持续产生高额利润；而<strong>护城河就是环绕在城堡周围，抵御竞争对手入侵，保护城堡利润的持久竞争优势。</strong>拥有宽阔且深厚护城河的公司，能够在更长时间内保持其盈利能力和市场份额，为股东创造持续的回报。</p><ul><li><strong>通俗理解</strong>：想象古代的城堡，有高墙、深河、吊桥等防御工事，使得敌人难以攻破。公司的护城河就是其独特的“防御工事”，让竞争对手难以模仿或超越。</li><li><strong>与财务指标的联系</strong>：拥有强大护城河的公司，通常会在财务上表现为持续较高的毛利率、净利率和净资产收益率（ROE）。</li></ul><p><strong>怎么做 (How)：识别常见的护城河类型</strong></p><p>识别和评估公司的护城河是价值投资和成长投资的核心环节。常见的护城河类型包括：</p><ol type="1"><li><strong>无形资产 (Intangible Assets)</strong>：<ul><li><strong>品牌(Brand)</strong>：强大的品牌意味着消费者信任、忠诚度和溢价能力。消费者愿意为知名品牌支付更高的价格，或者在众多选择中优先选择该品牌。<ul><li><strong>现实实例</strong>：可口可乐的品牌价值连城，使其在全球饮料市场占据主导地位；苹果公司的品牌吸引了大量忠实用户，并能支撑其产品的较高定价。奢侈品品牌如路易威登、爱马仕更是品牌力量的极致体现。</li></ul></li><li><strong>专利(Patents)</strong>：专利为公司在一定时期内提供了对其发明创造的独家使用权，阻止竞争对手复制其产品或技术，尤其在医药、科技等行业至关重要。<ul><li><strong>现实实例</strong>：辉瑞公司对其明星药物（如立普妥、伟哥）的专利保护，使其在专利期内获得了巨额利润。高通公司在移动通信领域的专利积累，使其能够向几乎所有手机制造商收取专利费。</li></ul></li><li><strong>特许经营权/牌照 (Licenses andFranchises)</strong>：政府授予的特定经营许可，或难以获得的行业准入资格，可以限制竞争者的数量。<ul><li><strong>现实实例</strong>：广播电视、烟草、某些金融服务领域通常需要特定的牌照。赌场牌照也是一种强大的特许经营权。</li></ul></li></ul></li><li><strong>转换成本 (Switching Costs)</strong>：<ul><li>指客户从一家公司的产品或服务转换到另一家公司的产品或服务时，所需要付出的时间、金钱、精力、风险或便利性损失。高转换成本会“锁定”客户，使他们倾向于继续使用现有产品或服务，即使竞争对手提供了略好或略便宜的选择。</li><li><strong>现实实例</strong>：<ul><li><strong>企业软件</strong>：如微软的Windows操作系统和Office办公套件，一旦企业和个人习惯了其生态系统，更换到其他平台的成本（学习成本、数据迁移成本、兼容性成本）非常高。SAP的企业资源规划（ERP）系统也是如此。</li><li><strong>银行服务</strong>：个人或企业更换主要银行账户，需要转移自动扣款、工资发放、投资账户等，过程繁琐。</li><li><strong>某些专业设备或平台</strong>：一旦用户投入大量时间和精力学习并适应了某个平台的操作逻辑（如某些设计软件、金融交易终端），轻易不会更换。</li></ul></li></ul></li><li><strong>网络效应 (Network Effects)</strong>：<ul><li>指一个产品或服务的价值随着用户数量的增加而增加。用户越多，产品对新老用户的吸引力就越大，形成正反馈循环，从而构筑起强大的竞争壁垒。</li><li><strong>现实实例</strong>：<ul><li><strong>社交媒体</strong>：如微信、Facebook。你的朋友都在用，所以你也更有可能使用，并且难以离开，因为离开意味着失去与这个网络的连接。</li><li><strong>电商平台</strong>：如淘宝/天猫、亚马逊。越多的卖家吸引越多的买家，越多的买家也吸引越多的卖家。</li><li><strong>操作系统</strong>：如iOS和Android。越多的用户吸引越多的开发者为其开发应用，越多的应用又吸引越多的用户。</li></ul></li></ul></li><li><strong>成本优势 (Cost Advantages)</strong>：<ul><li>指公司能够以比竞争对手更低的成本生产和提供产品或服务，从而使其能够以更低的价格竞争，或者在相同价格下获得更高的利润率。</li><li>常见的成本优势来源：<ul><li><strong>规模经济 (Economies ofScale)</strong>：随着产量的增加，单位产品的固定成本被摊薄，从而降低总成本。大型制造商、零售商通常具有规模优势。<ul><li><strong>现实实例</strong>：沃尔玛通过其巨大的采购量和高效的物流系统，能够从供应商那里获得更低的进货价格，并以具有竞争力的价格销售给消费者。</li></ul></li><li><strong>独特的流程或技术 (Proprietary Process orTechnology)</strong>：拥有更高效的生产流程或独特的技术，能够显著降低成本。<ul><li><strong>现实实例</strong>：西南航空通过标准化的机队、高效的机场周转、点对点的航线网络等运营模式，实现了比传统航空公司更低的运营成本。</li></ul></li><li><strong>地理位置优势或独特的资源获取 (Location or Unique Access toResources)</strong>：例如，靠近原材料产地或主要消费市场的工厂可以节省运输成本；拥有独家矿产资源的公司具有天然的成本优势。</li></ul></li></ul></li></ol><p><strong>为什么 (Why)：护城河的重要性</strong></p><ol type="1"><li><strong>利润的持续性</strong>：护城河是公司长期保持高盈利能力和抵御竞争的关键。</li><li><strong>定价权</strong>：拥有强大护城河的公司往往具有更强的定价权，可以将成本上升转嫁给消费者，或在不降低销量的情况下提高价格。</li><li><strong>抵御行业冲击</strong>：在行业面临不利因素或竞争加剧时，拥有护城河的公司更有可能生存下来并最终胜出。</li><li><strong>预测的可靠性</strong>：对于拥有清晰且持久护城河的公司，其未来现金流的预测也相对更可靠，这对于估值至关重要。</li></ol><p><strong>判断护城河的注意事项</strong>：</p><ul><li><strong>动态变化</strong>：护城河并非一成不变，技术进步、商业模式创新、政策变化等都可能削弱甚至摧毁原有的护城河。例如，柯达曾因其胶卷技术和品牌拥有强大护城河，但在数码时代未能及时转型而被颠覆。</li><li><strong>宽度与深度</strong>：不仅要看护城河的类型，还要评估其“宽度”（能抵御多少竞争者）和“深度”（能持续多久）。</li><li><strong>警惕“伪护城河”</strong>：有些看似优势的因素（如暂时的市场领先、优秀的产品但易被模仿）可能并非真正的、持久的护城河。</li></ul><h4 id="二管理层判断-management-assessment">二、管理层判断 (ManagementAssessment)</h4><p><strong>是什么 (What)：掌舵人的能力与品格</strong></p><p>公司的管理层是战略的制定者和执行者，他们的能力、远见、诚信和资本配置能力对公司的长期发展和股东回报至关重要。即使公司拥有良好的业务和护城河，糟糕的管理层也可能将其葬送。</p><ul><li><strong>通俗理解</strong>：管理层就像一艘船的船长和船员。船再好，如果船长能力不行或人品有问题，船也可能触礁或偏离航向。</li></ul><p><strong>怎么做 (How)：评估管理层</strong></p><p>评估管理层是一个复杂且主观性较强的过程，但可以从以下几个方面入手：</p><ol type="1"><li><strong>能力 (Competence)</strong>：<ul><li><strong>过往业绩 (TrackRecord)</strong>：管理层（尤其是CEO）过去的经营业绩如何？是否带领公司取得了持续的增长和良好的财务表现？是否成功应对过行业挑战或危机？</li><li><strong>战略眼光与执行力 (Strategic Vision andExecution)</strong>：管理层对行业发展趋势是否有清晰的判断？制定的战略是否合理且具有前瞻性？战略的执行效果如何？</li><li><strong>运营效率 (OperationalEfficiency)</strong>：管理层在成本控制、资产运用、流程优化等方面的能力如何？</li><li><strong>资本配置能力 (Capital AllocationSkill)</strong>：这是巴菲特非常看重的一点。管理层如何运用公司产生的现金流？是用于扩大核心业务、进行有前景的并购、回购股票、还是派发股息？他们的资本配置决策是否为股东创造了价值？糟糕的资本配置（如盲目多元化、高价进行劣质并购）会摧毁股东价值。<ul><li><strong>现实实例</strong>：迪士尼在罗伯特·艾格 (Robert Iger)领导下，通过一系列成功的并购（皮克斯、漫威、卢卡斯影业、福克斯），极大地拓展了其IP版图和业务范围，展现了卓越的资本配置能力。</li></ul></li></ul></li><li><strong>诚信与品格 (Integrity and Character)</strong>：<ul><li><strong>坦诚透明 (Transparency andCandor)</strong>：管理层是否对股东坦诚，尤其是在公司遇到困难或犯错误时？他们发布的年报、公告等信息是否真实、完整、易于理解？</li><li><strong>股东利益至上 (Alignment with ShareholderInterests)</strong>：管理层的薪酬激励机制是否与股东长期利益挂钩？他们是否将股东的钱当作自己的钱一样审慎使用？是否存在损害小股东利益的行为（如不合理的关联交易、过高的个人待遇）？</li><li><strong>言行一致 (Consistency between Words andActions)</strong>：管理层过去所说的目标和承诺是否得到兑现？</li><li><strong>声誉(Reputation)</strong>：管理层在行业内和公众中的声誉如何？</li><li><strong>警惕信号</strong>：频繁更换审计师、复杂的关联交易、模糊不清的财务披露、管理层丑闻等都可能是危险信号。</li></ul></li><li><strong>如何获取信息</strong>：<ul><li><strong>公司年报、公告、投资者关系材料</strong>：尤其是致股东信，可以看出管理层的思路和态度。</li><li><strong>管理层访谈、业绩发布会</strong>：观察管理层的言谈举止和对问题的回应。</li><li><strong>媒体报道、行业分析报告</strong>。</li><li><strong>员工评价、供应商和客户反馈（如果能获取）</strong>。</li></ul></li></ol><p><strong>为什么 (Why)：管理层的重要性</strong></p><ol type="1"><li><strong>战略方向盘</strong>：管理层决定了公司的发展方向和战略重点。</li><li><strong>资源分配者</strong>：管理层掌握着公司资源的分配权，其决策直接影响公司效率和股东回报。</li><li><strong>文化塑造者</strong>：管理层对企业文化的形成有关键影响，而优秀的企业文化是公司持续成功的软实力。</li><li><strong>风险控制者</strong>：诚信可靠的管理层是投资者利益的重要保障。</li></ol><h4 id="三行业前景分析-industry-outlook">三、行业前景分析 (IndustryOutlook)</h4><p><strong>是什么 (What)：公司所处赛道的“风向”与“空间”</strong></p><p>一家公司无论多优秀，其发展都会受到所处行业大环境的影响。“水大鱼大”，处于高速成长、前景广阔的行业中的公司，更容易获得发展机会；而处于夕阳行业或竞争格局恶化的行业中的公司，即使自身很努力，也可能面临增长的天花板。</p><ul><li><strong>通俗理解</strong>：选择行业就像选择你要参加的比赛项目。是选择一个参与者众多、奖金丰厚且规则不断演进的新兴项目，还是一个参与者日渐稀少、关注度下降的传统项目？</li></ul><p><strong>怎么做 (How)：分析行业前景</strong></p><ol type="1"><li><strong>行业生命周期 (Industry LifeCycle)</strong>：判断行业目前处于哪个发展阶段？<ul><li><strong>导入期(Introduction)</strong>：新技术、新产品出现，市场需求不确定，风险高，但潜在回报也高。</li><li><strong>成长期(Growth)</strong>：市场需求快速增长，技术逐渐成熟，竞争者增多，行业利润丰厚。这是投资的黄金时期。<ul><li><strong>现实实例</strong>：过去十年的移动互联网、近年来的新能源汽车、人工智能等行业都处于或经历过高速成长期。</li></ul></li><li><strong>成熟期(Maturity)</strong>：市场需求增长放缓，行业集中度提高，竞争激烈，利润率可能下降，龙头企业通过品牌、规模、效率取胜。</li><li><strong>衰退期(Decline)</strong>：市场需求萎缩，被新技术或替代品取代，行业内企业面临转型或退出压力。<ul><li><strong>现实实例</strong>：传统胶卷行业、功能手机行业等。</li></ul></li></ul></li><li><strong>市场规模与增长潜力 (Market Size and GrowthPotential)</strong>：<ul><li>行业的整体市场规模有多大？未来的增长空间如何？驱动行业增长的主要因素是什么（技术进步、政策支持、消费升级、人口结构变化等）？</li><li><strong>天花板有多高</strong>：即使是好公司，如果行业空间有限，其长期增长也会受限。</li></ul></li><li><strong>行业竞争格局 (Competitive Landscape - Porter's FiveForces)</strong>：<ul><li>迈克尔·波特的“五力模型”是分析行业竞争结构的经典框架：<ul><li><strong>现有竞争者的威胁 (Rivalry among ExistingCompetitors)</strong>：行业内竞争对手的数量和实力如何？价格战是否频繁？产品同质化程度高吗？</li><li><strong>潜在进入者的威胁 (Threat of NewEntrants)</strong>：新公司进入这个行业的壁垒高吗（资金、技术、品牌、渠道、政策等）？</li><li><strong>替代品的威胁 (Threat of Substitute Products orServices)</strong>：是否存在其他产品或服务能够满足同样的需求？替代品的性价比如何？</li><li><strong>供应商的议价能力 (Bargaining Power ofSuppliers)</strong>：上游供应商是否集中？他们提供的原材料或部件是否关键且难以替代？</li><li><strong>购买者的议价能力 (Bargaining Power ofBuyers)</strong>：下游客户是否集中？他们转换成本高吗？对价格敏感吗？</li></ul></li><li>通过分析这五种力量，可以判断行业的整体盈利潜力和吸引力。</li></ul></li><li><strong>技术变革与创新 (Technological Changes andInnovation)</strong>：<ul><li>行业是否受到快速的技术变革影响？公司是否具备持续创新的能力以适应变化？</li><li>技术是颠覆性的还是渐进性的？</li></ul></li><li><strong>政策与监管环境 (Regulatory Environment)</strong>：<ul><li>行业是否受到政府政策的显著影响（鼓励、限制、补贴、税收等）？政策的稳定性和可预测性如何？</li><li><strong>现实实例</strong>：教育培训行业、医药集采、新能源补贴政策等都对相关行业产生了巨大影响。</li></ul></li></ol><p><strong>为什么 (Why)：行业分析的重要性</strong></p><ol type="1"><li><strong>识别成长机会</strong>：帮助投资者找到具有长期增长潜力的“好赛道”。</li><li><strong>规避系统性风险</strong>：避免投资于处于衰退期或竞争格局持续恶化的行业。</li><li><strong>理解公司业绩的驱动因素</strong>：公司业绩的好坏，很多时候是行业景气度的反映。</li><li><strong>辅助公司估值</strong>：行业前景直接影响对公司未来增长的预期，从而影响估值。</li></ol><p><strong>小结</strong></p><p>定性分析与定量分析相辅相成，共同构成了对一家公司基本面进行全面评估的基础。</p><ul><li><strong>护城河</strong>决定了公司能否在竞争中保持优势并持续盈利。</li><li><strong>管理层</strong>是公司战略的制定者和执行者，其能力和品格直接影响公司的命运。</li><li><strong>行业前景</strong>则为公司的发展提供了舞台和天花板。</li></ul><p>进行定性分析需要广泛阅读、独立思考、长期跟踪和经验积累。它不像财务分析那样有固定的公式，更多的是一种商业洞察力和判断力的体现。在投资决策中，那些能够准确识别出宽阔护城河、优秀管理层和良好行业前景的公司，并以合理价格买入的投资者，往往能够获得丰厚的长期回报。</p><h3 id="第四节估值基础">第四节：估值基础</h3><p>在通过财务分析（定量）和商业分析（定性）对一家公司有了深入的了解之后，投资决策的最后一步，也是至关重要的一步，就是<strong>估值(Valuation)</strong>。估值的核心目标是判断一家公司的股票当前的市场价格与其内在价值相比，是便宜了、贵了，还是合理。只有当价格低于价值时，才具备足够的安全边际和潜在回报空间。</p><h4 id="一内在价值-intrinsic-value">一、内在价值 (Intrinsic Value)</h4><p><strong>是什么 (What)：公司真正的经济价值</strong></p><p><strong>内在价值是指一家企业在其余下生命周期内可以产生的、并能分配给所有者的自由现金流量的折现值。</strong>这是由本杰明·格雷厄姆在<strong>《证券分析》</strong>中提出并由巴菲特等价值投资者所信奉的核心概念。</p><ul><li><strong>通俗理解</strong>：想象你要买一个会下蛋的母鸡。这只母鸡的内在价值，不是它现在的体重乘以鸡肉的市场价，也不是别人昨天买类似母鸡的价格，而是这只母鸡未来一生能为你下的所有鸡蛋，以及最后把母鸡卖掉的钱，把这些未来的钱折算到今天值多少钱。</li><li><strong>《证券分析第五版》</strong>强调，内在价值是一个估计值，而非精确的数字。它取决于对公司未来盈利能力、现金流、成长性、风险等因素的预测和判断，因此带有一定的主观性。不同的分析师对同一家公司的内在价值评估可能不同。</li><li><strong>关键在于“近似正确”而非“精确错误”</strong>：估值的目标不是得到一个精确到小数点后两位的数字，而是得出一个大致的价值区间，并判断当前股价与这个区间的关系。</li></ul><p><strong>怎么做 (How)：理解内在价值的驱动因素</strong></p><p>内在价值主要由以下因素驱动：</p><ol type="1"><li><strong>未来现金流的产生能力 (Future Cash FlowGeneration)</strong>：公司未来能赚多少自由现金流？这是核心。自由现金流是指公司经营活动产生的现金流扣除为维持现有生产经营能力所需的资本性支出后，可供股东和债权人分配的现金。</li><li><strong>现金流的成长性 (Growth Rate of CashFlows)</strong>：公司未来的现金流是以什么速度增长？是高速增长、稳定增长还是缓慢增长甚至负增长？</li><li><strong>现金流的持续性与确定性 (Duration and Certainty of CashFlows)</strong>：公司产生这些现金流的能力能持续多久？其确定性有多高（即风险有多大）？拥有强大护城河的公司，其现金流的持续性和确定性通常更高。</li><li><strong>折现率 (DiscountRate)</strong>：由于未来的现金流不如今天的现金流有价值（因为时间价值和风险），我们需要用一个折现率将未来的现金流折算回今天的现值。折现率通常反映了投资的机会成本和该项投资的风险水平。风险越高的公司，折现率应该越高。</li></ol><p><strong>为什么 (Why)：内在价值是投资的锚</strong></p><ol type="1"><li><strong>投资决策的基石</strong>：只有估算出内在价值，才能判断市场价格是否合理，从而做出买入、持有或卖出的决策。</li><li><strong>安全边际的来源</strong>：当市场价格显著低于内在价值时，就形成了安全边际，这是保护投资者免受误判和市场不利波动的缓冲垫。</li><li><strong>避免市场情绪干扰</strong>：内在价值提供了一个相对客观的“锚”，帮助投资者在市场狂热或恐慌时保持理性，不被短期价格波动所迷惑。</li></ol><h4 id="二相对估值法-relative-valuation">二、相对估值法 (RelativeValuation)</h4><p><strong>是什么 (What)：与同类资产比较定价</strong></p><p>相对估值法不直接估算公司的绝对内在价值，而是通过比较目标公司与同行业、同规模或具有相似风险和成长特征的可比公司（或其自身历史水平）的某些估值乘数（如P/E、P/B、P/S、EV/EBITDA等），来判断目标公司的估值是否合理。</p><ul><li><strong>通俗理解</strong>：就像买房子，你会看看同小区、同户型、类似楼层和装修的房子最近都卖多少钱一平米，以此来判断你想买的这套房子的报价是否合理。</li><li><strong>核心逻辑</strong>：“相似的资产应该有相似的价格（或估值倍数）”。</li></ul><p><strong>怎么做 (How)：常见的相对估值指标与方法</strong></p><p>我们在第二节“关键财务指标”中已经介绍过市盈率 (P/E) 和市净率(P/B)，它们是最常用的相对估值指标。</p><ol type="1"><li><strong>市盈率对比法 (P/E Multiple Approach)</strong>：<ul><li><strong>步骤</strong>：<ol type="1"><li>选择一组与目标公司业务相似、规模相当、风险和成长性可比的公司。</li><li>计算这些可比公司的平均市盈率（或中位数市盈率）。</li><li>用可比公司的平均市盈率乘以目标公司的每股收益（或预测每股收益），得到目标公司的一个参考股价。</li></ol></li><li><strong>历史P/E对比</strong>：将目标公司当前的P/E与其自身的历史P/E区间进行比较。</li><li><strong>现实实例</strong>：假设A公司是一家软件公司，其EPS为2元/股。通过分析，发现同行业类似规模和成长性的可比公司平均P/E为30倍。那么A公司的参考股价可能是2元/股 × 30 =60元/股。如果A公司当前股价为50元，则可能被认为相对低估。</li></ul></li><li><strong>市净率对比法 (P/B Multiple Approach)</strong>：<ul><li>逻辑与P/E对比类似，只是用P/B和每股净资产进行比较。更适用于银行、保险等重资产行业。</li></ul></li><li><strong>其他相对估值指标</strong>：<ul><li><strong>市销率 (Price-to-Sales Ratio - P/S)</strong>：= 市值 /营业收入。适用于亏损或利润不稳定的成长型公司，或周期性行业。</li><li><strong>企业价值/EBITDA (EV/EBITDA)</strong>：EV = 市值 + 总负债 -总现金及现金等价物；EBITDA =息税折旧摊销前利润。该指标剔除了不同公司间资本结构、税收政策和折旧摊销政策差异的影响，更适合跨国或不同会计准则下的公司比较。</li></ul></li></ol><p><strong>为什么 (Why)：相对估值法的优势与局限性</strong></p><ul><li><strong>优势</strong>：<ul><li><strong>简单易懂，易于计算和使用</strong>。</li><li><strong>数据容易获取</strong>。</li><li><strong>能够反映当前市场对某一类资产的普遍看法和情绪</strong>。</li></ul></li><li><strong>局限性</strong>：<ul><li><strong>“相对”而非“绝对”</strong>：如果整个行业或市场都被高估（或低估），那么通过相对估值法得出的“合理”估值也可能是高估（或低估）的。它告诉你的是“相对便宜”，但不一定是“绝对便宜”。<ul><li><strong>历史实例</strong>：在2000年互联网泡沫时期，许多科技股的P/E都非常高，如果仅仅进行行业内比较，可能会觉得某些股票“还不够贵”，但实际上整个行业都处于巨大的泡沫中。</li></ul></li><li><strong>可比公司的选择非常关键</strong>：找到真正具有可比性的公司很困难，公司之间总会存在差异。</li><li><strong>容易受到市场短期情绪的影响</strong>。</li><li><strong>对于独特或创新型公司，可能找不到合适的可比对象</strong>。</li></ul></li></ul><h4 id="三绝对估值法-absolute-valuation---以dcf为例">三、绝对估值法(Absolute Valuation) - 以DCF为例</h4><p><strong>是什么 (What)：估算公司自身的内在价值</strong></p><p>绝对估值法试图通过分析公司的基本面（主要是未来现金流的产生能力）来估算其内在价值，而不依赖于与其他公司的比较。其中最经典和理论上最完善的方法是<strong>贴现现金流估值法(Discounted Cash Flow - DCF)</strong>。</p><ul><li><strong>核心逻辑</strong>：正如前面“内在价值”部分所述，一家公司的价值等于其未来所有自由现金流的现值总和。</li><li><strong>《DCF贴现现金流估值原理》</strong>这类书籍会详细阐述其数学模型和应用细节，但对于初学者，理解其基本思想更为重要。</li></ul><p><strong>怎么做 (How)：DCF估值的基本步骤（概念理解）</strong></p><ol type="1"><li><strong>预测未来自由现金流 (Forecast Future Free Cash Flows -FCF)</strong>：<ul><li>这是DCF模型中最关键也最困难的一步。需要基于对公司业务、行业前景、竞争优势、管理层等的深入分析，预测公司在未来一定时期内（通常是5-10年）每年能产生的自由现金流。</li><li><strong>自由现金流 (FCF)</strong>可以有多种计算方法，一种常用的是：FCF = 经营活动现金流量净额 -资本性支出。</li></ul></li><li><strong>预测永续期价值/终值 (Forecast Terminal Value -TV)</strong>：<ul><li>由于不可能无限期地预测现金流，DCF模型通常会将预测期分为两段：明确预测期（如5-10年）和永续期（明确预测期之后的所有年份）。</li><li>终值是指明确预测期之后所有年份自由现金流的现值。通常假设公司在永续期以一个稳定的、较低的增长率（如等于或略高于长期通胀率或名义GDP增长率）持续增长。</li><li>计算终值有多种方法，如永续增长模型 (Gordon Growth Model)或退出倍数法。</li></ul></li><li><strong>确定折现率 (Determine Discount Rate)</strong>：<ul><li>折现率用于将未来的自由现金流和终值折算回今天的现值。常用的折现率是<strong>加权平均资本成本(Weighted Average Cost of Capital - WACC)</strong>。</li><li>WACC考虑了公司股权融资成本和债务融资成本的加权平均值，反映了投资于该公司所需承担的风险。</li><li>WACC的计算较为复杂，涉及无风险利率、市场风险溢价、Beta系数（衡量公司股价相对于市场波动的敏感性）、公司债务成本、股权和债务在资本结构中的权重等。</li></ul></li><li><strong>计算现值并加总 (Discount Cash Flows and Sum Up)</strong>：<ul><li>将预测期每年的自由现金流和永续期终值，分别用折现率折算到今天的现值。</li><li>将所有这些现值加总，就得到了公司的企业价值 (Enterprise Value - EV)或股权价值 (EquityValue)。如果得到的是企业价值，还需要减去净负债（总负债 -总现金）才能得到股权价值。</li><li>用股权价值除以总股本，就得到了每股内在价值。</li></ul></li></ol><p><strong>为什么 (Why)：DCF估值法的优势与局限性</strong></p><ul><li><strong>优势</strong>：<ul><li><strong>基于基本面</strong>：DCF直接关注公司产生现金流的能力，这是价值的根本来源。</li><li><strong>提供了对价值驱动因素的洞察</strong>：构建DCF模型的过程迫使分析师深入思考公司的成长性、盈利能力、资本支出、风险等核心要素。</li><li><strong>不受市场短期情绪影响</strong>：它试图估算公司的“真实”价值，而非仅仅是市场价格。</li><li><strong>灵活性高</strong>：可以根据不同的假设进行情景分析和敏感性分析。</li></ul></li><li><strong>局限性</strong>：<ul><li><strong>高度依赖假设 (“Garbage In, GarbageOut”)</strong>：DCF的输出结果对未来现金流预测、增长率假设和折现率选择非常敏感。如果假设不合理，结果也会失之千里。<ul><li><strong>现实实例</strong>：对于一家初创科技公司，其未来现金流极不确定，增长路径也难以预测，使用DCF估值的难度非常大，结果的可靠性也较低。</li></ul></li><li><strong>计算复杂，耗时费力</strong>。</li><li><strong>永续期价值占比通常很高</strong>：终值在整个估值结果中可能占到一半以上，而终值的计算本身也依赖于较强的假设。</li><li><strong>难以应用于某些类型的公司</strong>：如处于困境、重组或业务模式快速变化的公司，其未来现金流难以预测。</li></ul></li></ul><p><strong>小结：估值是一门艺术，也是一门科学</strong></p><p>估值没有绝对完美的方法，每种方法都有其适用场景和优缺点。</p><ul><li><strong>相对估值法</strong>更像是在“选美”，看市场上其他人喜欢什么样的，简单快捷，但容易随波逐流。</li><li><strong>绝对估值法（如DCF）</strong>更像是在“称重”，试图找到物体本身的真实分量，理论上更严谨，但对“秤”（假设和预测）的要求很高。</li></ul><p><strong>福利：本书最后会有一个小章节专门解释估值方法及应用。</strong></p><p>聪明的投资者通常会<strong>综合运用多种估值方法</strong>，相互印证，并结合对公司基本面的深入理解，最终形成对公司价值的判断。更重要的是，要始终牢记<strong>安全边际</strong>原则，即只在市场价格显著低于自己估算的内在价值时才考虑买入。</p><hr /><h3 id="总结公司分析与估值基础">总结：公司分析与估值基础</h3><p>在本章中，我们深入探索了理解一家公司的核心方法，从阅读财务语言到评估其内在价值。</p><p>我们首先学习了<strong>财务报表入门</strong>，详细了解了三大核心报表：</p><ul><li><strong>资产负债表</strong>：公司的“家底”快照，展示了在特定时点公司拥有什么（资产）、欠了什么（负债）以及真正属于股东的有多少（所有者权益）。我们熟悉了其基本恒等式“资产= 负债 + 所有者权益”以及主要科目的现实含义。</li><li><strong>利润表</strong>：公司的“经营成绩单”，反映了在一定时期内公司是赚钱了还是亏钱了，以及利润的构成和来源。</li><li><strong>现金流量表</strong>：公司的“现金收支簿”，追踪了现金的流入和流出，揭示了公司真实的“造血”能力和财务健康状况。我们强调了三张报表之间的关联性，以及它们作为公司“体检报告”的重要性，借鉴了《手把手教你读财报》、《巴菲特教你读财报》和《证券分析》中的智慧。</li></ul><p>接着，我们学习了如何从财报数据中提炼出<strong>关键财务指标</strong>，包括：</p><ul><li><strong>盈利能力指标</strong>：毛利率、净利率、净资产收益率(ROE)，以及ROE的杜邦分析。</li><li><strong>偿债能力指标</strong>：资产负债率。</li><li><strong>市场估值指标</strong>：市盈率 (P/E) 和市净率 (P/B)。我们理解了这些指标的计算方法、经济含义、如何解读以及各自的局限性，强调了趋势分析和横向比较的重要性。</li></ul><p>然后，我们从定量分析转向<strong>定性分析入门</strong>，探讨了那些难以量化但至关重要的因素：</p><ul><li><strong>护城河（竞争优势）</strong>：识别了品牌、专利、转换成本、网络效应和成本优势等常见的护城河类型，理解了其对于保护公司长期利润的重要性。</li><li><strong>管理层判断</strong>：从能力（过往业绩、战略眼光、资本配置能力等）和诚信品格两个方面评估公司的掌舵人。</li><li><strong>行业前景分析</strong>：通过行业生命周期、市场规模与增长潜力、竞争格局（波特五力模型）、技术变革和政策环境等维度，判断公司所处赛道的“风向”与“空间”。</li></ul><p>最后，我们接触了<strong>估值基础</strong>，这是连接分析与决策的关键环节：</p><ul><li>理解了<strong>内在价值</strong>的核心概念，即公司未来自由现金流的折现值。</li><li>了解了两种主要的估值方法：<ul><li><strong>相对估值法</strong>：通过与可比公司或历史水平的估值乘数（如P/E、P/B）进行比较来判断估值。</li><li><strong>绝对估值法</strong>：以<strong>DCF（贴现现金流）模型</strong>为例，理解了其试图估算公司自身内在价值的基本逻辑和步骤，即预测未来现金流并将其折现。我们强调了估值是一门艺术与科学的结合，需要综合运用多种方法，并始终坚守<strong>安全边际</strong>原则。</li></ul></li></ul><p>贯穿本章，我们依然秉持<strong>“理解先于行动”</strong>的核心原则。通过学习阅读财报、分析关键指标、进行定性和定量分析，并初步掌握估值的基本概念，我们为做出更明智的投资决策打下了坚实的基础。</p><p><strong>给读者的行动建议</strong>：理论学习固然重要，但实践才能出真知。在不投入真实资金的前提下，我们强烈建议读者开始进行一些<strong>模拟交易</strong>或<strong>案例分析</strong>：</p><ol type="1"><li><strong>选择你感兴趣的1-2家上市公司</strong>（可以是你知道的品牌，或者你日常接触到的产品/服务提供商）。</li><li><strong>尝试去查找并阅读它们的年度财务报告</strong>（通常在公司官网的“投资者关系”栏目或证券交易所网站可以找到）。</li><li><strong>对照本章学习的内容，尝试识别资产负债表、利润表、现金流量表中的主要科目，并计算一些关键财务指标</strong>（如毛利率、净利率、ROE、P/E、P/B）。</li><li><strong>思考这些公司的护城河可能是什么？它们的管理层如何？所处行业前景怎样？</strong></li><li><strong>尝试用相对估值法（如P/E对比）对其进行一个非常粗略的估值判断</strong>。这个过程可能会遇到很多困难和疑问，这非常正常。关键是开始动手，将学到的知识应用起来，在实践中加深理解。记住，<strong>“理论结合实践”</strong>和 <strong>“保持耐心和好奇心”</strong> 是我们不断进步的动力。</li></ol><h2 id="第三章策略深化与组合构建">第三章：策略深化与组合构建</h2><p><strong>目标：</strong>深入理解不同的投资策略，学习资产配置和风险管理，开始形成自己的投资框架。</p><h3 id="第一节深入价值投资">第一节：深入价值投资</h3><p>在第一章我们初步接触了价值投资的核心思想，将其定义为寻找并买入那些当前市场价格低于其内在价值的证券。本节我们将更深入地挖掘价值投资的精髓，探讨其背后的原理、关键的应用方法，并从投资大师的智慧中汲取养分。价值投资不仅仅是一种投资技巧，更是一种商业哲学和处世智慧。</p><h4id="一价值投资的底层逻辑与核心原则">一、价值投资的底层逻辑与核心原则</h4><p><strong>是什么(What)：价值投资的再认识——以商业视角看待股票</strong></p><p>价值投资的奠基人本杰明·格雷厄姆在其划时代著作<strong>《聪明的投资者》</strong>中开宗明义地指出：<strong>“投资操作是基于透彻的分析，确保本金安全并能获得满意回报的行为。不满足这些条件的操作就是投机。”</strong>这句话为价值投资设定了三个核心支柱：</p><ol type="1"><li><strong>透彻的分析 (ThoroughAnalysis)</strong>：价值投资者将购买股票视为购买一家企业的部分所有权，而非仅仅是一串代码或一张可以买卖的纸片。因此，他们会像企业家评估一笔生意一样，深入研究公司的基本面，包括其财务状况、盈利能力、竞争优势、管理层、行业前景等。这种分析是基于事实和数据的，而非市场传言或短期情绪。</li><li><strong>本金安全 (Safety ofPrincipal)</strong>：这是价值投资的首要考虑。价值投资者厌恶永久性的资本损失。他们追求的不是一夜暴富，而是长期、可持续的财富增值。实现本金安全的核心手段就是<strong>安全边际</strong>。</li><li><strong>满意回报 (SatisfactoryReturn)</strong>：在确保本金安全的前提下，价值投资者寻求获得令人满意的回报。这个“满意”并非指追求最高的短期收益，而是指符合其风险承受能力和长期目标的合理回报。它通常意味着超越市场平均水平或无风险利率的回报。</li></ol><p>塞思·卡拉曼在其著作<strong>《安全边际》</strong>（这本书本身就是价值投资的经典，虽然市面上较难获得原版）中，进一步强调了价值投资的风险规避特性。他认为，价值投资本质上是<strong>“在风险和不确定性面前保持谦逊，并坚持以低于内在价值的价格购买”</strong>。</p><p><strong>价值投资的核心原则可以概括为：</strong></p><ul><li><strong>股票即企业所有权</strong>：将自己视为企业的合伙人，关注企业的长期经营和价值创造。</li><li><strong>市场先生的隐喻</strong>：市场短期是投票机（受情绪影响），长期是称重机（反映真实价值）。利用市场先生的非理性报价，而非被其左右。</li><li><strong>内在价值是基石</strong>：相信每家公司都有其内在价值，投资者的任务是估算它。</li><li><strong>安全边际是王道</strong>：只在市场价格显著低于估算的内在价值时买入，为错误和不利因素留出缓冲。</li><li><strong>逆向思考，独立判断</strong>：不盲从大众，敢于在市场恐慌时买入被低估的优质资产，在市场狂热时保持警惕。</li></ul><h4 id="怎么做-how价值投资的实践方法论">怎么做(How)：价值投资的实践方法论</h4><p>深入价值投资并非易事，它需要严格的纪律、持续的学习和独立的思考。以下是一些关键的应用方法：</p><p><strong>1. 深入研究公司基本面 (Fundamental Research)</strong></p><ul><li><strong>定量分析回顾</strong>：<ul><li><strong>财务报表分析</strong>：仔细研读资产负债表、利润表、现金流量表，分析公司的盈利能力（毛利率、净利率、ROE）、财务健康状况（负债率、现金流）、运营效率（周转率）等。</li><li><strong>财务指标的趋势与比较</strong>：关注关键指标的长期趋势，并与同行业竞争对手进行比较，找出优势与劣势。</li></ul></li><li><strong>定性分析深化</strong>：<ul><li><strong>理解商业模式</strong>：公司是如何赚钱的？其产品或服务的核心竞争力是什么？客户是谁？供应商是谁？</li><li><strong>评估护城河的宽度与深度</strong>：如前所述，深入分析公司的无形资产、转换成本、网络效应、成本优势等，判断其护城河是否真实、持久、且难以逾越。<ul><li><strong>历史实例</strong>：巴菲特长期持有喜诗糖果 (See'sCandies)，正是看中了其强大的品牌忠诚度和定价权，这构成了其坚实的护城河，使其能够持续提价并保持高利润率，即使原材料成本上涨。</li></ul></li><li><strong>考察管理层的品格与能力</strong>：管理层是否诚信可靠？是否具备优秀的资本配置能力？是否与股东利益一致？（参考第二章第三节）</li><li><strong>分析行业前景与竞争格局</strong>：公司所处的行业是否具有长期增长潜力？行业竞争是否过于激烈？（参考第二章第三节）</li></ul></li></ul><p><strong>2. 估算内在价值 (Estimating Intrinsic Value)</strong></p><ul><li><strong>回顾估值方法</strong>：<ul><li><strong>绝对估值法（如DCF）</strong>：理论上最符合内在价值的定义，但高度依赖假设。价值投资者会倾向于使用保守的假设进行估算。</li><li><strong>相对估值法（如P/E、P/B）</strong>：作为参考和交叉验证，但要警惕其“相对性”陷阱。价值投资者会寻找那些不仅相对便宜，而且绝对价值也被低估的标的。</li><li><strong>其他估值方法</strong>：如资产重置成本法（评估重建公司现有资产需要多少成本）、清算价值法（评估公司立即停止运营并变卖所有资产能获得多少价值，这是格雷厄姆早期常用的方法，尤其适用于账面价值可靠的公司）。</li></ul></li><li><strong>注重保守估计</strong>：在估算内在价值时，价值投资者倾向于保守，给予未来预期一定的折让，以应对不确定性。他们宁愿“模糊的正确”，也不要“精确的错误”。</li></ul><p><strong>3. 坚持安全边际 (Insisting on a Margin ofSafety)</strong></p><ul><li><strong>什么是安全边际？</strong> 安全边际 = 估算的内在价值 -市场价格。或者以百分比表示：安全边际率 = (估算的内在价值 - 市场价格) /估算的内在价值 × 100%。</li><li><strong>安全边际的重要性</strong>：<ul><li><strong>抵御估算错误</strong>：内在价值的估算不可能完全精确，安全边际为这种不精确提供了缓冲。</li><li><strong>抵御未来不利变化</strong>：即使公司未来经营出现未预料到的困难，或者宏观经济环境恶化，安全边际也能提供一定的保护。</li><li><strong>提供超额回报的潜力</strong>：以较大的折扣买入，当市场价格回归内在价值时，投资者能获得可观的回报。</li></ul></li><li><strong>安全边际的大小</strong>：没有固定的标准，取决于多种因素，如公司的质量、估值的确定性、市场的整体风险水平等。格雷厄姆建议，对于普通股票，至少需要三分之一（约33%）的安全边际（即以不高于内在价值三分之二的价格买入）。对于债券，安全边际体现在发行人的偿债能力远超其债务负担。</li><li><strong>《安全边际》</strong>一书中，卡拉曼反复强调，追求安全边际是价值投资者区别于其他市场参与者的核心特征。他认为，安全边际不是在好光景下锦上添花，而是在坏光景下救命稻草。</li><li><strong>历史实例</strong>：在市场恐慌性抛售时，例如2008年金融危机期间，许多优质公司的股价被大幅打压，远低于其长期内在价值，这为坚持安全边际的价值投资者提供了绝佳的买入机会。巴菲特在危机期间对高盛、通用电气等公司的投资，正是利用了这种市场错配。</li></ul><p><strong>4. 利用市场波动 (Exploiting Market Fluctuations - Mr.Market)</strong></p><ul><li>格雷厄姆在《聪明的投资者》中创造了“市场先生”这个经典比喻。市场先生每天都会向你报价，有时他情绪高涨，报出非常高的价格；有时他情绪低落，报出非常低的价格。</li><li><strong>价值投资者的态度</strong>：<ul><li><strong>不被市场先生的情绪左右</strong>：不要因为市场先生今天高兴（股价上涨）就跟着买，也不要因为他今天沮丧（股价下跌）就恐慌性抛售。</li><li><strong>将市场先生视为服务者而非指导者</strong>：利用市场先生提供的报价。当他报出远低于你对公司内在价值评估的价格时，就是买入的好机会。当他报出远高于内在价值的价格时，可以考虑卖出。如果他的报价既不高也不低，你可以选择忽略他，继续持有。</li></ul></li><li><strong>逆向投资的本质</strong>：价值投资往往带有逆向色彩，因为寻找被低估的资产通常意味着在市场不看好、甚至恐慌的时候买入。这需要强大的心理素质和独立思考能力。</li></ul><p><strong>5. 长期持有与耐心 (Long-Term Horizon andPatience)</strong></p><ul><li>价值投资不是一种快速致富的方法。市场价格回归到内在价值可能需要较长时间，有时是几年甚至更久。</li><li><strong>复利的力量</strong>：长期持有优质公司的股票，可以让复利效应充分发挥作用，实现财富的指数级增长。</li><li><strong>减少交易成本和税收</strong>：频繁交易会产生不必要的佣金和税费，侵蚀投资回报。</li><li><strong>给企业成长的时间</strong>：对于投资于优秀的企业，长期持有可以分享企业成长带来的价值提升。</li><li><strong>霍华德·马克斯</strong>在其著作<strong>《投资最重要的事》</strong>中，多次强调了“第二层次思维”和“耐心等待机会”的重要性。他认为，许多投资者只看到表象（第一层次思维），而价值投资者需要看得更深、更远，理解事物背后的复杂性和周期性，并有耐心等待“好球”出现。</li></ul><h4 id="为什么-why价值投资的持久魅力与挑战">为什么(Why)：价值投资的持久魅力与挑战</h4><p><strong>价值投资的持久魅力：</strong></p><ol type="1"><li><strong>经过时间检验的成功策略</strong>：从格雷厄姆到巴菲特，再到许多其他成功的价值投资者，他们的长期业绩证明了价值投资的有效性。</li><li><strong>强调风险控制</strong>：安全边际原则将风险控制放在首位，这使得价值投资在长期内更具韧性，尤其是在市场动荡时期。</li><li><strong>符合商业常识</strong>：将投资视为购买企业所有权，关注企业的真实价值，这符合基本的商业逻辑。</li><li><strong>提供清晰的决策框架</strong>：为投资者提供了一套相对完整和理性的分析与决策流程。</li><li><strong>培养独立思考能力</strong>：要求投资者不盲从市场，进行独立研究和判断。</li></ol><p><strong>价值投资面临的挑战：</strong></p><ol type="1"><li><strong>需要极大的耐心和纪律性</strong>：在市场狂热或股价长期不涨时，坚持价值投资原则非常困难。</li><li><strong>估值的主观性和不确定性</strong>：内在价值的估算本身就存在难度和主观性。</li><li><strong>“价值陷阱” (ValueTrap)</strong>：有些股票看起来便宜，但其基本面在持续恶化，导致股价永远无法回归所谓的“价值”，甚至进一步下跌。识别并避开价值陷阱是价值投资者的重要功课。这通常需要区分是“便宜的好公司”还是“便宜的烂公司”。</li><li><strong>在某些市场阶段可能表现不佳</strong>：例如，在由少数高成长科技股驱动的“疯牛”行情中，传统的价值股可能表现落后，这会考验投资者的定力。</li><li><strong>信息获取与分析的挑战</strong>：深入的基本面研究需要投入大量的时间和精力。</li></ol><p><strong>价值投资的演进：从格雷厄姆到巴菲特</strong></p><p>值得注意的是，价值投资本身也在演进。</p><ul><li><strong>格雷厄姆早期</strong>更侧重于“烟蒂股”投资，即寻找那些股价极低，甚至低于其清算价值的公司，即使公司本身不是特别优秀，但只要足够便宜，就有投资价值。这在当时的市场环境下是有效的。</li><li><strong>巴菲特和芒格</strong>则将价值投资的理念与对“优质企业”的关注结合起来，提出了<strong>“以合理的价格买入优秀的公司，远胜于以便宜的价格买入平庸的公司。”</strong>他们更强调公司的护城河、管理层质量和长期成长性。这种方法更适应现代资本市场。</li></ul><p><strong>小结</strong></p><p>深入价值投资，意味着要培养一种像企业家一样思考的习惯，关注企业的长期内在价值而非短期的市场价格波动。它要求投资者具备扎实的分析能力、保守的估值态度、严格的纪律、以及超乎常人的耐心。虽然价值投资之路充满挑战，但其强调风险控制、追求可持续回报的核心理念，使其成为值得每一位严肃投资者学习和践行的投资哲学。记住，正如格雷厄姆所说，投资的秘诀在于<strong>“安全边际”</strong>。而霍华德·马克斯则提醒我们，<strong>“最重要的不是预测未来，而是为未来做好准备，并坚持自己的原则。”</strong></p><h3 id="第二节深入成长投资">第二节：深入成长投资</h3><p>与价值投资强调“买得便宜”不同，成长投资的核心在于寻找那些具有卓越增长潜力的公司，并期望通过分享其未来的高速成长来获取丰厚回报。成长投资者相信，一家公司的价值主要由其未来的盈利增长能力决定，因此他们愿意为这种预期的增长支付相对较高的价格。本节我们将深入探讨成长投资的原理、应用方法，并警示其中潜藏的“增长陷阱”。</p><h4id="一成长投资的底层逻辑与核心要素">一、成长投资的底层逻辑与核心要素</h4><p><strong>是什么(What)：成长投资的再认识——投资于未来的“明星企业”</strong></p><p>成长投资，顾名思义，是<strong>专注于识别并投资于那些预期其收入、利润、市场份额等关键指标能够以远超行业平均水平和整体经济增长速度持续快速增长的公司。</strong>成长投资者如同星探，试图在众多企业中发掘出未来的“超级明星”。</p><ul><li><strong>菲利普·费雪 (PhilipFisher)</strong>，虽然常被归为成长投资的先驱，但他的理念其实融合了对“优质”和“成长”的深度关注。他的著作《怎样选择成长股》(CommonStocks and Uncommon Profits)影响了包括巴菲特在内的许多投资者。费雪强调通过“闲聊法”（深入调研公司的客户、供应商、竞争对手、前员工等）来全面了解一家公司的竞争优势和成长潜力。</li><li><strong>彼得·林奇 (Peter Lynch)</strong>在其畅销书<strong>《彼得·林奇的成功投资》(One Up On WallStreet)</strong>中，以其幽默风趣的语言和贴近生活的案例，将成长投资的理念普及给了大众。他鼓励普通投资者从自己熟悉的产品和服务中寻找“十倍股”(Tenbaggers)。</li></ul><p><strong>成长投资的核心要素可以概括为：</strong></p><ol type="1"><li><strong>高增长性 (High GrowthPotential)</strong>：这是成长投资的灵魂。公司必须展现出在未来几年内实现远高于市场平均水平的营收和利润增长的能力。</li><li><strong>广阔的市场空间 (Large AddressableMarket)</strong>：公司所处的行业或细分市场需要有足够的空间来支撑其持续的高增长。一个“小池塘”很难养出“大鱼”。</li><li><strong>强大的竞争优势/护城河 (Strong CompetitiveAdvantages/Moat)</strong>：仅仅有高增长的预期是不够的，公司还需要有可持续的竞争优势来保护其增长果实不被竞争对手轻易侵蚀。这与价值投资对护城河的关注有共通之处，只是成长投资更看重护城河能否支持其持续扩张。</li><li><strong>优秀的管理团队 (Excellent ManagementTeam)</strong>：能够引领公司抓住市场机遇、有效执行增长战略、并管理好快速扩张带来的挑战的管理层至关重要。</li><li><strong>合理的估值（相对于增长性而言）(Reasonable Valuation Relativeto Growth -GARP)</strong>：虽然成长投资者愿意为增长支付溢价，但并非不计成本。许多成熟的成长投资者会奉行“以合理价格成长”(Growthat a Reasonable Price -GARP)的策略，试图在增长性和估值之间找到平衡。</li></ol><p><strong>《聪明的投资者》</strong>中，格雷厄姆虽然主要倡导价值投资，但也承认成长股的吸引力，但他警告说，预测未来的高增长非常困难，且市场往往对成长股给予过高的估值，从而抵消了其增长潜力带来的回报，甚至带来巨大风险。</p><h4 id="怎么做-how成长投资的实践方法论">怎么做(How)：成长投资的实践方法论</h4><p>寻找并投资于真正的成长股是一项极具挑战性的任务，需要敏锐的洞察力、深入的研究和一定的风险承受能力。</p><p><strong>1. 识别高成长行业与趋势 (Identifying High-Growth Industriesand Trends)</strong></p><ul><li><strong>关注新兴技术与创新</strong>：如人工智能、生物科技、新能源、云计算、物联网等领域，往往孕育着高成长机会。</li><li><strong>洞察社会与消费变迁</strong>：如人口老龄化带来的医疗健康需求、消费升级带来的品牌与体验需求、数字化生活方式的普及等。</li><li><strong>政策导向与支持</strong>：某些行业会因为得到国家政策的大力支持而迎来快速发展期。</li><li><strong>彼得·林奇</strong>强调从日常生活中发现趋势。比如，他注意到妻子喜欢Hanes公司的连裤袜，进而研究该公司并获得了丰厚回报。</li></ul><p><strong>2. 筛选具有成长潜力的公司 (Screening for Potential GrowthCompanies)</strong></p><ul><li><strong>财务指标筛选</strong>：<ul><li><strong>营收增长率 (Revenue GrowthRate)</strong>：过去几年营收是否持续高速增长（如年均20%以上）？</li><li><strong>利润增长率 (Earnings GrowthRate)</strong>：净利润增长是否与营收增长同步甚至更快？</li><li><strong>毛利率和净利率趋势</strong>：是否能保持稳定或提升？高增长如果伴随着利润率的持续下滑，其质量会大打折扣。</li><li><strong>研发投入占比 (R&amp;D Expenditure as a Percentage ofSales)</strong>：对于科技、医药等创新驱动型行业，持续的研发投入是未来增长的保障。</li></ul></li><li><strong>定性因素考察</strong>：<ul><li><strong>产品/服务的独特性与创新性</strong>：公司是否拥有难以复制的领先产品或创新服务？</li><li><strong>市场份额的扩大能力</strong>：公司是否在不断蚕食竞争对手的份额，或者在开辟新的市场？</li><li><strong>客户粘性与口碑</strong>：客户是否对公司的产品/服务有较高的忠诚度？口碑如何？</li></ul></li></ul><p><strong>3. 深入分析成长驱动力与可持续性 (Analyzing Growth Drivers andSustainability)</strong></p><ul><li><strong>增长是内生还是外延？</strong><ul><li><strong>内生增长 (OrganicGrowth)</strong>：依靠自身核心业务的拓展、新产品的推出、效率的提升等实现的增长，通常被认为质量更高，更可持续。</li><li><strong>外延增长 (InorganicGrowth)</strong>：通过并购等方式实现的增长。需要警惕公司是否为了追求规模而进行不经济的并购，或者并购后的整合效果不佳。</li></ul></li><li><strong>增长的天花板有多高？</strong>公司目前的市场渗透率如何？未来还有多大的增长空间？</li><li><strong>护城河能否支撑持续增长？</strong>公司的竞争优势是否能够随着规模的扩张而增强（如网络效应），或者至少不被削弱？</li><li><strong>管理层的执行能力与适应性</strong>：管理层是否有能力驾驭快速增长带来的组织、管理、资金等方面的挑战？是否能够根据市场变化及时调整战略？</li></ul><p><strong>4. 评估估值的合理性 (Assessing ValuationReasonableness)</strong></p><p>这是成长投资中最具挑战性的环节之一。因为成长股通常伴随着较高的估值（如高P/E、高P/B）。</p><ul><li><strong>市盈率相对盈利增长比率 (PEG - Price/Earnings to GrowthRatio)</strong>：<ul><li><strong>PEG = P/E / (未来1-5年预期年均每股收益增长率 ×100)</strong></li><li>彼得·林奇认为，PEG等于1是比较合理的水平。PEG远小于1可能意味着低估，远大于1则可能意味着高估。</li><li><strong>优点</strong>：将估值与成长性联系起来，提供了一个相对直观的判断标准。</li><li><strong>缺点</strong>：对未来盈利增长率的预测非常关键且困难；不适用于盈利不稳定或亏损的公司。</li></ul></li><li><strong>市销率 (P/SRatio)</strong>：对于尚未盈利或利润很低的初创期成长公司，市销率可能比市盈率更有参考价值。但需要结合其未来的盈利能力预期来看。</li><li><strong>绝对估值法（如DCF）的审慎运用</strong>：虽然DCF对成长股的估值难度很大（因为未来现金流预测的不确定性高），但通过构建不同情景下的DCF模型（乐观、中性、悲观），可以帮助投资者理解在不同增长假设下公司的价值区间，以及当前股价隐含了多高的增长预期。</li><li><strong>警惕“为增长支付过高价格”</strong>：霍华德·马克斯在<strong>《投资最重要的事》</strong>中提醒投资者，即使是最好的公司，如果买入价格过高，也可能变成糟糕的投资。成长本身并不必然带来超额回报，关键在于你为这份成长支付了多少。</li></ul><p><strong>5. 持续跟踪与动态调整 (Continuous Monitoring and DynamicAdjustment)</strong></p><ul><li>成长股的经营环境和竞争格局变化迅速，其业绩表现也可能波动较大。因此，成长投资者需要：<ul><li><strong>密切跟踪公司的季报、年报、新闻动态、行业变化</strong>。</li><li><strong>定期重新评估其成长逻辑是否依然成立，增长速度是否符合预期</strong>。</li><li><strong>当发现公司的基本面发生重大不利变化，或者增长不及预期，或者估值变得极度泡沫化时，应考虑减持或卖出</strong>。</li></ul></li></ul><h4 id="三警惕增长陷阱-avoiding-growth-traps">三、警惕“增长陷阱”(Avoiding "Growth Traps")</h4><p>成长投资充满诱惑，但也遍布陷阱。投资者需要保持清醒的头脑，避免以下常见的“增长陷阱”：</p><ol type="1"><li><strong>为增长支付过高的价格 (Overpaying forGrowth)</strong>：这是最常见的陷阱。市场往往对热门成长股寄予过高期望，导致其股价远超其内在价值，即使公司未来实现了不错的增长，投资者也可能因为买入成本太高而无法获得满意回报，甚至亏损。<ul><li><strong>历史实例</strong>：2000年互联网泡沫时期，许多“.com”公司即使没有任何盈利，甚至商业模式都不清晰，也被炒到极高的估值，最终泡沫破裂，投资者损失惨重。</li></ul></li><li><strong>“成长幻觉” (Growth Illusion)</strong>：<ul><li><strong>不可持续的增长</strong>：某些公司可能在短期内依靠某些偶然因素（如一次性的大订单、行业短期过热）实现了高速增长，但这种增长缺乏持续性。</li><li><strong>低质量的增长</strong>：例如，通过大幅降价牺牲利润换来的营收增长，或者通过大量并购但整合效果不佳实现的规模扩张，这种增长的“含金量”不高。</li><li><strong>“伪成长股”</strong>：有些公司可能只是处于周期性行业的景气上升期，被误认为是成长股。当行业周期逆转时，其业绩会大幅下滑。</li></ul></li><li><strong>忽视竞争格局恶化 (Ignoring Worsening CompetitiveLandscape)</strong>：即使公司曾经拥有竞争优势，但如果行业进入门槛降低，大量新竞争者涌入，或者现有竞争对手采取激进策略，公司的护城河可能会被削弱，增长难以持续。</li><li><strong>管理层能力与诚信风险 (Management Competence and IntegrityRisks)</strong>：<ul><li>快速成长对管理层的能力提出了极高要求。如果管理层无法有效应对扩张带来的挑战，或者在成功后变得自满、决策失误，都可能葬送公司的成长前景。</li><li>某些管理层可能为了维持股价而粉饰业绩，甚至财务造假。</li></ul></li><li><strong>技术路径风险 (Technological PathRisk)</strong>：对于科技行业，技术更新迭代速度非常快。如果公司押注的技术路径最终被证明是错误的，或者未能跟上新的技术趋势，可能会迅速被市场淘汰。<ul><li><strong>历史实例</strong>：诺基亚在智能手机时代未能及时转型，错失了移动操作系统的发展机遇。</li></ul></li></ol><p><strong>如何规避增长陷阱？</strong></p><ul><li><strong>坚持严格的估值纪律</strong>：即使是最好的成长故事，也要有价格上限。</li><li><strong>深入研究，独立思考</strong>：不要轻信市场上的热门概念和“故事”，要进行扎实的基本面分析。</li><li><strong>关注增长的质量和可持续性</strong>，而不仅仅是增长的速度。</li><li><strong>分散投资</strong>：不要将所有赌注押在一两只成长股上。</li><li><strong>保持怀疑精神</strong>：正如塞思·卡拉曼在<strong>《安全边际》</strong>中所强调的，对过于美好的前景要保持警惕。</li></ul><p><strong>成长投资与价值投资的融合</strong></p><p>值得注意的是，价值投资与成长投资并非完全对立，而是可以相互融合的。巴菲特的名言“以合理的价格买入优秀的公司”本身就体现了这种融合。他寻找的是那些既具有良好成长前景（“优秀的公司”），又能在市场提供合理估值时（“合理的价格”）买入的标的。这种GARP策略（Growthat a Reasonable Price）是许多成熟投资者的选择。</p><p><strong>小结</strong></p><p>深入成长投资，意味着要具备前瞻性的眼光，去发现那些能够引领未来、创造巨大价值的企业。它要求投资者不仅要关注当下的财务数据，更要洞察行业趋势、理解商业模式的演变、评估管理层的远见卓识。成长投资的回报潜力巨大，但风险也相对较高。投资者需要有能力区分真正的“千里马”与虚假的“概念股”，并警惕各种“增长陷阱”。记住，持续的盈利增长是驱动公司价值提升的核心动力，但只有在付出合理价格的前提下，这种增长才能最终转化为投资者的满意回报。</p><h3 id="第三节指数基金投资">第三节：指数基金投资</h3><p>在前两节我们深入探讨了主动选股的两种主流策略——价值投资和成长投资，它们都需要投资者具备较高的专业知识、投入大量的时间精力，并承担选错股或择时失误的风险。对于大多数普通投资者而言，是否存在一种更简单、更省心，且长期来看依然能获得不错回报的投资方式呢？答案是肯定的，那就是<strong>指数基金投资</strong>。</p><h4id="一指数基金投资的原理与核心优势">一、指数基金投资的原理与核心优势</h4><p><strong>是什么(What)：指数基金投资的再认识——搭乘市场整体发展的“便车”</strong></p><p><strong>指数基金是一种被动管理的投资基金，其目标是复制特定市场指数（如标普500、沪深300、纳斯达克100等）的表现。</strong>购买指数基金，就相当于购买了该指数所包含的一揽子成分股（或债券），从而分散了投资于单一证券的风险，并力求获得与市场整体（或特定板块）相当的平均回报。</p><ul><li><strong>约翰·博格 (JohnBogle)</strong>，先锋集团的创始人，被誉为“指数基金教父”。他毕生致力于推广低成本的指数化投资理念，认为对于绝大多数投资者而言，试图通过主动管理战胜市场是徒劳的，而指数基金能够以极低的成本提供市场平均回报，长期下来反而能跑赢大部分主动管理型基金。他的名言<strong>“不要在大海捞针，直接把整个草堆买下来！”</strong>形象地说明了指数投资的精髓。</li></ul><p><strong>指数基金的核心优势：</strong></p><ol type="1"><li><strong>成本极低 (Extremely Low Cost)</strong>：<ul><li><strong>原理</strong>：指数基金是被动跟踪指数，不需要高薪聘请基金经理进行频繁的个股研究和交易决策，因此其管理费、托管费等运营成本远低于主动管理型基金。</li><li><strong>影响</strong>：约翰·博格反复强调<strong>“成本是投资的头号敌人”</strong>。长期来看，即使每年只有1%-2%的费用差异，在复利效应下也会对最终回报产生巨大影响。低成本意味着投资者能将更多的市场回报留在自己口袋里。</li><li><strong>现实实例</strong>：美国市场上一些主流的标普500指数ETF的年费率甚至可以低至0.03%-0.05%，而主动管理型股票基金的费率通常在1%-2%甚至更高。</li></ul></li><li><strong>高度分散风险 (Highly Diversified)</strong>：<ul><li><strong>原理</strong>：指数基金通常持有其所跟踪指数的全部或绝大部分成分股。一个宽基指数（如沪深300、标普500）往往包含数百只来自不同行业的股票。</li><li><strong>影响</strong>：通过投资一只指数基金，投资者就能自动实现对众多股票的分散投资，有效降低了个别公司“爆雷”（如财务造假、经营失败）带来的非系统性风险。你不再需要担心自己选的某一只股票表现不佳，因为你的收益取决于一篮子股票的整体表现。</li><li><strong>“永远不会破产”</strong>：单个公司可能会破产，但代表整个国家或区域经济的宽基指数几乎不可能归零（除非发生极端灾难）。指数会定期调整成分股，剔除不符合标准的公司，纳入新的优质公司，具有自我进化和新陈代谢的能力。</li></ul></li><li><strong>透明度高 (High Transparency)</strong>：<ul><li><strong>原理</strong>：指数的编制规则和成分股构成通常是公开透明的，投资者可以清楚地知道自己的钱投向了哪里。指数基金的持仓也会定期披露，且与指数成分高度一致。</li><li><strong>影响</strong>：相比之下，一些主动管理型基金的持仓策略和调整可能不那么透明，投资者有时难以完全了解基金经理的具体操作。</li></ul></li><li><strong>长期业绩大概率跑赢多数主动基金 (Long-Term Performance Likelyto Outperform Most Active Funds)</strong>：<ul><li><strong>原理</strong>：这似乎有悖直觉，但大量实证研究（如标普道琼斯指数公司发布的SPIVA报告）反复证明，在任何一个较长的时期内（如10年、15年、20年），绝大多数（通常是70%-90%）主动管理型股票基金在扣除费用后，其业绩都跑不赢相应的市场基准指数。</li><li><strong>原因</strong>：<ul><li><strong>市场有效性</strong>：在信息相对发达的今天，市场在一定程度上是有效的，持续发现被错误定价的股票并战胜市场非常困难。</li><li><strong>成本拖累</strong>：如前所述，主动基金的高费率会侵蚀其超额收益（如果能产生的话）。</li><li><strong>均值回归</strong>：少数短期表现优异的基金经理，长期来看其业绩也可能回归平均水平。</li></ul></li><li><strong>巴菲特的赌局</strong>：巴菲特曾公开打赌，在10年内，一只低成本的标普500指数基金的业绩将跑赢一组由专业人士挑选的对冲基金组合。最终，巴菲特轻松获胜，再次印证了指数投资的长期优势。</li></ul></li><li><strong>简单易行，省时省力 (Simple and Effortless)</strong>：<ul><li><strong>原理</strong>：投资者不需要花费大量时间和精力去研究个股、分析财报、预测市场时机。选择好合适的指数基金后，长期持有即可。</li><li><strong>影响</strong>：这使得指数基金非常适合那些没有足够专业知识、时间或兴趣进行主动投资的普通人。它可以让投资变得不再复杂和焦虑。</li></ul></li></ol><h4 id="怎么做-how选择指数基金与制定投资策略">怎么做(How)：选择指数基金与制定投资策略</h4><p>虽然指数基金投资相对简单，但在具体实践中，仍有一些关键点需要注意：</p><p><strong>1. 选择合适的指数 (Choosing the Right Index)</strong></p><ul><li><strong>理解指数的编制规则和代表性</strong>：不同的指数代表不同的市场、行业、风格或资产类别。<ul><li><strong>宽基指数 (Broad MarketIndexes)</strong>：覆盖范围广，代表性强，适合作为核心配置。<ul><li><strong>国内常见</strong>：沪深300（代表A股大盘蓝筹）、中证500（代表A股中小盘）、创业板指、科创50等。</li><li><strong>海外常见</strong>：标普500（代表美国大盘股）、纳斯达克100（代表美国科技股）、MSCI全球指数（代表全球发达和新兴市场）等。</li></ul></li><li><strong>行业/主题指数 (Sector/ThematicIndexes)</strong>：聚焦于特定行业（如消费、医药、科技、新能源）或特定投资主题。适合对某些行业有特别看好的投资者，但风险相对更集中。</li><li><strong>策略/风格指数 (Strategy/FactorIndexes)</strong>：如红利指数（投资于高股息率股票）、价值指数、成长指数、低波动指数等。</li></ul></li><li><strong>根据自己的投资目标、风险承受能力和投资期限选择</strong>：<ul><li>长期稳健投资：优先选择覆盖面广、代表性强的核心宽基指数。</li><li>看好特定行业：可以适当配置相关行业指数基金，但要注意控制比例。</li><li>全球资产配置：可以考虑投资跟踪海外主要市场（如美股、港股）或全球市场的指数基金。</li></ul></li></ul><p><strong>2. 选择优质的指数基金产品 (Selecting Quality Index FundProducts)</strong></p><p>即使是跟踪同一指数的基金，不同基金公司的产品在细节上也会有差异。主要关注以下几个方面：</p><ul><li><strong>跟踪误差 (Tracking Error)</strong>：<ul><li><strong>是什么</strong>：指指数基金的净值增长率与其所跟踪的目标指数的增长率之间的差异程度。跟踪误差越小，说明基金复制指数的效果越好。</li><li><strong>原因</strong>：基金的申购赎回、现金拖累（基金需要保留少量现金以应对赎回）、成分股调整时的交易成本、基金费用等都可能导致跟踪误差。</li><li><strong>怎么看</strong>：可以查看基金的定期报告，或者在第三方基金平台上比较不同基金的跟踪误差数据。选择跟踪误差较小的产品。</li></ul></li><li><strong>费率 (Expense Ratio)</strong>：<ul><li><strong>是什么</strong>：包括管理费、托管费等。这是投资者直接付出的成本。</li><li><strong>怎么看</strong>：在同类指数基金中，选择费率尽可能低的产品。对于长期投资，费率的细微差异也会累积成显著的影响。</li></ul></li><li><strong>基金规模 (Fund Size / Assets Under Management -AUM)</strong>：<ul><li><strong>是什么</strong>：基金管理的总资产规模。</li><li><strong>影响</strong>：规模过小的基金可能面临清盘风险，或者因为规模效应不足导致运营成本相对较高、跟踪误差较大。通常选择规模适中或较大的基金相对更稳妥。</li></ul></li><li><strong>基金公司实力与声誉 (Fund Company's Strength andReputation)</strong>：选择那些在指数基金管理方面经验丰富、风控能力强、声誉良好的基金公司。</li><li><strong>基金类型：ETF vs. 场外指数基金 (ETF vs. Off-Exchange IndexFund)</strong><ul><li><strong>ETF (Exchange Traded Fund -交易所交易基金)</strong>：像股票一样在证券交易所上市交易，需要开设股票账户购买。交易灵活，盘中可以实时买卖，交易费用通常是券商佣金。流动性好的ETF，其买卖价差较小。</li><li><strong>场外指数基金（联接基金或普通开放式指数基金）</strong>：通过银行、第三方基金销售平台（如支付宝、天天基金网）等渠道申购赎回。申购赎回按日终净值计算，通常有申购费和赎回费（持有时间越长，赎回费越低甚至免除）。</li><li><strong>选择</strong>：对于有股票账户、喜欢灵活交易的投资者，ETF更方便。对于习惯在场外平台操作、或者希望进行基金定投的投资者，场外指数基金更便捷。许多ETF也有对应的场外联接基金。</li></ul></li></ul><p><strong>3. 制定并坚持投资策略 (Formulating and Adhering to anInvestment Strategy)</strong></p><ul><li><strong>长期持有 (Buy andHold)</strong>：指数投资的核心在于分享市场长期的β收益（市场平均收益）。频繁买卖不仅增加交易成本，也容易错失市场上涨的机会。选择好指数基金后，最重要的就是“拿得住”。</li><li><strong>定期定额投资 (Dollar-Cost Averaging -DCA)，即基金定投</strong>：<ul><li><strong>是什么</strong>：在固定的时间（如每月、每周）以固定的金额投资于同一只指数基金。</li><li><strong>优势</strong>：<ul><li><strong>平滑成本</strong>：在市场下跌时，同样的金额可以买到更多份额；在市场上行时，买到的份额较少。长期下来，可以有效摊平成本，降低择时风险。</li><li><strong>强制储蓄，积少成多</strong>：对于工薪族而言，是一种很好的强制储蓄和长期理财方式。</li><li><strong>克服情绪干扰</strong>：机械化的定期投入，可以避免因市场短期波动而做出错误的追涨杀跌决策。</li></ul></li><li><strong>适合人群</strong>：尤其适合没有大额本金进行一次性投入、希望长期积累财富、且不想费心择时的普通投资者。</li><li><strong>现实实例</strong>：许多人通过坚持数年甚至数十年的指数基金定投，最终积累了可观的财富，实现了购房、子女教育、养老等财务目标。</li></ul></li><li><strong>资产配置 (AssetAllocation)</strong>：虽然指数投资相对简单，但如果资金量较大，或者有更复杂的投资目标，依然需要考虑不同类型指数基金（如股票指数、债券指数、国内外指数）之间的配置比例，以进一步分散风险和优化回报。我们将在后续章节详细讨论资产配置。</li><li><strong>再平衡(Rebalancing)</strong>：如果进行了资产配置，当不同资产类别的涨跌导致实际配置比例偏离初始目标比例时，可以通过卖出涨幅较多的资产、买入涨幅较少或下跌的资产，来恢复到目标配置比例。这是一种逆向操作，有助于“高抛低吸”，控制风险。</li></ul><h4id="四指数基金投资的常见误区与注意事项">四、指数基金投资的常见误区与注意事项</h4><ol type="1"><li><strong>认为指数基金完全没有风险</strong>：指数基金虽然分散了个股风险，但依然承担整个市场的系统性风险。如果市场整体下跌（如熊市），指数基金的净值也会随之下跌。它不能保证稳赚不赔。</li><li><strong>频繁更换指数或基金</strong>：有些投资者看到某个行业指数短期涨得好就追进去，跌了又换到另一个热门指数，这违背了指数投资长期持有的初衷，变成了择基、择时的主动行为。</li><li><strong>忽视指数本身的特性和风险</strong>：例如，某些行业指数可能波动性非常大，或者估值已经很高，投资者在选择时需要有清醒的认识。</li><li><strong>对跟踪误差和费率不够敏感</strong>：尤其是对于长期投资，这些看似微小的差异会累积成大影响。</li><li><strong>在市场高点一次性投入过多</strong>：虽然定投可以平滑成本，但如果是在市场估值极高的位置开始定投或一次性买入，短期内也可能面临较大回撤。可以结合估值水平（如P/E百分位）进行智能定投或分批买入。</li></ol><p><strong>小结</strong></p><p>指数基金投资为普通投资者提供了一条通往财富增值的康庄大道。它以其<strong>低成本、高分散、高透明、业绩大概率跑赢多数主动基金以及简单易行</strong>的特点，成为现代投资组合中不可或缺的组成部分。通过选择合适的指数和优质的基金产品，并坚持长期持有和定期定额投资的策略，即使是没有专业金融背景的投资者，也能够分享经济增长的红利，稳健地实现自己的财务目标。正如约翰·博格所言，<strong>“投资成功的秘诀在于常识、纪律和耐心。”</strong>指数基金投资正是这些品质的最佳实践之一。</p><h3 id="第四节资产配置">第四节：资产配置</h3><p>在深入了解了价值投资、成长投资和指数基金投资等具体策略后，我们现在需要上升到一个更宏观的层面来思考如何构建一个完整的投资组合。<strong>资产配置(Asset Allocation)</strong>被广泛认为是投资决策中最重要的因素，它对投资组合的长期风险和回报的贡献，甚至超过了具体的证券选择和择时。本节将探讨资产配置的原理、常见方法以及其在风险管理中的核心作用。</p><h4id="一资产配置的原理不要把所有鸡蛋放在一个篮子里">一、资产配置的原理：“不要把所有鸡蛋放在一个篮子里”</h4><p><strong>是什么(What)：资产配置的再认识——构建多元化的投资组合以平滑风险</strong></p><p><strong>资产配置是指根据投资者的投资目标、风险承受能力、投资期限等因素，将投资资金在不同类型的资产（如股票、债券、现金、房地产、大宗商品等）之间进行分配和组合的过程。</strong>其核心目的是通过分散投资来降低整体投资组合的波动性（风险），并在可接受的风险水平内争取最优的长期回报。</p><ul><li><strong>“不要把所有鸡蛋放在一个篮子里”</strong>这句古老的谚语，形象地道出了资产配置的精髓。如果把所有资金都投入到单一资产或少数几只高度相关的资产上，一旦该资产遭遇不利情况，整个投资组合将面临巨大损失。而通过将资金分散到不同类型的资产中，这些资产在不同市场环境下的表现往往不尽相同（即相关性较低），从而可以起到“东方不亮西方亮”的对冲效果，平滑整体组合的净值波动。</li><li><strong>《聪明的投资者》</strong>中，本杰明·格雷厄姆早就强调了资产配置的重要性，尤其是对防御型投资者，他建议在股票和债券之间维持一个相对稳定的配置比例（如50/50，或根据市场情况在25/75至75/25之间调整）。他认为这种纪律性的配置有助于投资者在市场波动时保持理性，避免情绪化操作。</li></ul><p><strong>资产配置的理论基础——现代投资组合理论 (Modern Portfolio Theory- MPT)</strong></p><ul><li>由哈里·马科维茨 (Harry Markowitz)于1952年提出，并因此获得诺贝尔经济学奖。</li><li><strong>核心思想</strong>：<ul><li><strong>风险与回报的权衡</strong>：投资者追求在给定风险水平下的最大化回报，或在给定回报水平下的最小化风险。</li><li><strong>分散化的力量</strong>：通过将不同相关性的资产组合起来，可以构建一个比其任何单一成分资产风险更低的投资组合，同时可能获得不低于（甚至高于）某些单一资产的回报。关键在于资产之间的<strong>相关性系数(CorrelationCoefficient)</strong>。如果两种资产的相关性为负（一种涨时另一种跌）或较低的正相关性，那么将它们组合起来就能有效地降低风险。</li><li><strong>有效边界 (EfficientFrontier)</strong>：在所有可能的资产组合中，存在一系列组合，它们在给定的风险水平下能提供最高的回报，或者在给定的回报水平下风险最低。这些最优组合构成了“有效边界”。投资者应选择有效边界上符合自身风险偏好的那个组合点。</li></ul></li></ul><h4 id="怎么做-how资产配置的步骤与常见策略">怎么做(How)：资产配置的步骤与常见策略</h4><p><strong>1. 确定投资目标、风险承受能力与投资期限</strong></p><p>这是进行资产配置的前提。</p><ul><li><strong>投资目标</strong>：是为了短期储蓄、购房首付、子女教育，还是长期养老？不同的目标对应不同的风险和回报要求。</li><li><strong>风险承受能力</strong>：你能承受多大的本金回撤？你的年龄、收入稳定性、家庭状况、心理素质等都会影响你的风险承受能力。<strong>《随机致富的傻瓜》</strong>的作者纳西姆·塔勒布提醒我们，人们往往高估自己对损失的承受能力，尤其是在顺境时。</li><li><strong>投资期限</strong>：投资期越长，通常可以承担越高的风险，因为有更多时间来平滑短期波动并从高风险资产的长期增长中获益。</li></ul><p><strong>2. 选择合适的资产类别 (Selecting Asset Classes)</strong></p><p>常见的资产类别包括：</p><ul><li><strong>股票(Equities)</strong>：高风险，高潜在回报，长期来看是抵御通胀、实现财富增长的重要工具。包括国内股票、国际股票、大盘股、小盘股、价值股、成长股等。</li><li><strong>债券 (Fixed Income /Bonds)</strong>：中低风险，回报相对稳定，主要提供利息收入和本金安全。包括国债、地方政府债、企业债、高收益债、通胀保值债券等。</li><li><strong>现金及现金等价物 (Cash and CashEquivalents)</strong>：极低风险，流动性极高，主要用于满足短期流动性需求、作为应急储备或市场避险。</li><li><strong>房地产 (RealEstate)</strong>：包括直接投资房产和间接投资房地产投资信托基金(REITs)。具有一定的抗通胀特性，但流动性较差（直接投资）。</li><li><strong>大宗商品(Commodities)</strong>：如黄金、石油、农产品等。黄金常被视为避险资产和抗通胀工具。大宗商品价格波动较大，与传统股债资产的相关性可能较低。</li><li><strong>另类投资 (AlternativeInvestments)</strong>：如私募股权、对冲基金、收藏品等。通常门槛较高，流动性差，风险也可能很高。</li></ul><p><strong>3. 确定各类资产的配置比例 (Determining AllocationPercentages)</strong></p><p>这是资产配置的核心步骤。没有放之四海而皆准的完美比例，需要根据第一步的分析来定制。一些常见的策略和经验法则：</p><ul><li><strong>股债平衡策略 (Balanced Stock/Bond Strategy)</strong>：<ul><li><strong>60/40组合</strong>：经典的配置比例，即60%的资金投资于股票，40%投资于债券。被认为是兼顾成长与稳健的长期配置方案。</li><li><strong>年龄法则（经验公式）</strong>：例如，“100 - 年龄 =股票配置比例”。一个30岁的投资者，可以配置70%的股票和30%的债券。随着年龄增长，股票比例逐渐降低，债券比例逐渐升高，以降低风险。这是一种简化的生命周期配置思路。</li><li><strong>格雷厄姆的建议</strong>：防御型投资者在股票和债券之间的配置比例不应低于25%或高于75%，并可以根据市场估值水平进行适度调整（例如，当股市估值过高时，适当降低股票比例）。</li></ul></li><li><strong>生命周期基金/目标日期基金 (Lifecycle Funds / Target-DateFunds -TDFs)</strong>：这是一种“一站式”的资产配置解决方案。基金会自动根据预设的退休日期（目标日期）来调整股债配置比例，年轻时股票比例高，临近退休时债券和现金比例高。非常适合缺乏经验或不想自己操心配置的投资者。</li><li><strong>核心-卫星策略 (Core-Satellite Strategy)</strong>：<ul><li><strong>核心部分(Core)</strong>：占据投资组合的大部分（如70%-90%），投资于低成本、高分散的宽基指数基金（如标普500、沪深300、全球股票指数）和综合债券指数基金，追求稳健的市场平均回报。</li><li><strong>卫星部分(Satellite)</strong>：占据较小部分（如10%-30%），可以投资于一些更积极、更具主题性或风险更高的资产，如特定行业ETF、主动管理型基金、个股、新兴市场基金等，试图获取超额收益。</li></ul></li><li><strong>风险平价策略 (RiskParity)</strong>：并非按资金比例分配，而是力求使不同资产类别对组合整体风险的贡献大致相等。通常会导致债券等低波动资产在资金上占比较高（可能需要加杠杆）。较为复杂，适合机构投资者。</li></ul><p><strong>4. 定期回顾与再平衡 (Regular Review andRebalancing)</strong></p><ul><li><strong>为什么要再平衡？</strong>由于不同资产类别的涨跌幅不同，随着时间的推移，投资组合的实际配置比例会偏离最初设定的目标比例。例如，如果股市表现好于债市，股票的占比会上升，债券的占比会下降，导致组合的风险水平偏离预期。</li><li><strong>如何再平衡？</strong>定期（如每年一次）或当实际比例偏离目标比例达到一定阈值时（如5%或10%），通过卖出涨幅较大、占比过高的资产，买入涨幅较小或下跌、占比过低的资产，使组合恢复到目标配置比例。</li><li><strong>再平衡的好处</strong>：<ul><li><strong>控制风险</strong>：确保投资组合的风险水平始终与投资者的承受能力相匹配。</li><li><strong>实现“高抛低吸”</strong>：本质上是一种逆向操作，有助于在不进行主动择时的情况下实现低买高卖。</li><li><strong>维持纪律性</strong>：避免因市场情绪而随意改变长期配置策略。</li></ul></li></ul><h4id="三资产配置与反脆弱性及黑天鹅">三、资产配置与“反脆弱性”及“黑天鹅”</h4><p>纳西姆·塔勒布在其著作<strong>《黑天鹅》</strong>和<strong>《反脆弱》</strong>中，对传统金融理论中的风险管理方法提出了深刻的批判和独到的见解，这些思想对我们理解资产配置的深层意义非常有启发。</p><ul><li><strong>黑天鹅事件 (Black SwanEvents)</strong>：指那些极其罕见、不可预测，但一旦发生就会产生巨大冲击的极端事件（如2008年金融危机、911事件、新冠疫情）。传统的风险模型（如基于正态分布的方差-协方差模型）往往低估了这类事件发生的概率及其破坏力。</li><li><strong>反脆弱性(Antifragility)</strong>：塔勒布认为，仅仅做到“稳健”（能抵抗冲击）是不够的，更理想的状态是具有“反脆弱性”，即能够从波动、混乱、压力和不确定性中受益。</li><li><strong>资产配置的启示</strong>：<ul><li><strong>承认极端风险的存在，为未知做好准备</strong>：资产配置本身就是一种应对不确定性的策略。不要假设未来会一帆风顺，组合中应包含一些能够在极端市场环境下提供保护或机会的资产。</li><li><strong>杠铃策略 (BarbellStrategy)</strong>：这是塔勒布推崇的一种“反脆弱”配置方法。即将绝大部分（如80%-90%）资金配置于极其安全的资产（如短期国债、现金），确保本金绝对安全；同时将一小部分（如10%-20%）资金配置于具有极高潜在回报但也可能血本无归的高风险投机性资产（如看涨期权、风险投资、某些极具爆发力的成长股）。这种策略避免了将大量资金暴露在难以预测的“中等风险”区域，而是试图从“黑天鹅”事件中（无论是正向还是负向）获益或至少不受重创。<ul><li><strong>通俗理解</strong>：就像杠铃两端重，中间轻。一端是绝对安全，另一端是博取巨大向上空间，避免中间那些看似稳健但可能隐藏巨大“黑天鹅”风险的资产。</li></ul></li><li><strong>避免过度优化和精准预测</strong>：试图通过复杂的模型找到“最优”的资产配置比例往往是徒劳的，因为输入参数（如预期回报、波动率、相关性）本身就充满不确定性，且会随时间变化。更重要的是构建一个简单、稳健、能够适应多种情景的组合。</li><li><strong>冗余和安全垫</strong>：在资产配置中保留一定的现金或高流动性资产，就像系统中的冗余备份，可以在危机发生时提供缓冲，并抓住可能出现的极端低估机会。</li></ul></li></ul><h4 id="四资产配置的长期价值与挑战">四、资产配置的长期价值与挑战</h4><p><strong>资产配置的长期价值：</strong></p><ol type="1"><li><strong>风险管理的核心</strong>：通过分散化有效降低了非系统性风险，平滑了组合波动。</li><li><strong>提高长期回报的稳定性与可持续性</strong>：虽然资产配置不能保证最高的短期回报，但它有助于投资者在长期内穿越牛熊，避免因巨大回撤而被迫离场，从而更有可能实现复利增长。</li><li><strong>纪律性的框架</strong>：为投资者提供了一个在市场情绪波动时保持理性的行为准则。</li><li><strong>个性化定制</strong>：能够根据每个投资者独特的需求和情况量身打造。</li></ol><p><strong>资产配置面临的挑战：</strong></p><ol type="1"><li><strong>预测的困难</strong>：对各类资产未来的回报、风险和相关性的预测是困难的，而这些是资产配置决策的基础。</li><li><strong>“错误的分散化”(Diworsification)</strong>：如果持有的资产过多，或者资产之间的相关性过高，分散化的效果可能会大打折扣，甚至增加管理成本和复杂性。</li><li><strong>坚持的难度</strong>：在某些资产类别长期表现不佳时（例如，在长期牛市中，债券的表现在短期内可能远不如股票），投资者可能会失去耐心，放弃原有的配置计划，追逐短期热点。</li><li><strong>行为偏误的干扰</strong>：如过度自信、损失厌恶、近期偏好（倾向于追逐近期表现好的资产）等都可能影响资产配置决策的客观性和有效性。</li></ol><p><strong>小结</strong></p><p>资产配置是投资这门艺术与科学中的“战略”层面。它不追求预测市场的短期涨跌，也不试图挑选出下一只“十倍股”，而是通过科学的组合与分散，构建一个能够抵御未知风险、适应不同市场环境、并最终帮助投资者实现长期财务目标的“全天候”投资组合。记住，<strong>“时间是你的朋友，冲动是你的敌人。”</strong>资产配置正是帮助我们与时间做朋友，克服冲动情绪的有力武器。它要求我们对自身的财务状况和风险偏好有清晰的认知，对各类资产的特性有深入的理解，并能够长期坚持既定的配置纪律。</p><p>好的，我们来撰写第五节“风险管理”以及第三章的总结。风险管理是投资中与追求回报同等重要的另一面。</p><hr /><h3 id="第五节风险管理">第五节：风险管理</h3><p>在投资的世界里，风险与回报如影随形。我们追求回报，但更要敬畏风险。<strong>风险管理并非是要完全消除风险（这是不可能的，除非不投资），而是要理解风险、识别风险、衡量风险，并采取有效措施将风险控制在可承受的范围内，从而保护我们的本金，并为实现长期投资目标保驾护航。</strong>忽视风险的投资无异于蒙眼狂奔，最终可能导致灾难性的后果。本节我们将探讨不同类型的投资风险，以及如何通过有效的策略来管理它们。</p><h4 id="一认识不同类型的投资风险">一、认识不同类型的投资风险</h4><p><strong>是什么 (What)：风险的多种面孔</strong></p><p>风险意味着不确定性，尤其是结果可能不如预期的不确定性。在投资中，风险通常指投资本金发生损失或投资回报未达预期的可能性。</p><ol type="1"><li><strong>市场风险 (Market Risk / Systematic Risk)</strong>：<ul><li><strong>定义</strong>：指由于整体市场（如股票市场、债券市场）的波动而导致投资价值下跌的风险。这种风险影响范围广，几乎所有同类资产都会受到影响，难以通过简单的分散投资完全消除。</li><li><strong>来源</strong>：宏观经济变化（如经济衰退、通货膨胀、利率变动）、政治事件、自然灾害、投资者情绪的集体变化等。</li><li><strong>《黑天鹅》</strong>的作者纳西姆·塔勒布强调，市场常常会发生一些传统模型无法预测的极端事件（黑天鹅），这些事件往往会引发剧烈的市场风险。</li><li><strong>现实实例</strong>：2008年全球金融危机导致全球股市暴跌；2020年初新冠疫情爆发引发全球市场恐慌性抛售。即使是优质公司的股票，在系统性风险面前也难以幸免。</li></ul></li><li><strong>特定风险/非系统性风险 (Specific Risk / Unsystematic Risk /Idiosyncratic Risk)</strong>：<ul><li><strong>定义</strong>：指与特定公司、特定行业或特定证券相关的风险，可以通过充分的分散投资来显著降低。</li><li><strong>来源</strong>：公司经营不善、管理层失误、财务丑闻、新产品失败、行业竞争加剧、技术被颠覆等。</li><li><strong>现实实例</strong>：某上市公司因财务造假导致股价暴跌（如安然、瑞幸咖啡）；某航空公司因重大安全事故导致股价和声誉受损；某科技公司因未能跟上技术潮流而被市场淘汰。</li></ul></li><li><strong>信用风险/违约风险 (Credit Risk / Default Risk)</strong>：<ul><li><strong>定义</strong>：指债券发行方（如政府、企业）未能按时支付利息或偿还本金的风险。</li><li><strong>影响</strong>：主要影响债券投资者。信用评级越低的债券，信用风险越高。</li><li><strong>现实实例</strong>：企业发行的“垃圾债券”（高收益债）违约率较高；某些国家也曾发生主权债务违约（如阿根廷）。</li></ul></li><li><strong>流动性风险 (Liquidity Risk)</strong>：<ul><li><strong>定义</strong>：指投资者在需要将资产变现时，无法以合理价格快速卖出，或者需要大幅折价才能成交的风险。</li><li><strong>影响</strong>：对于交易不活跃的股票（如小型股、仙股）、某些类型的债券、房地产、非上市公司股权等，流动性风险较高。</li><li><strong>现实实例</strong>：在市场恐慌时，即使是流动性较好的资产也可能出现短期流动性枯竭。某些小型公司的股票可能长时间无人问津，难以找到买家。</li></ul></li><li><strong>利率风险 (Interest Rate Risk)</strong>：<ul><li><strong>定义</strong>：指市场利率变动导致投资（尤其是固定收益类投资如债券）价值发生变动的风险。当市场利率上升时，已发行的固定利率债券价格通常会下跌。</li><li><strong>影响</strong>：对债券投资者尤为重要，对股票市场也有间接影响（如影响企业融资成本和估值）。</li></ul></li><li><strong>通货膨胀风险 (Inflation Risk / Purchasing PowerRisk)</strong>：<ul><li><strong>定义</strong>：指由于物价持续上涨，导致货币购买力下降，从而使投资的实际回报率低于名义回报率的风险。</li><li><strong>影响</strong>：持有大量现金或低收益固定收益产品的投资者面临较大的通胀风险。</li></ul></li><li><strong>汇率风险 (Currency Risk / Exchange Rate Risk)</strong>：<ul><li><strong>定义</strong>：指由于外币与本币之间的汇率波动，导致以外币计价的投资在折算回本币时价值发生变动的风险。</li><li><strong>影响</strong>：主要影响进行跨国投资的投资者。</li></ul></li><li><strong>操作风险 (Operational Risk)</strong>：<ul><li><strong>定义</strong>：指由于内部流程、人员、系统缺陷或外部事件导致损失的风险。例如，交易系统故障、人为操作失误、欺诈行为等。</li></ul></li><li><strong>“模型风险”与“认知风险”</strong>：<ul><li><strong>《随机致富的傻瓜》</strong>中塔勒布警示我们，过度依赖简化的金融模型（模型风险）而忽视现实世界的复杂性和罕见事件，是危险的。</li><li>我们自身的认知偏差（如过度自信、确认偏误）也会导致我们低估或误判风险（认知风险）。</li></ul></li></ol><h4 id="怎么做-how风险管理的策略与工具">怎么做(How)：风险管理的策略与工具</h4><p>有效的风险管理不是单一的方法，而是一个系统性的过程和多种工具的结合。</p><p><strong>1. 理解并接受风险 (Understand and Accept Risk)</strong></p><ul><li><strong>没有无风险的高回报</strong>：这是投资的第一课。任何声称“无风险、高收益”的投资机会，几乎都是骗局。</li><li><strong>评估自身的风险承受能力</strong>：清晰了解自己能承受多大的损失，这是制定风险管理策略的前提。不要承担超出自己承受能力的风险。</li><li><strong>风险与回报的匹配</strong>：所承担的风险应该与预期的回报相匹配。不值得为了微不足道的回报而去承担巨大的风险。</li></ul><p><strong>2. 分散化投资 (Diversification)</strong></p><ul><li><strong>原理</strong>：“不要把所有鸡蛋放在一个篮子里。”通过将资金分散投资于不同类型的资产、不同行业、不同地区，可以有效降低非系统性风险。</li><li><strong>方法</strong>：<ul><li><strong>资产类别分散</strong>：在股票、债券、现金等大类资产之间进行配置。</li><li><strong>行业分散</strong>：在投资股票时，避免过度集中于单一行业。</li><li><strong>地区分散</strong>：考虑在全球不同市场进行配置，以分散特定国家或地区的风险。</li><li><strong>个股分散</strong>：即使在同一行业内，也应持有一定数量的不同公司的股票，避免单一个股“爆雷”对组合造成过大冲击（对于主动选股而言，指数基金本身就是高度分散的）。</li></ul></li><li><strong>《聪明的投资者》</strong>中格雷厄姆建议，即使是积极型投资者，也应确保其投资组合具有“充分的但不过度的分散化”。</li></ul><p><strong>3. 坚持安全边际 (Margin of Safety)</strong></p><ul><li><strong>原理</strong>：这是价值投资的核心风险管理工具。以低于内在价值的价格买入，为可能发生的错误判断或不利变化提供缓冲。</li><li><strong>应用</strong>：不仅适用于股票投资，也适用于其他资产。例如，在购买债券时，关注发行人的偿债能力是否远超其债务负担。</li><li><strong>《投资最重要的事》</strong>的作者霍华德·马克斯将安全边际视为最重要的投资原则之一，他认为安全边际的本质在于“认识到预测的不可靠性，并为这种不可靠性做好准备”。</li></ul><p><strong>4. 资产配置 (Asset Allocation)</strong></p><ul><li><strong>原理</strong>：如上一节所述，通过科学地配置不同风险收益特征的资产，构建一个与自身风险偏好相匹配的投资组合，是管理整体投资风险的核心策略。</li><li><strong>作用</strong>：资产配置决定了投资组合长期风险和回报的主要部分。合理的资产配置能够在控制下行风险的同时，争取长期稳健的回报。</li></ul><p><strong>5. 止损 (Stop-Loss Orders) - 审慎使用</strong></p><ul><li><strong>是什么</strong>：预设一个价格，当投资标的的价格跌至该水平时，自动触发卖出指令，以限制潜在的进一步损失。</li><li><strong>优点</strong>：有助于克服人性中不愿“割肉”的弱点，机械化地执行风险控制。</li><li><strong>缺点/争议</strong>：<ul><li>可能在市场短期非理性波动时被“误伤”，过早卖出优质资产。</li><li>止损点的设置具有主观性，难以完美。</li><li>对于长期价值投资者而言，如果公司基本面未变，股价下跌反而可能是买入机会，而不是止损信号。</li></ul></li><li><strong>建议</strong>：止损策略更适用于短期交易者或趋势投资者。对于长期投资者，更应关注基本面变化而非单纯的价格波动。如果要使用，应结合对资产基本价值的判断。</li></ul><p><strong>6. 风险对冲 (Hedging) - 较复杂，适合专业投资者</strong></p><ul><li><strong>是什么</strong>：通过买入与持有资产具有负相关性或能抵消特定风险的金融工具（如期权、期货、做空工具）来降低组合风险。</li><li><strong>例子</strong>：持有大量股票的投资者，可以购买股指看跌期权来对冲市场下跌风险。</li><li><strong>复杂性</strong>：对冲工具本身具有复杂性，且会产生额外成本。不当使用可能反而增加风险。</li></ul><p><strong>7. 保持充足的流动性 (Maintaining AdequateLiquidity)</strong></p><ul><li><strong>原理</strong>：持有一定比例的现金或高流动性资产（如货币基金），以应对不时之需（如紧急开支）或抓住市场极端下跌时出现的投资机会。</li><li><strong>《反脆弱》</strong>中塔勒布强调现金的“期权价值”，即持有现金让你拥有了在未来某个不确定时刻采取行动的选择权。</li></ul><p><strong>8. 持续学习与反思 (Continuous Learning andReflection)</strong></p><ul><li><strong>认识到风险是动态变化的</strong>：市场环境、公司基本面、风险因素都在不断变化，需要持续学习，更新自己的知识和认知。</li><li><strong>从错误中学习</strong>：每一次投资失误都是一次宝贵的学习机会。反思错误的原因，避免重蹈覆辙。</li><li><strong>保持谦逊和敬畏之心</strong>：市场永远比我们想象的更复杂。<strong>《随机致富的傻瓜》</strong>提醒我们，不要将运气误认为能力，对风险始终保持警惕。</li></ul><h4 id="三风险管理的心态与哲学">三、风险管理的心态与哲学</h4><p>风险管理不仅是技术层面的操作，更是一种投资心态和哲学的体现。</p><ul><li><strong>“首先，不要亏钱；其次，记住第一条。” (Rule No.1: Never losemoney. Rule No.2: Never forget rule No.1.)</strong>这是巴菲特的名言，强调了本金安全的重要性。虽然这里的“不亏钱”并非指绝对意义上的每一笔交易都不亏，而是指避免永久性的、灾难性的资本损失。</li><li><strong>关注下行风险，而非仅仅是上行潜力</strong>：霍华德·马克斯认为，优秀的投资者花在思考“可能出错的地方”的时间，和花在思考“可能赚多少钱”的时间一样多，甚至更多。</li><li><strong>接受不确定性，拥抱概率思维</strong>：投资决策是在不完全信息和不确定环境下做出的。没有100%确定的事情。要学会用概率来思考问题，并为不同可能的结果做好准备。</li><li><strong>避免“灾难性风险” (Avoiding RuinRisk)</strong>：确保没有任何单一的风险事件能够让你彻底出局。这意味着要避免过度集中的投资、过度使用杠杆等。</li><li><strong>“幸存者偏差”的警示</strong>：我们看到的成功案例往往是“幸存者”，许多失败的案例已被遗忘。不要被少数极端成功的个例所迷惑，而忽视了普遍存在的风险。</li></ul><p><strong>小结</strong></p><p>风险管理是投资成功的基石。它不是一句空洞的口号，而是贯穿于投资决策全过程的思维方式和具体行动。通过理解不同类型的风险，并综合运用分散化、安全边际、合理的资产配置、持续学习等策略，我们可以有效地驾驭风险，而不是被风险所吞噬。记住，投资是一场关于风险与回报的权衡游戏，只有那些能够清醒地认识风险、智慧地管理风险的人，才能在长期的投资马拉松中最终胜出。</p><hr /><h3 id="总结策略深化与组合构建">总结：策略深化与组合构建</h3><p>在本章中，我们从具体的投资策略深入到投资组合的宏观构建与风险管理，旨在帮助读者形成更为系统和成熟的投资框架。</p><p>我们首先<strong>深入价值投资</strong>，重温了其“透彻分析、本金安全、满意回报”的核心原则，探讨了基于深入基本面研究、估算内在价值、坚持安全边际、利用市场波动以及长期持有的实践方法论。我们借鉴了《聪明的投资者》、《安全边际》、《投资最重要的事》等经典著作中的智慧，理解了价值投资的持久魅力与挑战，以及其从格雷厄姆到巴菲特的演进。</p><p>接着，我们<strong>深入成长投资</strong>，聚焦于寻找具有卓越增长潜力的“明星企业”。我们分析了成长投资的核心要素（高增长性、广阔市场空间、强大竞争优势、优秀管理团队、合理估值），探讨了识别高成长行业与公司、分析成长驱动力与可持续性、评估估值合理性以及持续跟踪的实践方法。同时，我们特别警示了“增长陷阱”，如为增长支付过高价格、成长幻觉、忽视竞争格局恶化等，并借鉴了《彼得·林奇的成功投资》等著作的思想。</p><p>然后，我们转向了一种对大多数普通投资者更为友好的策略——<strong>指数基金投资</strong>。我们详细阐述了指数基金低成本、高分散、高透明、长期业绩大概率跑赢多数主动基金以及简单易行的核心优势。我们学习了如何选择合适的指数和优质的指数基金产品（关注跟踪误差、费率、规模等），并探讨了长期持有和定期定额投资（基金定投）等有效策略。</p><p>随后，我们将视角提升到投资组合的战略层面，学习了<strong>资产配置</strong>。我们理解了“不要把所有鸡蛋放在一个篮子里”的原理，探讨了资产配置在分散风险、平滑波动方面的核心作用。我们介绍了确定投资目标、选择资产类别、确定配置比例（如股债平衡、生命周期基金、核心-卫星策略）以及定期回顾与再平衡等关键步骤。我们还结合了《反脆弱》、《黑天鹅》等著作的思想，探讨了如何在资产配置中考虑极端风险和构建“反脆弱性”。</p><p>最后，我们系统地学习了<strong>风险管理</strong>。我们认识了市场风险、特定风险、信用风险、流动性风险、利率风险、通胀风险等多种类型的投资风险。我们探讨了通过理解并接受风险、分散化投资、坚持安全边际、合理的资产配置、保持充足流动性、持续学习与反思等多种策略来有效管理风险。我们强调了风险管理的心态与哲学，如关注下行风险、避免灾难性风险等。</p><p>贯穿本章，我们始终强调<strong>“理解先于行动”</strong>、<strong>“循序渐进”</strong>、<strong>“理论结合实践”</strong>和 <strong>“保持耐心和好奇心”</strong>的核心原则。通过对不同投资策略的深化理解，以及对资产配置和风险管理的系统学习，读者应能开始构建属于自己的、符合自身情况的投资框架。</p><p><strong>给读者的行动建议</strong>：在模拟交易或小额实践中，尝试应用本章学到的策略和理念：</p><ol type="1"><li><strong>策略选择与应用</strong>：<ul><li>尝试挑选1-2只符合<strong>价值投资</strong>标准的公司（如寻找具有安全边际的标的），并阐述你的理由。</li><li>尝试挑选1-2只符合<strong>成长投资</strong>标准的公司（如寻找具有高增长潜力和护城河的标的），并评估其估值与增长的匹配度，警惕增长陷阱。</li><li>研究几只主流的<strong>指数基金</strong>（如沪深300 ETF、标普500ETF），了解其成分、费率、跟踪误差，并模拟进行定投。</li></ul></li><li><strong>初步的资产配置方案</strong>：<ul><li>根据你设定的一个虚拟投资目标（如5年后买车，20年后养老）和风险承受能力，尝试设计一个简单的资产配置方案（例如，股票型指数基金和债券型指数基金的配置比例）。</li></ul></li><li><strong>风险管理意识</strong>：<ul><li>在你选择的模拟投资标的中，思考它们可能面临的主要风险是什么？你将如何应对这些风险？</li><li>如果你进行模拟交易，尝试设定一个止损点或回撤容忍度。</li></ul></li></ol><p>通过这样的模拟实践，可以将理论知识转化为实际操作的经验，更快地熟悉投资的各个环节，并为未来的真实投资做好更充分的准备。</p><h2 id="第四章实践准备与持续学习">第四章：实践准备与持续学习</h2><p><strong>目标：</strong>完善个人投资体系，了解交易实务，为小额实盘操作做准备，并建立持续学习的习惯。</p><h3 id="第一节交易平台">第一节：交易平台</h3><p>在学习了诸多投资理论、策略和分析方法之后，要将这些知识付诸实践，我们首先需要一个进行交易的“战场”——即选择合适的交易平台并熟悉其操作。本节将介绍在中国大陆和常见的海外市场进行证券交易的开户流程、交易成本（主要是佣金），以及交易软件的基本使用。</p><h4 id="一选择交易平台与开户流程">一、选择交易平台与开户流程</h4><p><strong>是什么 (What)：交易平台——连接投资者与市场的桥梁</strong></p><p><strong>交易平台，通常指证券公司（券商）提供的用于买卖股票、基金、债券等金融产品的服务系统。</strong>投资者通过在券商处开设证券账户，才能参与到交易所的集中交易中。</p><ul><li><strong>通俗理解</strong>：券商就像一个“中介服务机构”，为你提供进入股票/基金等交易市场的“入场券”（证券账户）和进行买卖操作的“工具”（交易软件）。</li><li><strong>国内与海外平台的区别</strong>：<ul><li><strong>投资A股（上海证券交易所、深圳证券交易所、北京证券交易所）</strong>：需要在中国大陆的证券公司开立A股账户。</li><li><strong>投资港股（香港交易所）</strong>：可以通过“港股通”（需满足一定资金门槛和风险测评要求，通过内地券商开通）或者直接在香港的证券公司或支持港股交易的国际券商开立港股账户。</li><li><strong>投资美股（纽约证券交易所、纳斯达克交易所）</strong>：通常需要通过支持美股交易的国际券商（如盈透证券Interactive Brokers, 富途证券 Futu, 老虎证券 Tiger Brokers等）或部分国内券商的香港子公司开立美股账户。</li></ul></li></ul><p><strong>怎么做 (How)：开户流程详解</strong></p><p><strong>1. 投资A股的开户流程（以线上开户为例）：</strong></p><p>目前国内大部分券商都支持线上自助开户，流程便捷高效。</p><ul><li><strong>选择证券公司 (券商)</strong>：<ul><li><strong>考虑因素</strong>：<ul><li><strong>佣金费率</strong>：这是最直接的交易成本。不同券商、不同资金量、不同地区的佣金可能不同。通常线上开户的佣金会比线下营业部开户更低。可以货比三家，选择佣金有竞争力的券商。</li><li><strong>交易软件体验</strong>：券商提供的交易软件（PC端、手机APP）是否功能齐全、操作便捷、行情稳定、资讯丰富等。可以先下载几家券商的APP体验一下。</li><li><strong>服务质量</strong>：客服响应速度、投顾服务水平（虽然对于初学者，主要靠自己）、线下网点覆盖（如果需要办理特殊业务）等。</li><li><strong>券商资质与规模</strong>：选择有良好信誉、规模较大、合规经营的券商，资金安全更有保障。</li></ul></li><li><strong>常见券商</strong>：如中信证券、华泰证券、国泰君安、招商证券、海通证券、广发证券、东方财富证券等。</li></ul></li><li><strong>准备开户所需材料</strong>：<ul><li><strong>本人有效身份证原件</strong>（有效期内）。</li><li><strong>本人银行借记卡</strong>（用于三方存管，即资金在银行和证券账户之间划转）。建议使用大型商业银行的借记卡。</li><li><strong>智能手机</strong>（带有摄像头和麦克风，用于视频见证）。</li><li><strong>良好的网络环境</strong>。</li></ul></li><li><strong>线上开户步骤（各券商大同小异）</strong>：<ol type="1"><li><strong>下载券商APP或访问官网开户页面</strong>。</li><li><strong>手机号验证注册</strong>。</li><li><strong>上传身份证正反面照片</strong>，系统会自动识别信息。</li><li><strong>填写个人基本信息</strong>，如姓名、身份证号、职业、学历、联系地址等。</li><li><strong>视频见证</strong>：与券商客服进行短暂的视频通话，确认是本人操作并回答几个简单问题。</li><li><strong>选择开通的股东账户</strong>：通常默认开通上海A股股东账户和深圳A股股东账户。如果需要投资可转债、基金等，也会一并开通相关权限。</li><li><strong>设置交易密码和资金密码</strong>：交易密码用于登录交易软件和下单，资金密码用于银证转账。务必牢记并妥善保管。</li><li><strong>绑定三方存管银行卡</strong>：输入银行卡号和相关信息。</li><li><strong>进行风险承受能力测评</strong>：根据问卷结果评估你的风险等级，这会影响你能购买的产品类型。务必如实填写。</li><li><strong>阅读并签署相关协议</strong>，如《证券交易委托代理协议》、《客户须知》等。</li><li><strong>提交开户申请，等待审核</strong>。通常1-2个工作日内会有审核结果（短信或APP通知）。</li><li><strong>开户成功后，会收到资金账号和股东账号信息</strong>。</li></ol></li></ul><p><strong>2.投资港股/美股的开户流程（以国际互联网券商为例）：</strong></p><ul><li><strong>选择券商</strong>：如前述的盈透证券、富途证券、老虎证券等。这些券商通常提供中文界面和客服，支持多种海外市场交易。<ul><li><strong>考虑因素</strong>：佣金费率、支持的市场范围、交易软件体验、资金安全保障（如是否受SIPC等机构保护）、出入金便捷性等。</li></ul></li><li><strong>准备开户所需材料</strong>：<ul><li><strong>本人有效身份证原件</strong>。</li><li><strong>地址证明文件</strong>：通常是近3个月内的水电煤账单、信用卡账单、银行结单等，上面需有你的姓名和住址。</li><li><strong>部分券商可能需要其他辅助证明文件</strong>。</li></ul></li><li><strong>线上开户步骤</strong>：<ol type="1"><li>访问券商官网或下载其APP。</li><li>注册账户，填写个人信息（可能需要填写英文地址等）。</li><li>上传身份证明和地址证明文件。</li><li>填写投资经验、财务状况等问卷（W-8BEN表格等，用于美国税务申报，非美国居民可免缴资本利得税）。</li><li>进行风险披露和签署协议。</li><li>提交申请，等待审核。审核时间可能比A股略长。</li><li>开户成功后，需要从国内银行账户<strong>购汇</strong>并将外币（通常是美元或港币）<strong>跨境汇款</strong>至券商指定的银行账户才能开始交易。出金（将资金从券商账户转回国内）也需要类似的反向操作。这个过程可能涉及银行的手续费和电讯费。</li></ol></li></ul><p><strong>为什么 (Why)：选择合适平台与顺利开户的重要性</strong></p><ol type="1"><li><strong>合法合规交易的保障</strong>：通过正规券商开户，确保交易行为受到监管保护。</li><li><strong>资金安全</strong>：正规券商有严格的客户资金存管制度（如A股的三方存管，美股的SIPC保险等），保障投资者资金安全。</li><li><strong>交易成本控制</strong>：选择低佣金的券商可以显著降低长期投资的交易成本。</li><li><strong>便捷高效的交易体验</strong>：好用的交易软件和顺畅的开户流程能提升投资效率和体验。</li></ol><h4 id="二交易成本佣金与其他费用">二、交易成本：佣金与其他费用</h4><p><strong>是什么 (What)：投资过程中需要支付的费用</strong></p><p>在进行证券交易时，投资者需要支付一定的费用，这些费用会直接影响投资的净回报。</p><p><strong>1. 佣金 (Commission)</strong>：</p><ul><li><strong>定义</strong>：投资者在买卖证券时按成交金额的一定比例向券商支付的手续费。这是最主要的交易成本之一。</li><li><strong>A股佣金</strong>：<ul><li><strong>费率</strong>：由券商自行设定，但受到监管机构的上限限制（如不超过成交金额的千分之三）。目前市场竞争激烈，许多券商线上开户的佣金可以做到万分之三、万分之二点五，甚至更低（如万分之一点几，但通常有最低5元的收费标准，即单笔佣金不足5元按5元收取）。</li><li><strong>双向收取</strong>：买入和卖出股票时都需要支付佣金。</li><li><strong>可协商</strong>：对于资金量较大或交易频繁的客户，可以尝试与客户经理协商更低的佣金费率。</li></ul></li><li><strong>港股佣金</strong>：<ul><li><strong>费率</strong>：不同券商收费标准不一，通常按成交金额的百分比收取，也有最低收费。例如，可能是0.03%- 0.25%不等，最低收费几十港元到一百港元不等。</li><li><strong>部分互联网券商可能推出免佣活动或低佣套餐</strong>。</li></ul></li><li><strong>美股佣金</strong>：<ul><li><strong>收费模式多样</strong>：<ul><li><strong>按股数收费</strong>：如每股0.005美元，最低1美元/笔。</li><li><strong>按交易笔数固定收费</strong>：如每笔交易固定几美元。</li><li><strong>免佣金 (ZeroCommission)</strong>：近年来许多美国本土券商（如Robinhood, CharlesSchwab）和部分互联网券商推出了针对特定股票或ETF的免佣交易。但要注意，“免佣”不一定等于“免费”，券商可能通过其他方式盈利（如订单流支付、融资融券利息等）。</li></ul></li></ul></li><li><strong>如何降低佣金成本</strong>：<ul><li>选择低佣金券商。</li><li>对于小额交易，注意是否有最低收费标准。</li><li>减少不必要的频繁交易。</li></ul></li></ul><p><strong>2. 印花税 (Stamp Duty)</strong>：</p><ul><li><strong>定义</strong>：国家对证券交易行为征收的一种税。</li><li><strong>A股印花税</strong>：<ul><li><strong>仅在卖出股票时收取</strong>，买入时不收。</li><li><strong>税率</strong>：目前为成交金额的千分之一（0.1%）。由国家统一规定，券商无权调整。</li></ul></li><li><strong>港股印花税</strong>：<ul><li><strong>买卖双向收取</strong>。</li><li><strong>税率</strong>：目前为成交金额的0.13%（买卖双方各付）。（注：税率可能会调整，请以最新规定为准）</li></ul></li><li><strong>美股印花税</strong>：美国联邦政府不征收印花税，但美国证监会(SEC)会收取一个极小的规费(SECFee)，通常在卖出时由券商代扣。</li></ul><p><strong>3. 过户费 (Transfer Fee)</strong>：</p><ul><li><strong>定义</strong>：股票成交后，更换户名所需支付给证券登记结算机构的费用。</li><li><strong>A股过户费</strong>：<ul><li><strong>上海市场收取</strong>：按成交金额的十万分之四点五（0.0045%）双向收取。</li><li><strong>深圳市场不单独收取</strong>，已包含在交易经手费中。</li></ul></li><li><strong>港股、美股</strong>：通常没有单独列出的过户费，可能包含在其他综合费用中或由券商承担。</li></ul><p><strong>4. 其他费用</strong>：</p><ul><li><strong>交易征费、交易费（港股）</strong>：由香港证监会和交易所收取，费率较低。</li><li><strong>平台使用费（部分互联网券商）</strong>：有些券商可能会对某些类型的账户或服务收取固定的平台使用费。</li><li><strong>资金存管费、账户管理费</strong>：国内券商通常不收取，但某些海外券商或特定账户类型可能会有。</li><li><strong>出入金手续费（海外平台）</strong>：跨境汇款时银行会收取手续费和电讯费。部分券商对入金可能有补贴，但出金通常需要投资者自行承担费用。</li></ul><p><strong>为什么 (Why)：关注交易成本的重要性</strong></p><ul><li><strong>直接侵蚀回报</strong>：交易成本是实实在在的支出，会直接降低你的投资净收益。</li><li><strong>复利效应的负面影响</strong>：长期来看，即使是很小的费率差异，在复利的作用下也会对最终财富积累产生巨大影响。正如约翰·博格所强调的，控制成本是成功投资的关键。</li><li><strong>影响交易策略</strong>：高昂的交易成本使得频繁的短线交易更难盈利。</li></ul><h4 id="三交易软件的基本使用">三、交易软件的基本使用</h4><p><strong>是什么(What)：投资者进行交易、获取行情和资讯的工具</strong></p><p>交易软件通常由券商提供，是投资者进行日常操作的主要界面。</p><ul><li><strong>主要功能模块</strong>：<ul><li><strong>行情显示 (MarketQuotes)</strong>：实时显示股票、基金等的价格、涨跌幅、成交量、买卖盘口（五档行情）、分时图、K线图等。</li><li><strong>交易下单 (OrderPlacement)</strong>：进行买入、卖出、撤单等操作。</li><li><strong>账户管理 (AccountManagement)</strong>：查询持仓、可用资金、交易记录、盈亏分析、银证转账等。</li><li><strong>资讯信息 (News andInformation)</strong>：提供财经新闻、公司公告、研究报告、市场数据等。</li><li><strong>自选股(Watchlist)</strong>：将自己关注的股票或基金添加到列表，方便跟踪。</li><li><strong>条件单/智能交易 (Conditional Orders/SmartTrading)</strong>：一些高级功能，如预设价格和条件自动下单。</li></ul></li></ul><p><strong>怎么做 (How)：熟悉基本操作</strong></p><ol type="1"><li><strong>登录与安全</strong>：<ul><li>使用资金账号和交易密码登录。</li><li>注意保护账户安全，不要在公共电脑登录，定期修改密码。</li></ul></li><li><strong>查看行情</strong>：<ul><li>输入股票代码或名称搜索。</li><li>理解分时图（白线代表价格，黄线代表均价）和K线图（日K、周K、月K，包含开盘价、收盘价、最高价、最低价）的含义。</li><li>关注成交量、换手率等指标。</li></ul></li><li><strong>下单交易</strong>：<ul><li><strong>买入 (Buy)</strong>：<ul><li>输入股票代码。</li><li>选择价格类型：<ul><li><strong>限价单 (LimitOrder)</strong>：指定一个买入价格，只有当市场价格达到或低于该价格时才会成交。可以避免以过高价格买入。</li><li><strong>市价单 (MarketOrder)</strong>：以当前市场最优价格立即成交。成交速度快，但成交价格可能不确定，尤其在市场快速波动时。A股目前市价单有多种形式（如最优五档即时成交剩余撤销、最优五档即时成交剩余转限价等）。</li></ul></li><li>输入买入数量（A股通常是100股的整数倍，称为“一手”；港股和美股的最小交易单位不同，港股有些是100股、500股、1000股/手，美股可以1股起买，甚至部分券商支持零碎股交易）。</li><li>确认下单。</li></ul></li><li><strong>卖出 (Sell)</strong>：操作与买入类似，只是方向相反。</li><li><strong>撤单 (CancelOrder)</strong>：如果限价单未成交，且你不想再等待，可以撤销该委托。</li></ul></li><li><strong>查询与管理</strong>：<ul><li><strong>持仓(Positions)</strong>：查看当前持有的证券、数量、成本价、当前市值、浮动盈亏等。</li><li><strong>当日成交 (Today'sTrades)</strong>：查看当天已成交的买卖记录。</li><li><strong>历史成交 (Trade History)</strong>：查询过去的交易记录。</li><li><strong>银证转账 (Bank-SecuritiesTransfer)</strong>：在交易日的特定时间内（通常是9:00-16:00），将资金从银行卡转入证券账户（入金），或从证券账户转出至银行卡（出金）。</li></ul></li><li><strong>熟悉交易规则</strong>：<ul><li><strong>交易时间</strong>：A股（9:30-11:30,13:00-15:00，集合竞价时间除外）、港股、美股的交易时间各不相同，还有盘前盘后交易时段。</li><li><strong>涨跌停板制度</strong>：A股主板股票有±10%的涨跌停限制（ST股±5%，科创板和创业板注册制后新股上市前5日无涨跌停，之后±20%）。港股和美股通常没有普适性的涨跌停板制度（但有熔断机制）。</li><li><strong>T+1交易制度（A股）</strong>：当天买入的股票，要到下一个交易日才能卖出。资金是T+0可用（卖出股票的资金当天可用），T+1可取（下一个交易日才能转出到银行卡）。港股和美股通常是T+0交易（当天买入可当天卖出），资金交收是T+2。</li></ul></li></ol><p><strong>为什么 (Why)：熟悉交易软件的重要性</strong></p><ol type="1"><li><strong>准确高效执行交易</strong>：避免因操作不熟练导致下单错误或错过交易时机。</li><li><strong>及时获取市场信息</strong>：帮助投资者做出更明智的决策。</li><li><strong>有效管理账户资产</strong>：清楚了解自己的持仓和盈亏状况。</li></ol><p><strong>小结</strong></p><p>选择合适的交易平台、了解开户流程、熟悉交易成本和掌握交易软件的基本使用，是投资者从理论学习走向实践操作的必经之路。这个过程可能有些繁琐，但却是进行真实投资的基础设施建设。建议初学者在选择平台时，优先考虑<strong>安全性、低佣金和易用性</strong>。在开户和熟悉软件后，可以先用极小额的资金（例如，只够买一手低价股的钱）进行几次真实交易，体验整个流程，这比单纯的模拟交易能带来更深刻的体会。但切记，在没有形成自己的投资体系和风险控制能力之前，不宜投入大量资金。</p><h3 id="第二节交易基础">第二节：交易基础</h3><p>熟悉了交易平台和开户流程后，我们还需要掌握一些进行实际买卖操作的基础知识。其中，理解不同的订单类型是至关重要的一环，它直接关系到你的交易能否以期望的价格和方式成交。本节将重点介绍几种最常见的订单类型及其适用场景。</p><h4id="一理解订单簿与市场深度-order-book-and-market-depth">一、理解订单簿与市场深度(Order Book and Market Depth)</h4><p><strong>是什么 (What)：市场供需的实时展示</strong></p><p>在深入了解订单类型之前，我们先简单理解一下“订单簿”和“市场深度”的概念。当你打开交易软件查看某只股票的行情时，通常会看到类似下面的信息：</p><table><thead><tr><th>买盘 (Bid)</th><th></th><th>卖盘 (Ask/Offer)</th><th></th></tr></thead><tbody><tr><td>价格 (Price)</td><td>数量 (Qty)</td><td>价格 (Price)</td><td>数量 (Qty)</td></tr><tr><td>买一 (Bid 1) 10.00</td><td>5000</td><td>卖一 (Ask 1) 10.01</td><td>3000</td></tr><tr><td>买二 (Bid 2) 9.99</td><td>8000</td><td>卖二 (Ask 2) 10.02</td><td>6000</td></tr><tr><td>买三 (Bid 3) 9.98</td><td>12000</td><td>卖三 (Ask 3) 10.03</td><td>9000</td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td></tr></tbody></table><ul><li><strong>订单簿 (OrderBook)</strong>：是一个实时记录特定证券所有未成交买入委托（买盘）和卖出委托（卖盘）的列表，按价格高低（买盘从高到低，卖盘从低到高）排列。</li><li><strong>买盘(Bid)</strong>：代表潜在买家愿意购买该证券的价格和相应的数量。<strong>买一价(Bid 1 Price)</strong> 是当前市场上最高的买入报价。</li><li><strong>卖盘(Ask/Offer)</strong>：代表潜在卖家愿意出售该证券的价格和相应的数量。<strong>卖一价(Ask 1 Price)</strong> 是当前市场上最低的卖出报价。</li><li><strong>价差 (Spread)</strong>：卖一价与买一价之间的差额 (Ask 1 -Bid 1)。价差越小，通常意味着该证券的流动性越好。</li><li><strong>市场深度 (MarketDepth)</strong>：指在买一/卖一价附近，有多少数量的买单和卖单在等待成交。深度越好，意味着市场能够承受较大数量的买卖而不引起价格剧烈波动。通常，交易活跃的蓝筹股市场深度较好。</li></ul><p>理解订单簿和市场深度，有助于我们选择合适的订单类型和判断交易的难易程度。</p><h4 id="二主要订单类型-common-order-types">二、主要订单类型 (CommonOrder Types)</h4><p><strong>1. 市价单 (Market Order)</strong></p><ul><li><strong>是什么(What)</strong>：市价单是最简单直接的订单类型。<strong>投资者不指定具体价格，只要求以当前市场上可获得的最优价格立即买入或卖出特定数量的证券。</strong><ul><li><strong>买入市价单</strong>：会从卖一价开始向上撮合，直到买足所需数量。</li><li><strong>卖出市价单</strong>：会从买一价开始向下撮合，直到卖出指定数量。</li></ul></li><li><strong>怎么做 (How to use)</strong>：<ul><li>在交易软件中选择“市价”委托。</li><li>输入需要买入或卖出的数量。</li><li>确认提交。</li></ul></li><li><strong>优点</strong>：<ul><li><strong>成交速度快，保证成交</strong>：只要市场上有足够的对手方订单，市价单几乎可以立即成交。这对于希望快速建仓或平仓的投资者非常重要。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>成交价格不确定 (PriceUncertainty)</strong>：尤其是在市场快速波动或流动性不足（市场深度较差）时，最终的成交价格可能与投资者下单时看到的“最优价”（如卖一价或买一价）有较大差异，这种差异称为<strong>滑点(Slippage)</strong>。<ul><li><strong>现实实例</strong>：假设某股票卖一价为10.01元，有3000股挂单。如果你想用市价单买入5000股，那么前3000股可能会以10.01元成交，但剩下的2000股就需要以更高的价格（如卖二价10.02元或更高）成交，导致平均买入成本高于10.01元。在发布重大利好或利空消息，股价剧烈波动时，滑点可能非常显著。</li></ul></li><li><strong>不适合流动性差的证券</strong>：对于交易不活跃、买卖盘口稀疏的股票，使用市价单可能会导致成交价格远超预期。</li></ul></li><li><strong>适用场景</strong>：<ul><li>对成交速度的要求高于对成交价格的要求时。</li><li>交易流动性非常好、价差很小的证券。</li><li>需要快速止损或止盈，不计较微小价格差异时（但需注意极端行情下的滑点风险）。</li></ul></li><li><strong>A股市场的特殊市价单</strong>：为了控制市价单的价格不确定性风险，A股交易所提供了一些优化后的市价单类型，如：<ul><li><strong>最优五档即时成交剩余撤销</strong>：以对手方最优五个价位为限价，依次成交，未成交部分自动撤销。</li><li><strong>最优五档即时成交剩余转限价</strong>：以对手方最优五个价位为限价，依次成交，未成交部分自动转为限价单（通常是转为下单时最新的买一/卖一价）。</li><li><strong>全额成交或撤销 (Fill or Kill -FOK)</strong>：要求订单要么立即按指定价格和数量全部成交，要么立即全部撤销（不产生部分成交）。</li><li><strong>立即成交剩余撤销 (Immediate or Cancel -IOC)</strong>：允许订单部分成交，未成交部分立即撤销。</li></ul></li></ul><p><strong>2. 限价单 (Limit Order)</strong></p><ul><li><strong>是什么(What)</strong>：限价单允许投资者<strong>指定一个买入的最高价格或卖出的最低价格。</strong><ul><li><strong>买入限价单</strong>：只有当市场价格达到或低于你设定的限价时，订单才可能成交。</li><li><strong>卖出限价单</strong>：只有当市场价格达到或高于你设定的限价时，订单才可能成交。</li></ul></li><li><strong>怎么做 (How to use)</strong>：<ul><li>在交易软件中选择“限价”委托。</li><li>输入你愿意接受的买入价格（限价）或卖出价格（限价）。</li><li>输入需要买入或卖出的数量。</li><li>确认提交。</li></ul></li><li><strong>优点</strong>：<ul><li><strong>价格可控 (PriceControl)</strong>：投资者可以确保成交价格不会差于自己设定的限价，避免了市价单的滑点风险。</li><li><strong>可以“挂单等待”</strong>：如果当前市场价格未达到你的理想价位，限价单会进入订单簿中排队等待，直到市场价格满足条件且有对手方匹配。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>不保证成交 (No Guarantee ofExecution)</strong>：如果市场价格一直没有达到你设定的限价，或者即使达到了但排在你前面的订单很多，你的订单也可能无法成交或只能部分成交。<ul><li><strong>现实实例</strong>：你想以9.90元的价格买入某股票，但该股票价格一直在9.95元以上徘徊，那么你的买入限价单就无法成交。或者，你想以10.10元卖出，但股价最高只涨到10.08元就回落了，你的卖单也无法成交。</li></ul></li><li><strong>可能错失机会</strong>：如果过于执着于某个限价，在市场快速上涨（买入）或下跌（卖出）时，可能因为订单未成交而错失上车或离场的机会。</li></ul></li><li><strong>适用场景</strong>：<ul><li>对成交价格有明确要求，不愿以不利价格成交时。</li><li>交易流动性一般或较差的证券，以避免价格大幅偏离。</li><li>希望在特定支撑位买入或在特定阻力位卖出时（技术分析的应用）。</li><li>不急于立即成交，愿意等待更好的价格时。</li></ul></li></ul><p><strong>市价单 vs. 限价单：核心权衡</strong></p><table><thead><tr><th>特点</th><th>市价单 (Market Order)</th><th>限价单 (Limit Order)</th></tr></thead><tbody><tr><td><strong>成交速度</strong></td><td>快，几乎立即成交</td><td>可能较慢，取决于市场价格是否达到限价</td></tr><tr><td><strong>成交保证</strong></td><td>高度保证（只要有对手盘）</td><td>不保证成交</td></tr><tr><td><strong>价格控制</strong></td><td>较差，有滑点风险</td><td>好，成交价不劣于限价</td></tr><tr><td><strong>适用情况</strong></td><td>重视速度，流动性好，或不计较微小价格差异</td><td>重视价格，流动性一般/差，或希望特定价格成交</td></tr></tbody></table><p><strong>3. 止损单 (Stop Order / Stop-Loss Order)</strong> -<strong>需注意与A股市场的区别</strong></p><ul><li><strong>是什么(What)</strong>：止损单是一种当证券价格达到预设的“止损价位 (StopPrice)”时，自动转化为市价单或限价单来执行的订单。其主要目的是限制潜在的亏损。<ul><li><strong>卖出止损单 (Sell StopOrder)</strong>：设置一个低于当前市价的止损价。当股价下跌到或跌破该止损价时，订单被激活，通常转化为市价单卖出（或限价单卖出）。用于保护已有的盈利或限制亏损扩大。<ul><li><strong>例子</strong>：你以10元买入某股票，设置止损价为9.50元。如果股价跌至9.50元或以下，你的止损单被触发，股票将以市价（可能略低于9.50元）卖出。</li></ul></li><li><strong>买入止损单 (Buy StopOrder)</strong>：设置一个高于当前市价的止损价。当股价上涨到或涨破该止损价时，订单被激活，通常转化为市价单买入（或限价单买入）。常用于：<ul><li><strong>保护空头头寸</strong>：如果你做空某股票，当股价上涨到一定程度时，通过买入止损单平仓，限制亏损。</li><li><strong>追突破</strong>：当股价突破某个重要的阻力位时，认为上涨趋势可能形成，通过买入止损单跟进。</li></ul></li></ul></li><li><strong>在A股市场的实现</strong>：A股券商的普通交易系统通常不直接提供标准的“止损单”这种订单类型。投资者往往需要通过券商提供的“条件单”或“智能交易”功能来间接实现类似止损的效果。例如，设置“当股价跌破X元时，以市价（或指定限价）卖出Y股”。</li><li><strong>在海外市场（如美股、港股）</strong>：止损单是标准的订单类型，可以直接设置。</li><li><strong>优点</strong>：<ul><li><strong>自动化风险控制</strong>：无需时刻盯盘，当达到条件时自动执行。</li><li><strong>克服情绪</strong>：避免因犹豫或侥幸心理而未能及时止损。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>可能被“震荡出局”(Whipsaw)</strong>：在市场正常波动或被机构“洗盘”时，股价可能短暂触及止损价后迅速反弹，导致不必要的亏损卖出。</li><li><strong>止损价触发后的成交价不确定</strong>：如果止损单转化为市价单执行，尤其在市场快速跳空下跌时，实际成交价可能远低于止损价（产生较大滑点）。</li><li><strong>止损限价单 (Stop-LimitOrder)</strong>：为了解决止损市价单的滑点问题，可以设置止损限价单。即当股价达到止损价时，订单转化为一个指定价格的限价单。优点是控制了成交价格的下限（卖出）或上限（买入），缺点是如果市场价格快速穿过限价，订单可能无法成交，从而失去了止损的意义。</li></ul></li></ul><p><strong>4. 其他高级订单类型 (Advanced Order Types)</strong> -了解即可，初学者慎用</p><ul><li><strong>跟踪止损单 (Trailing StopOrder)</strong>：止损价不是固定的，而是随着股价向有利方向移动而动态调整（例如，始终保持在最高价下方X元或Y%的水平）。</li><li><strong>冰山订单 (IcebergOrder)</strong>：将一个大的订单分割成许多小的、分批显示的订单，以避免大单直接冲击市场价格，暴露交易意图。</li><li><strong>条件单 (ConditionalOrder)</strong>：基于更复杂的条件（如多只股票的价格关系、技术指标达到某个值等）来触发的订单。</li></ul><h4 id="三订单的有效期-order-duration">三、订单的有效期 (OrderDuration)</h4><ul><li><strong>当日有效单 (DayOrder)</strong>：如果订单在当天交易时段结束前未能完全成交，未成交部分将自动失效。这是大多数交易平台的默认设置。</li><li><strong>成交并取消单 (Good 'Til Canceled -GTC)</strong>：订单会一直保持有效，直到被完全执行或投资者手动取消。不同券商对GTC订单的最长有效期有不同规定（如30天、90天）。在A股市场，通常没有标准的GTC订单，都是当日有效。海外市场较常见。</li><li><strong>开盘指令 (At-the-Open Order) / 收盘指令 (At-the-CloseOrder)</strong>：要求订单尽可能在开盘价或收盘价附近成交。</li></ul><p><strong>为什么 (Why)：理解不同订单类型的重要性</strong></p><ol type="1"><li><strong>实现交易意图</strong>：选择正确的订单类型，才能更好地按照自己的价格预期和风险控制要求来执行交易。</li><li><strong>控制交易成本</strong>：合理使用限价单可以避免不利的滑点，从而间接控制成本。</li><li><strong>管理交易风险</strong>：如止损单的应用（虽然在A股需要变通实现）。</li><li><strong>提高交易效率</strong>：了解不同订单的成交特性，有助于在不同市场环境下做出更有效的操作。</li></ol><p><strong>小结</strong></p><p>掌握市价单和限价单这两种最基本的订单类型，是进行证券交易的必备技能。市价单追求速度和成交保证，但牺牲了价格确定性；限价单追求价格控制，但牺牲了成交保证和速度。投资者需要根据自己的交易目标、所交易证券的流动性以及当前的市场状况，灵活选择合适的订单类型。对于止损单等更高级的订单类型，初学者应在充分理解其机制和风险后再考虑使用，尤其是在A股市场，需要通过券商的条件单功能来实现，更要仔细阅读其说明。实践是最好的老师，在模拟交易或小额实盘操作中多尝试不同订单类型，能更快地加深理解。</p><h3 id="第三节投资纪律">第三节：投资纪律</h3><p>即使我们掌握了精深的分析方法、选择了理想的交易平台、熟悉了各种订单类型，如果在实际操作中缺乏<strong>投资纪律</strong>，那么所有的知识和准备都可能付诸东流。投资纪律是投资者为自己设定的一套行为准则和操作规则，旨在克服人性的弱点（如贪婪、恐惧、侥幸心理），避免情绪化决策，从而更理性、更持续地执行自己的投资策略。可以说，投资纪律是知行合一的保障。</p><h4 id="一为什么要强调投资纪律">一、为什么要强调投资纪律？</h4><p><strong>是什么 (What)：投资纪律——抵御人性弱点的行为框架</strong></p><p>投资纪律并非一套僵化的教条，而是一个<strong>基于个人投资哲学、目标和风险承受能力而制定的，用以指导投资决策和行为的系统性框架。</strong>它帮助投资者在纷繁复杂、充满诱惑和恐惧的市场中保持清醒和一致性。</p><ul><li><strong>人性的挑战</strong>：正如我们在第一章第六节“克服心理障碍”中讨论的，人类天生就有很多认知偏差和情绪反应（如追涨杀跌、过度自信、损失厌恶、锚定效应等），这些在投资中往往是有害的。<ul><li><strong>贪婪</strong>：在市场上涨时，贪婪会驱使我们追高，甚至加杠杆，希望能赚取更多，结果可能买在顶部。</li><li><strong>恐惧</strong>：在市场下跌时，恐惧会让我们恐慌性抛售，即使是优质资产也可能在底部割肉。</li><li><strong>侥幸心理/鸵鸟心态</strong>：当投资出现亏损时，不愿面对现实，期待“总会涨回来”，结果可能越陷越深。</li><li><strong>频繁交易的冲动</strong>：试图抓住每一次市场波动，结果往往是增加了交易成本，却未必能提高回报。</li></ul></li><li><strong>市场的不确定性</strong>：市场本身充满不确定性，没有人能完美预测未来。投资纪律提供了一种在不确定环境中保持行为一致性的方法。</li><li><strong>《聪明的投资者》</strong>中，本杰明·格雷厄姆强调，投资者的主要问题，甚至是他最大的敌人，很可能就是他自己。他认为，建立并遵守一套合理的投资原则，是防御这种“内部敌人”的关键。</li></ul><p><strong>没有纪律的投资，就像没有舵的船，随波逐流，极易偏离航向甚至倾覆。</strong></p><h4 id="怎么做-how制定和遵守投资纪律的关键方面">怎么做(How)：制定和遵守投资纪律的关键方面</h4><p>投资纪律的建立是一个个性化的过程，但通常应包含以下几个核心方面：</p><p><strong>1. 制定清晰的投资目标与计划 (Clear Investment Goals andPlan)</strong></p><ul><li><strong>在行动之前思考</strong>：<ul><li>你的投资是为了什么？（短期目标、中期目标、长期目标如养老、子女教育等）</li><li>你的风险承受能力如何？（能接受多大的回撤？）</li><li>你的投资期限是多久？</li></ul></li><li><strong>制定书面的投资计划</strong>：将你的投资目标、策略选择（价值、成长、指数、资产配置比例等）、风险管理措施（如最大仓位限制、止损原则等）明确地写下来。书面计划有助于强化承诺，并在市场波动时提醒自己不忘初心。</li></ul><p><strong>2. 制定买入原则 (Establishing Buying Principles)</strong></p><ul><li><strong>基于你的投资策略</strong>：<ul><li><strong>价值投资者</strong>：只在出现显著安全边际时买入（例如，股价低于内在价值的30%-50%）。明确哪些财务指标或定性因素是买入的触发条件。</li><li><strong>成长投资者</strong>：明确什么样的成长速度、市场空间、竞争优势和估值水平（如PEG）是你愿意买入的标准。</li><li><strong>指数投资者</strong>：明确你选择定投的指数、定投的频率和金额，以及在市场出现极端低估时是否追加投资的原则。</li></ul></li><li><strong>不买自己不懂的</strong>：这是巴菲特反复强调的“能力圈”原则。如果你不理解一家公司的业务模式、盈利来源和风险所在，就不要投资它。</li><li><strong>避免“消息驱动”的盲目买入</strong>：不要仅仅因为听到某个“内幕消息”、“市场传言”或“专家推荐”就草率买入。坚持独立分析和判断。</li><li><strong>分批买入的考虑</strong>：对于看好的标的，如果担心一次性买入点位不佳，可以考虑分批建仓，以平滑成本。</li></ul><p><strong>3. 制定卖出原则 (Establishing SellingPrinciples)</strong></p><p>卖出往往比买入更难，因为涉及到对未来判断的改变和对已有盈利或亏损的处理。清晰的卖出原则至关重要。</p><ul><li><strong>达到目标价位/估值过高</strong>：<ul><li>如果当初买入的逻辑是基于价值低估，当股价上涨到你认为的合理价值甚至显著高估时，应考虑卖出或减持。</li><li><strong>彼得·林奇</strong>提到，对于周期股，在行业景气度达到顶峰、公司盈利最好、市盈率最低时，往往是卖出的时机。</li></ul></li><li><strong>基本面发生根本性恶化</strong>：<ul><li>如果公司的竞争优势丧失、行业前景逆转、管理层出现重大问题、财务状况持续恶化等，导致你最初的买入逻辑不再成立，那么无论盈亏，都应该果断卖出。</li><li><strong>不要将“希望”作为投资策略</strong>。死守基本面变坏的股票，期待它“奇迹般”反转，往往是徒劳的。</li></ul></li><li><strong>发现更好的投资机会</strong>：<ul><li>如果你的资金有限，而你发现了一个具有更高预期回报和更佳风险收益比的新投资机会，可以考虑卖出现有持仓中相对不那么具有吸引力的标的，进行置换。但这需要非常审慎的比较和判断，避免仅仅为了“换股”而换股。</li></ul></li><li><strong>达到止损点（如果采用此策略）</strong>：<ul><li>如前所述，止损策略有其争议，但如果你决定采用，就必须严格执行。</li></ul></li><li><strong>因为需要现金而卖出</strong>：这不属于投资策略层面的卖出，而是个人财务规划的需要。</li><li><strong>避免因短期市场波动而卖出</strong>：如果公司的基本面依然良好，仅仅因为市场情绪导致的短期下跌，不应成为卖出的理由。</li></ul><p><strong>4. 如何应对亏损？ (Dealing with Losses)</strong></p><p>亏损是投资中不可避免的一部分。关键在于如何理性地应对它。</p><ul><li><strong>区分浮亏与实亏，更要区分“好公司暂时跌”与“坏公司继续坏”</strong>：<ul><li>如果你持有的优质公司，其长期基本面未变，仅仅因为市场短期调整而出现账面浮亏，且你对公司的长期前景依然有信心，那么“卧倒不动”甚至在更低价格加仓（前提是有足够安全边际和对公司的深刻理解）可能是合理的。</li><li>但如果亏损是因为公司基本面确实恶化了，或者你当初的买入判断就是错误的，那么不应抱有幻想，及时止损（承认错误并卖出）是明智的选择，以避免更大的损失。</li></ul></li><li><strong>不要让亏损影响后续决策（避免“翻本心理”）</strong>：不要因为某笔投资亏损了，就急于在下一笔投资中冒更大的风险试图“把亏的钱赚回来”。每一笔投资都应该基于其自身的价值和风险进行独立判断。</li><li><strong>从亏损中学习</strong>：每一次亏损都是一次宝贵的教训。冷静分析亏损的原因：是选股错误？择时错误？估值过高？还是未能遵守纪律？将经验教训记录下来，避免重蹈覆辙。</li><li><strong>控制单笔投资的最大亏损额度</strong>：通过仓位管理，确保没有任何一笔投资的失败会导致你整体财务状况陷入困境。</li><li><strong>保持积极心态，但不要盲目乐观</strong>：接受亏损是投资的一部分，但也要从中吸取教训，不断完善自己的投资体系。</li></ul><p><strong>5. 如何避免情绪化交易？ (Avoiding EmotionalTrading)</strong></p><ul><li><strong>制定并遵守交易计划</strong>：如前所述，书面的计划是抵御情绪的“防火墙”。在市场波动让你感到不安时，回头看看你的计划，它会提醒你最初的逻辑和目标。</li><li><strong>设定“冷静期”</strong>：当市场剧烈波动，或者你因为某笔交易产生强烈情绪（兴奋、沮丧、愤怒）时，在做任何新的交易决策前，给自己设定一个“冷静期”（比如24小时），避免在情绪的顶峰做决定。</li><li><strong>减少盯盘频率</strong>：对于长期投资者而言，过于频繁地查看账户净值和股价波动，只会徒增焦虑，更容易引发情绪化操作。设定一个合理的查看频率（如每周一次，甚至每月一次）。</li><li><strong>关注过程而非短期结果</strong>：投资是一场马拉松。关注你的决策过程是否理性、是否符合你的原则，比关注一两天的账户盈亏更重要。</li><li><strong>拥有投资以外的生活</strong>：不要让投资占据你全部的精力和情绪。保持健康的生活方式、培养其他兴趣爱好，有助于在投资不顺时分散注意力，保持心态平和。</li><li><strong>寻找志同道合的良师益友（但警惕羊群效应）</strong>：与理性的、有经验的投资者交流，可以帮助你校正认知，获得支持，但最终决策仍需自己做出，避免盲目跟风。</li><li><strong>认识到“噪音”的存在</strong>：市场中充斥着各种各样的信息和观点，很多都是短期“噪音”，会干扰你的判断。学会筛选真正有价值的信息，忽略无关的干扰。<strong>霍华德·马克斯</strong>在<strong>《投资最重要的事》</strong>中强调了“第二层次思维”，即透过现象看本质，不被表面的市场情绪所迷惑。</li></ul><p><strong>6. 建立投资日志与定期复盘 (Investment Journal and RegularReview)</strong></p><ul><li><strong>记录每一笔交易的理由</strong>：在买入或卖出时，详细记录下你做出该决策的分析过程、关键假设、预期目标、以及当时的市场环境和你的情绪状态。</li><li><strong>定期回顾和评估</strong>：每隔一段时间（如每季度、每半年或每年），回顾你的投资日志和投资组合的表现。<ul><li>当初的决策逻辑是否依然成立？</li><li>实际结果与预期是否一致？如果出现偏差，原因是什么？</li><li>哪些决策是正确的？哪些是错误的？</li><li>从成功和失败中可以吸取哪些经验教训？</li><li>你的投资纪律是否得到了很好的遵守？哪些方面需要改进？</li></ul></li><li><strong>这是一个持续学习和自我提升的过程</strong>。通过复盘，可以不断优化你的投资策略和纪律。</li></ul><p><strong>现实中的实例</strong>：</p><ul><li><strong>巴菲特的纪律性</strong>：巴菲特以其超凡的耐心和严格的投资纪律著称。在市场狂热、别人都在追逐热门股时，他常常选择按兵不动，因为找不到符合他标准（内在价值、安全边际、能力圈）的投资机会。例如，在1999-2000年互联网泡沫时期，伯克希尔·哈撒韦公司因为没有投资科技股而受到质疑，但巴菲特坚持不投自己不懂的领域，最终在泡沫破裂后证明了他的远见。</li><li><strong>许多散户的“反面教材”</strong>：在牛市中，很多散户会忘记风险，盲目追高，甚至借钱炒股；而在熊市中，又因恐慌而底部割肉，反复上演“高买低卖”的悲剧。这正是缺乏投资纪律的典型表现。</li></ul><p><strong>小结</strong></p><p>投资纪律是连接“知道”与“做到”的桥梁，是投资者走向成熟的必经之路。它不是一蹴而就的，需要在实践中不断磨练、反思和完善。制定清晰的买入和卖出原则，理性应对亏损，努力避免情绪化交易，并建立持续复盘的习惯，这些都是构筑强大投资纪律的关键要素。记住，市场永远充满不确定性，但你可以控制的是自己的行为。一个有纪律的投资者，即使不能保证每一次都盈利，但更有可能在长期的投资生涯中获得成功，并避开那些可能导致重大损失的陷阱。</p><h3 id="第四节信息渠道">第四节：信息渠道</h3><p>在投资决策的每一个环节，从公司分析、行业判断到风险评估，我们都离不开信息的支持。然而，在今天这个信息爆炸的时代，我们面临的挑战往往不是信息匮乏，而是信息过载以及如何从海量信息中筛选出高质量、真实可靠的内容，并警惕那些可能误导我们决策的“噪音”和虚假信息。本节将探讨如何构建有效的信息获取渠道，并培养辨别信息真伪的能力。</p><h4 id="一信息的重要性与噪音的困扰">一、信息的重要性与“噪音”的困扰</h4><p><strong>是什么 (What)：信息——投资决策的“原材料”</strong></p><p><strong>投资信息是指能够影响投资者对金融资产价值判断、市场趋势预期以及风险认知的所有数据、新闻、分析和观点。</strong>优质的信息是做出明智投资决策的基石。</p><p>然而，并非所有信息都是有价值的。市场上充斥着大量的：</p><ul><li><strong>噪音(Noise)</strong>：指那些看似相关，但实际上对长期投资价值判断并无实质性帮助，甚至可能产生误导的短期、琐碎、情绪化或未经证实的信息。例如，每日股价的微小波动、未经证实的小道消息、某些缺乏深度分析的股评等。</li><li><strong>虚假信息/误导性信息 (False or MisleadingInformation)</strong>：包括刻意编造的谣言、带有偏见或利益驱动的“研究报告”、夸大其词的宣传、甚至是财务造假公司发布的虚假财报等。</li><li><strong>过时信息 (OutdatedInformation)</strong>：在快速变化的市场中，一些曾经准确的信息可能已经不再适用。</li></ul><p><strong>《聪明的投资者》</strong>中，格雷厄姆就曾提醒投资者要警惕华尔街的“销售技巧”和那些试图预测市场短期走势的“专家”。他更强调基于事实和长期价值的独立判断。</p><p><strong>信息过载的挑战</strong>：现代媒体（尤其是互联网和社交媒体）使得信息的传播速度极快、范围极广。投资者每天都会被各种新闻推送、分析评论、股吧讨论所包围，很容易陷入“信息焦虑”，难以集中精力进行深度思考和长期规划。</p><h4 id="怎么做-how构建高质量的信息渠道与筛选方法">怎么做(How)：构建高质量的信息渠道与筛选方法</h4><p>建立一套可靠、高效的信息获取与筛选机制，是成功投资者的必备技能。</p><p><strong>1. 一手信息来源 (Primary Sources) -最可靠，但需专业解读</strong></p><p>一手信息通常指直接来源于信息发布主体，未经中间加工或解读的原始信息。</p><ul><li><strong>上市公司官方披露</strong>：<ul><li><strong>定期报告</strong>：年度报告（年报）、半年度报告（中报）、季度报告（季报）。这是了解一家上市公司最权威、最全面的信息来源，包含了详细的财务数据、经营情况分析、管理层讨论与分析(MD&amp;A)、未来展望、风险提示等。仔细阅读年报（尤其是管理层讨论与分析、主要业务回顾、核心竞争力分析、财务报表附注等部分）是基本功。</li><li><strong>临时公告</strong>：关于公司的重大事件，如重大合同、并购重组、高管变动、业绩预告、增发配股、分红派息、诉讼仲裁等。</li><li><strong>招股说明书 (IPOProspectus)</strong>：对于新上市公司，招股书是了解其历史沿革、业务模式、股权结构、募投项目、风险因素等最详细的文件。</li><li><strong>投资者关系活动记录表</strong>：记录了公司与机构投资者、分析师等交流的内容，有时能提供一些年报中未详细展开的信息。</li><li><strong>获取渠道</strong>：证券交易所官方网站（如上交所、深交所、港交所、纽交所、纳斯达克官网）、巨潮资讯网（A股法定信息披露平台）、上市公司官网的“投资者关系”栏目。</li></ul></li><li><strong>监管机构官方信息</strong>：<ul><li><strong>证监会、银保监会、央行等监管机构的官网</strong>：发布法规政策、处罚公告、行业数据、风险提示等。</li><li><strong>交易所规则与通知</strong>：关于交易制度、上市公司监管要求等。</li></ul></li><li><strong>行业协会与政府部门报告</strong>：<ul><li>权威行业协会发布的行业发展报告、统计数据等。</li><li>国家统计局、工信部等政府部门发布的宏观经济数据、产业政策、行业运行数据等。</li></ul></li></ul><p><strong>2. 二手信息来源 (Secondary Sources) -经过加工，需审慎辨别</strong></p><p>二手信息是指对一手信息进行加工、整理、分析、评论后形成的信息。</p><ul><li><strong>权威财经媒体</strong>：<ul><li><strong>国内</strong>：如《中国证券报》、《上海证券报》、《证券时报》、《证券市场周刊》、《财经》、《财新》等传统财经媒体及其官方网站和APP。它们通常有专业的记者和编辑团队，信息相对严谨。</li><li><strong>国际</strong>：如《华尔街日报》(Wall StreetJournal)、《金融时报》(Financial Times)、彭博社 (Bloomberg)、路透社(Reuters)、《经济学人》(The Economist)等。这些媒体在全球财经领域有较高声誉。</li><li><strong>关注点</strong>：深度报道、行业分析、对重大事件的解读。但要注意区分新闻报道与观点评论。</li></ul></li><li><strong>专业研究机构的报告（券商研报、第三方研究报告）</strong>：<ul><li><strong>优点</strong>：通常由具备专业知识的分析师撰写，对行业和公司有较深入的研究，提供数据支持和估值模型。</li><li><strong>缺点/注意事项</strong>：<ul><li><strong>潜在的利益冲突</strong>：券商研究所可能因为投行业务等原因，对其承销或有业务往来的公司给出过于乐观的评级。</li><li><strong>“研报马后炮”或“一致性预期”</strong>：有时研报的观点可能趋同，或者在股价上涨后才发布“看好”报告。</li><li><strong>质量参差不齐</strong>：并非所有研报都有高质量。</li><li><strong>如何使用</strong>：将其作为获取信息、了解分析逻辑和数据来源的工具，而非直接的投资决策依据。要看其分析过程是否严谨，假设是否合理，而不是只看结论和目标价。可以多看几家不同机构的报告，进行交叉验证。</li></ul></li></ul></li><li><strong>投资大师的著作与访谈</strong>：<ul><li>阅读巴菲特致股东的信、彼得·林奇的书、霍华德·马克斯的备忘录等，可以学习他们的投资哲学、分析框架和对市场规律的洞察。这些是超越短期信息的智慧结晶。</li></ul></li><li><strong>高质量的财经数据库与工具</strong>：<ul><li>如Wind（万得）、Bloomberg Terminal、RefinitivEikon、Choice数据等（这些通常机构用户较多，费用较高）。</li><li>一些券商交易软件或第三方财经APP也提供相对丰富的财务数据、行业数据、研报摘要等。</li></ul></li><li><strong>学术研究与期刊</strong>：<ul><li>经济学、金融学领域的学术期刊和工作论文，有时会提供对市场现象和投资策略的深度理论分析。</li></ul></li></ul><p><strong>3. 需要高度警惕的信息渠道</strong></p><ul><li><strong>社交媒体、股吧、论坛上的“小道消息”和“内幕信息”</strong>：<ul><li>这些渠道信息传播快，但往往鱼龙混杂，充斥着大量未经证实、情绪化、甚至刻意误导的信息。</li><li>真正的“内幕信息”是违法的，普通投资者很难接触到。声称有“内幕消息”的人，往往是骗子或别有用心。</li><li><strong>巴菲特曾说：“打听内幕消息的人，最终会以内幕消息的价格买单。”</strong></li></ul></li><li><strong>所谓的“荐股大师”、“炒股软件”</strong>：<ul><li>承诺“保证盈利”、“月收益XX%”的，几乎都是骗局。如果真有如此稳赚不赔的方法，他们自己闷声发大财即可，何需广而告之？</li><li>很多“荐股群”的目的是为了“割韭菜”，通过拉高出货等方式坑害散户。</li></ul></li><li><strong>过度简化的“投资秘籍”和“快速致富”信息</strong>：投资没有捷径，需要长期的学习和实践。</li><li><strong>带有强烈情绪煽动性的文章和视频</strong>：这类内容往往是为了博眼球、带节奏，缺乏理性分析。</li></ul><p><strong>如何筛选和辨别信息？</strong></p><ol type="1"><li><strong>追溯信息来源 (Trace theSource)</strong>：这条信息是从哪里来的？是一手官方披露，还是二手转述，甚至是三手四手传播？来源越权威、越接近原始出处，可靠性通常越高。</li><li><strong>交叉验证(Cross-Verification)</strong>：对于重要的信息，尤其是可能影响你投资决策的信息，尝试从多个独立的不同来源进行核实。如果多个可靠渠道都报道了同样的事实，那么其可信度较高。</li><li><strong>评估发布者的可信度与动机 (Assess Credibility andMotivation)</strong>：<ul><li>发布者是专业的财经记者、持牌分析师、有良好声誉的投资人，还是匿名的网络用户？</li><li>发布者是否有潜在的利益冲突？（例如，某分析师是否在推荐自己券商承销的股票？）</li><li>他们发布信息的目的是什么？是客观分析，还是为了推销产品、吸引流量、或者操纵市场情绪？</li></ul></li><li><strong>区分事实与观点 (Distinguish Facts from Opinions)</strong>：<ul><li><strong>事实</strong>是可以被验证的客观陈述（如公司财报数据、已发生的事件）。</li><li><strong>观点</strong>是个人基于事实的解读、判断或预测（如“我认为这只股票会上涨”、“这家公司前景广阔”）。</li><li>关注事实，审慎对待观点，尤其是那些缺乏充分论证的观点。</li></ul></li><li><strong>注意时效性 (CheckTimeliness)</strong>：信息是否是最新的？在快速变化的市场中，过时的信息可能已经失去价值甚至产生误导。</li><li><strong>警惕“幸存者偏差”和“确认偏误”</strong>：<ul><li>不要只关注那些成功的案例和支持你已有观点的声音，也要主动去了解不同的看法和潜在的风险。</li></ul></li><li><strong>培养批判性思维 (Develop CriticalThinking)</strong>：不要轻易相信你看到或听到的一切。对信息进行质疑、分析、比较，形成自己的独立判断。</li><li><strong>关注长期信号，忽略短期噪音</strong>：<strong>霍华德·马克斯</strong>强调，投资者应该努力识别那些真正影响长期价值的“信号”，而过滤掉那些只引起短期波动的“噪音”。这需要经验和定力。</li><li><strong>建立自己的信息处理流程</strong>：<ul><li><strong>固定信息来源</strong>：选择几个你认为可靠、高质量的信息渠道作为主要来源，定期阅读。</li><li><strong>信息分类与优先级</strong>：将信息分为“必须关注”、“可以了解”、“无需理会”等不同级别。</li><li><strong>控制信息输入量</strong>：避免让自己淹没在信息的海洋中。设定每天或每周用于获取和处理投资信息的时间上限。</li></ul></li></ol><p><strong>现实中的实例</strong>：</p><ul><li><strong>财务造假公司的误导</strong>：历史上著名的安然公司、世通公司，以及近年的瑞幸咖啡等，都曾通过发布虚假的财务报告来误导投资者，导致投资者在真相暴露后遭受巨大损失。这凸显了独立分析和对一手财报进行审慎解读的重要性，不能仅仅依赖公司“讲的故事”。</li><li><strong>“牛市股神”的幻象</strong>：在牛市中，很多人会因为短期内买了几只上涨的股票而自诩为“股神”，并在社交媒体上大肆宣传，吸引跟风者。但当潮水退去，这些所谓的“股神”往往会销声匿迹。这提醒我们要警惕那些缺乏长期业绩验证的“专家”。</li></ul><p><strong>小结</strong></p><p>在信息时代，获取信息本身已不成问题，真正的挑战在于<strong>信息的质量管理——如何找到金子，并剔除沙子和毒丸。</strong>投资者需要有意识地构建自己的高质量信息渠道，以权威的一手信息为核心，辅以可信的二手信息进行佐证和启发，同时对那些充斥着噪音和虚假信息的渠道保持高度警惕。更重要的是，要培养独立思考和批判性分析的能力，不盲从、不轻信，努力在纷繁的信息中洞察真相，为自己的投资决策提供坚实可靠的依据。记住，**“你所依赖的信息，决定了你投资的上限。”</p><p>好的，我们来撰写第五节“税务知识”以及第四章的总结。税务是投资中一个常常被忽视但又非常重要的方面。</p><hr /><h3 id="第五节税务知识">第五节：税务知识</h3><p>在投资的旅程中，除了关注收益率和风险控制，还有一个不可忽视的因素会直接影响到我们最终的“落袋收益”，那就是<strong>税收</strong>。不同国家和地区对投资相关的税收规定各不相同，了解这些基本的税务知识，有助于我们更全面地评估投资回报，并在合规的前提下进行合理的税务规划（TaxPlanning），从而最大化税后收益。本节将简要介绍一些与投资相关的常见税种，并强调其因国家/地区而异的特性。</p><p><strong>请注意：本节内容仅为一般性科普，不构成任何税务建议。具体的税务问题请务必咨询专业的税务顾问或参考当地税务机关的官方规定。税法复杂且可能随时变更。</strong></p><h4id="一为什么需要了解投资相关的税务知识">一、为什么需要了解投资相关的税务知识？</h4><p><strong>是什么 (What)：税收——投资回报的“隐形”分配者</strong></p><p><strong>投资相关税收是指政府对个人或机构通过投资活动获得的收益（如股息、利息、资本利得）所征收的各种税款。</strong>这些税款会直接从你的投资回报中扣除，减少你的实际到手金额。</p><ul><li><strong>通俗理解</strong>：就像你工作获得的工资需要缴纳个人所得税一样，你通过投资赚到的钱，也可能需要向政府缴纳一部分作为税款。</li><li><strong>影响投资决策</strong>：税务考量可能会影响你的投资策略、持有期限、资产配置以及投资工具的选择。例如，某些国家对长期持有资产的资本利得税率可能低于短期持有，这会鼓励长期投资。某些特定的投资账户（如养老金账户）可能享有税收优惠。</li></ul><h4id="二常见的投资相关税种因国家地区而异">二、常见的投资相关税种（因国家/地区而异）</h4><p>以下是一些在全球范围内比较常见的与个人投资相关的税种，但具体名称、税率、征收方式、免税额度等在不同国家和地区差异巨大。</p><p><strong>1. 股息税 (Dividend Tax)</strong></p><ul><li><strong>是什么(What)</strong>：指对上市公司向股东分配的股息（红利）所征收的税。</li><li><strong>征收方式</strong>：<ul><li><strong>源泉扣缴 (WithholdingTax)</strong>：通常由派发股息的公司或其托管机构在支付股息时代扣代缴。</li><li><strong>个人所得税申报</strong>：在某些情况下，股息收入需要并入个人年度所得中进行申报纳税。</li></ul></li><li><strong>税率</strong>：<ul><li><strong>中国大陆 (A股)</strong>：<ul><li>持股期限在1个月以内（含1个月）的，股息红利所得全额计入应纳税所得额，实际税负为20%。</li><li>持股期限在1个月以上至1年（含1年）的，暂减按50%计入应纳税所得额，实际税负为10%。</li><li>持股期限超过1年的，暂免征收个人所得税。</li><li>（注：此为一般情况，具体以最新政策为准。QFII/RQFII等特殊主体可能有不同规定。）</li></ul></li><li><strong>香港(港股)</strong>：香港不对本地个人投资者收取的股息征税。但如果投资的是H股（在香港上市的内地注册公司），其派发的股息可能会被内地税务机关视为来源于中国内地的所得，并按10%的税率代扣代缴企业所得税（针对非居民企业股东）或个人所得税（针对非居民个人股东，具体根据双边税收协定）。对于内地个人投资者通过港股通投资H股，股息红利按20%的税率代扣个人所得税。</li><li><strong>美国 (美股)</strong>：<ul><li>对于美国税务居民，合格股息 (Qualified Dividends)通常享受较低的长期资本利得税率，非合格股息 (Non-qualified/OrdinaryDividends) 则按普通所得税率征税。</li><li>对于非美国税务居民（如中国投资者），收到的美股股息通常会被美国源泉扣缴30%的税款（除非有双边税收协定可以降低税率，例如中美之间的税收协定通常将股息预提所得税率降至10%，但这需要投资者向券商提交W-8BEN表格申请协定待遇）。</li></ul></li></ul></li><li><strong>影响</strong>：股息税会直接减少投资者实际收到的股息金额。对于偏好高股息策略的投资者，股息税的影响尤为显著。</li></ul><p><strong>2. 资本利得税 (Capital Gains Tax)</strong></p><ul><li><strong>是什么(What)</strong>：指对出售资产（如股票、债券、基金、房地产等）所获得的利润（即卖出价格高于买入成本的部分）所征收的税。如果卖出价格低于买入成本，则产生资本损失，某些情况下资本损失可以抵扣未来的资本利得。</li><li><strong>短期资本利得 vs.长期资本利得</strong>：许多国家会对持有时间较短（如一年以内）的资产出售所产生的利得（短期资本利得）按较高的税率（通常等同于普通所得税率）征税，而对持有时间较长（如一年以上）的资产出售所产生的利得（长期资本利得）按较低的优惠税率征税。</li><li><strong>税率与规定</strong>：<ul><li><strong>中国大陆(A股)</strong>：目前，对于个人投资者买卖境内上市公司股票（A股、B股）和证券投资基金份额取得的差价收入，<strong>暂免征收个人所得税</strong>。但对于个人转让限售股、非上市公司股权等，则有不同的规定。</li><li><strong>香港</strong>：香港对资本利得<strong>不征税</strong>。这是香港作为国际金融中心的一个重要优势。</li><li><strong>美国</strong>：<ul><li>美国税务居民需要就全球范围内的资本利得纳税。短期资本利得按普通所得税率征税，长期资本利得享受优惠税率（0%,15%或20%，取决于应税收入水平）。</li><li>对于非美国税务居民（如中国投资者），买卖美股所获得的资本利得<strong>通常不被视为来源于美国的所得，因此一般无需向美国缴纳资本利得税</strong>（但某些特定情况除外，如投资于美国房地产权益的收益）。</li></ul></li></ul></li><li><strong>影响</strong>：资本利得税会影响投资的持有策略。在有资本利得税且长期税率优惠的国家，投资者可能更倾向于长期持有以享受较低税率。</li></ul><p><strong>3. 利息税 (Interest Tax)</strong></p><ul><li><strong>是什么(What)</strong>：指对从债券、银行存款、货币市场基金等获得的利息收入所征收的税。</li><li><strong>征收方式与税率</strong>：各国规定不一。<ul><li><strong>中国大陆</strong>：目前，个人储蓄存款利息所得暂免征收个人所得税。个人投资者从公开发行和转让的国债和地方政府债券取得的利息收入免征个人所得税；从企业债券等获得的利息收入通常需要缴纳个人所得税（按“利息、股息、红利所得”项目，税率20%）。</li><li><strong>美国</strong>：美国税务居民的利息收入通常需要作为普通收入纳税。非美国税务居民从美国银行存款、某些类型的美国债券（如美国国债、市政债券、符合条件的组合债利息PortfolioInterest）获得的利息，通常可以免除美国的预提所得税（需正确填写W-8BEN表格）。</li></ul></li></ul><p><strong>4. 印花税 (Stamp Duty)</strong></p><ul><li>在上一节“交易平台”中已经提及，是对证券交易行为本身征收的税，与盈利与否无关。主要影响交易成本。</li></ul><p><strong>5. 遗产税与赠与税 (Estate Tax and Gift Tax)</strong></p><ul><li><strong>是什么(What)</strong>：在某些国家，当个人去世后其遗产（包括投资资产）转移给继承人时，可能需要缴纳遗产税；或者在生前将大额资产赠与他人时，可能需要缴纳赠与税。</li><li><strong>影响</strong>：对于有大额资产传承需求的投资者，需要提前了解相关规定并进行规划。</li><li><strong>中国大陆目前没有普遍开征遗产税和赠与税</strong>。美国等国家则有较为复杂的遗产税和赠与税制度。</li></ul><p><strong>双边税收协定 (Double Taxation Agreements / TaxTreaties)</strong></p><ul><li>许多国家之间签订了双边税收协定，旨在避免同一笔所得被两个国家重复征税，并降低跨境投资的预提所得税率。</li><li>例如，中美税收协定通常将非美国居民从美国获得的股息的预提所得税率从30%降至10%。投资者需要向券商或相关机构提交特定表格（如W-8BEN）来申请享受协定待遇。</li></ul><h4 id="怎么做-how应对投资税务的基本思路">怎么做(How)：应对投资税务的基本思路</h4><ol type="1"><li><strong>了解你所在税务居民身份国家/地区的税法</strong>：这是最基本的一步。明确哪些投资收益需要纳税，税率是多少，申报截止日期是什么时候。</li><li><strong>了解你所投资的海外市场的税务规定</strong>：如果你进行跨境投资，还需要了解投资对象国对非居民投资者的税务政策，以及是否有双边税收协定可以适用。</li><li><strong>选择合适的投资账户类型</strong>：许多国家提供具有税收优惠的特定投资账户，如养老金账户（美国的401(k)、IRA；加拿大的RRSP、TFSA等）、教育储蓄账户等。在这些账户内进行的投资，其收益可能享受递延纳税或免税的待遇。</li><li><strong>合理利用税法允许的抵扣和免税额度</strong>：例如，某些国家允许用资本损失抵扣资本利得；或者有一定的年度免税额。</li><li><strong>考虑持有期限对税率的影响</strong>：在有短期/长期资本利得税率差异的国家，可以通过延长持有期来争取较低的税率。</li><li><strong>妥善保存交易记录和税务文件</strong>：以便在报税时准确计算应纳税额，并应对可能的税务稽查。</li><li><strong>寻求专业税务建议</strong>：如果你的投资情况比较复杂，或者涉及大额跨境投资，强烈建议咨询专业的税务顾问。他们可以根据你的具体情况提供个性化的税务规划建议，帮助你在合规的前提下优化税务负担。</li><li><strong>保持对税法变化的关注</strong>：税法并非一成不变，政府可能会根据经济形势和政策目标进行调整。投资者需要保持关注，及时了解最新的税务规定。</li></ol><p><strong>为什么 (Why)：了解税务知识的重要性</strong></p><ol type="1"><li><strong>合法合规，避免税务风险</strong>：不了解税法可能导致无意中的偷税漏税，从而面临罚款甚至更严重的法律后果。</li><li><strong>准确评估真实回报</strong>：税收是投资回报的直接减项。不考虑税收因素，可能会高估投资的实际收益。</li><li><strong>优化投资决策</strong>：税务考量可以帮助你选择更优的投资工具、持有策略和账户类型，从而在合法范围内提高税后回报。</li><li><strong>进行有效的财务规划</strong>：尤其是对于大额投资和长期财务目标（如养老、财富传承），税务规划是不可或缺的一环。</li></ol><p><strong>小结</strong></p><p>税务是投资世界中一个复杂但不可回避的组成部分。虽然具体的税法规定因国家和地区而异，并且可能经常变化，但作为一名负责任的投资者，了解与自己投资活动相关的基本税务知识是非常必要的。这不仅有助于我们遵守法律法规，避免不必要的麻烦，更能帮助我们从更全面的角度审视投资回报，并在合规的前提下，通过合理的规划来提升最终的财富积累。再次强调，<strong>当涉及到具体的税务问题时，寻求专业税务顾问的帮助永远是明智之举。</strong></p><hr /><h3 id="总结实践准备与持续学习">总结：实践准备与持续学习</h3><p>在本章中，我们从理论学习过渡到为实际投资操作做准备，并强调了持续学习对于投资者成长的重要性。</p><p>我们首先详细探讨了<strong>交易平台</strong>的选择与使用。我们了解了在中国大陆投资A股以及通过不同渠道投资港股、美股的开户流程，强调了选择合规、低佣、体验良好的券商的重要性。我们还梳理了主要的交易成本，如佣金、印花税、过户费等，并学习了交易软件的基本功能和操作方法，为实际下单交易打下了基础。</p><p>接着，我们深入学习了<strong>交易基础</strong>，重点理解了不同的订单类型。我们详细辨析了市价单（追求速度和成交保证）和限价单（追求价格控制）的原理、优缺点及适用场景，并提及了止损单等其他订单类型。理解订单簿与市场深度的概念，以及订单的有效期，有助于我们更有效地执行交易意图。</p><p>然后，我们强调了<strong>投资纪律</strong>的极端重要性。我们认识到投资纪律是抵御人性弱点、避免情绪化决策的行为框架。我们探讨了如何制定清晰的投资目标与计划，如何设立买入和卖出原则，如何理性应对亏损，以及如何通过多种方法（如制定计划、设定冷静期、减少盯盘、建立投资日志与定期复盘等）来避免情绪化交易，从而做到知行合一。</p><p>随后，我们关注了<strong>信息渠道</strong>的构建与筛选。在信息爆炸的时代，我们学习了如何区分一手信息（如上市公司财报、官方公告）和二手信息（如财经媒体报道、券商研报），并强调了要警惕社交媒体上的“小道消息”、所谓的“荐股大师”以及过度简化的“投资秘籍”。我们探讨了追溯信息来源、交叉验证、评估发布者可信度、区分事实与观点、培养批判性思维等筛选高质量信息的方法，旨在帮助读者在纷繁的信息中找到“真金”。</p><p>最后，我们简要介绍了<strong>税务知识</strong>在投资中的重要性。我们了解了股息税、资本利得税、利息税等常见的投资相关税种，并强调了其因国家/地区而异的特性，以及双边税收协定的作用。我们探讨了应对投资税务的基本思路，如了解税法、选择合适的投资账户、合理利用抵扣和免税额度、寻求专业建议等，旨在帮助读者在合规的前提下优化税后回报。</p><p>贯穿本章，我们的核心目标是帮助读者<strong>完善个人投资体系，为小额实盘操作做准备，并建立持续学习的习惯。</strong>每一个小节都旨在弥合理论与实践之间的鸿沟。</p><p><strong>给读者的行动建议</strong>：本章的学习为你的实盘操作铺平了道路。在真正投入较大资金之前，请务必：</p><ol type="1"><li><strong>选择并熟悉一个交易平台</strong>：完成开户流程，彻底搞懂交易软件的各项功能。</li><li><strong>进行充分的模拟交易或极小额实盘测试</strong>：<ul><li>练习使用不同的订单类型。</li><li>尝试制定并严格执行你的买入、卖出纪律。</li><li>记录下你的每一次模拟操作的理由和结果，进行复盘。</li></ul></li><li><strong>开始有意识地筛选你的信息来源</strong>：尝试阅读一份完整的上市公司年报，关注几家权威的财经媒体，对网络上的信息保持警惕和辨别能力。</li><li><strong>初步了解与你投资相关的税务规定</strong>：如果你计划进行海外投资，尤其需要关注跨境税务问题。</li><li><strong>最重要的是，将投资视为一个持续学习和自我完善的过程。</strong>市场在变，知识在更新，你的认知也需要不断迭代。保持好奇心，多读书，多思考，多总结，这是在投资之路上行稳致远的不二法门。</li></ol><h2 id="第五章开始吧">第五章：开始吧</h2><p>恭喜你，坚持学习到这里！从投资的基础知识到公司分析，从策略深化到实践准备，我们共同走过了一段不短的旅程。现在，理论的灯塔已经为你点亮，实践的航船也已备好，是时候扬帆起航，真正踏上属于你自己的投资之路了。但在此之前，请允许我再次叮嘱几句，这些或许比任何具体的投资技巧都更为重要。</p><h4id="一投资是一个长期的过程不要追求速成">一、投资是一个长期的过程，不要追求速成</h4><p><strong>是什么(What)：投资的本质——时间的玫瑰，而非一夜暴富的彩票</strong></p><p><strong>投资，尤其是成功的投资，本质上是一个需要时间积累和耐心耕耘的长期过程。</strong>它不是一场可以速战速决的百米冲刺，而是一场考验耐力、智慧和纪律的马拉松。财富的增长，特别是通过复利效应实现的指数级增长，需要足够长的时间才能显现其威力。</p><ul><li><strong>现实的残酷与诱惑</strong>：市场上充斥着太多“快速致富”、“短期暴涨”的故事和诱惑。这些故事往往只展现了幸存者的光鲜，却掩盖了无数失败者的黯淡。追求速成，很容易让你陷入高风险的投机陷阱，或者因为短期挫折而灰心丧气，过早放弃。</li><li><strong>投资大师的启示</strong>：回顾那些伟大的投资者，如巴菲特、芒格、格雷厄姆、彼得·林奇，他们无一不是通过数十年的长期坚持和持续学习，才取得了辉煌的成就。巴菲特的大部分财富是在他50岁之后积累起来的，这正是复利在长时间尺度下展现出的惊人力量。</li></ul><p><strong>怎么做 (How)：培养长期视角与耐心</strong></p><ol type="1"><li><strong>设定合理的长期目标</strong>：不要期望通过几次交易就能实现财务自由。将你的投资目标设定在5年、10年甚至更长的时间维度上。</li><li><strong>理解并相信复利的力量</strong>：如第一章所述，复利是“世界第八大奇迹”。但它需要时间来发挥作用。每一次短期的波动，在长期的复利曲线面前，都可能只是一个小小的涟漪。</li><li><strong>忽略短期噪音，关注长期趋势</strong>：市场的短期波动是常态，受到各种复杂因素的影响，难以预测。不要被每日的涨跌所干扰，专注于你投资标的的基本面和长期价值。</li><li><strong>“坐等”的智慧</strong>：查理·芒格曾说，赚大钱的诀窍不在于买进卖出，而在于“坐等”(sitting)。当你以合理的价格买入了优质的资产，并且其基本面没有发生根本性恶化，那么耐心持有，让时间和企业成长为你创造价值。</li><li><strong>将投资视为一种生活方式</strong>：它不是一锤子买卖，而是需要你持续关注、学习和调整的长期事业。</li></ol><p><strong>为什么 (Why)：长期主义是投资成功的基石</strong></p><ul><li><strong>平滑短期波动</strong>：长期投资可以帮助你穿越市场的牛熊周期，降低短期波动对你情绪和决策的干扰。</li><li><strong>享受企业成长红利</strong>：对于股票投资而言，长期持有优质公司的股票，意味着你能够分享到这些公司在长期发展过程中创造的价值。</li><li><strong>降低交易成本和税负</strong>：频繁交易会产生不必要的佣金和税费，侵蚀你的回报。长期持有则可以有效降低这些成本。</li><li><strong>时间是优秀企业的朋友</strong>：真正优秀的企业，其竞争优势和盈利能力会随着时间的推移而愈发显现。</li></ul><h4 id="二学会独立思考警惕羊群效应">二、学会独立思考，警惕羊群效应</h4><p><strong>是什么 (What)：独立思考——在众声喧哗中保持清醒</strong></p><p><strong>独立思考是指不盲从他人的观点或市场的主流情绪，基于自己的知识、分析和判断，形成对投资标的和市场形势的独立看法，并据此做出投资决策。</strong>在投资领域，独立思考的能力尤为珍贵。</p><ul><li><strong>羊群效应的普遍性</strong>：人类作为社会性动物，天生有从众的倾向。在投资市场中，这种羊群效应表现为追涨杀跌、盲目跟风热门概念、轻信“专家”意见等。当周围的人都在谈论某只股票或某个投资机会时，保持独立判断非常困难。</li><li><strong>《乌合之众》的启示</strong>：古斯塔夫·勒庞在其经典著作《乌合之众》中深刻揭示了群体心理的非理性特征。在群体中，个体的独立思考能力容易被削弱，情绪更容易被传染和放大。</li></ul><p><strong>怎么做 (How)：培养独立思考的能力</strong></p><ol type="1"><li><strong>建立自己的知识体系和分析框架</strong>：本书为你提供的正是这样一个基础框架。通过持续学习，不断完善它。</li><li><strong>对信息进行批判性评估</strong>：如第四章第四节所述，学会辨别信息的真伪和质量，不轻信来源不明或缺乏依据的“消息”。</li><li><strong>敢于提出质疑，挑战主流观点</strong>：当市场一片看好或一片看空时，不妨反向思考一下：这种共识的基础是什么？是否存在被忽视的风险或机会？</li><li><strong>专注内在价值，而非市场价格</strong>：价值投资者之所以能够逆向操作，正是因为他们心中有对“内在价值”的锚，而不是被短期价格波动所迷惑。</li><li><strong>为自己的决策负责</strong>：不要把投资决策的责任推给别人。只有当你为自己的决策承担全部责任时，你才会真正努力去独立思考。</li><li><strong>保持阅读和学习的习惯</strong>：广泛阅读不同领域（经济、历史、心理学、商业等）的书籍，有助于拓展你的视野，提升你的认知深度，从而做出更周全的判断。</li></ol><p><strong>为什么 (Why)：独立思考是获取超额收益的前提</strong></p><ul><li><strong>发现市场错误定价的机会</strong>：市场的非理性波动和羊群效应，往往会造成优质资产被低估或劣质资产被高估。独立思考者才有机会发现并利用这些错误定价。</li><li><strong>避免成为“韭菜”</strong>：盲目跟风的投资者，最容易在市场的高点接盘，在市场的低点割肉，成为被收割的对象。</li><li><strong>形成自己的投资风格</strong>：只有通过独立思考和实践，你才能逐渐形成真正适合自己性格、知识和风险偏好的投资风格。</li><li><strong>获得内心的平静</strong>：当你基于自己的深入分析做出决策时，即使市场短期表现不佳，你也能更从容地面对，因为你知道自己为什么持有。</li></ul><h4 id="三时刻保有风险意识">三、时刻保有风险意识</h4><p><strong>是什么(What)：风险意识——投资旅程中的“安全带”与“刹车”</strong></p><p><strong>风险意识是指在进行任何投资决策之前和之后，始终对可能发生的各种不利情况及其潜在影响保持清醒的认知和警惕。</strong>它不是让你因噎废食、不敢投资，而是让你在追求回报的同时，始终将风险控制放在重要的位置。</p><ul><li><strong>“天下没有免费的午餐”</strong>：高收益往往伴随着高风险。任何看似“好得令人难以置信”的投资机会，背后都可能隐藏着巨大的风险。</li><li><strong>风险的多样性与隐蔽性</strong>：如第三章第五节所述，投资面临市场风险、信用风险、流动性风险、通胀风险，甚至还有你自己认知偏差带来的风险。有些风险是显而易见的，有些则是隐蔽的，甚至是你从未想过的“黑天鹅”事件。</li></ul><p><strong>怎么做 (How)：将风险意识融入投资的每一个环节</strong></p><ol type="1"><li><strong>理解你所投资的每一项资产的风险特征</strong>：不懂不做，不熟不投。</li><li><strong>坚持安全边际原则</strong>：为未知的风险和可能的错误预留缓冲。</li><li><strong>进行充分的分散投资和合理的资产配置</strong>：不要把所有鸡蛋放在一个篮子里。</li><li><strong>量力而行，不用“压力资金”投资</strong>：不要用生活必需的钱、短期内需要用到的钱，或者借来的钱进行高风险投资。投资应该是用“闲钱”。</li><li><strong>控制仓位，避免过度集中</strong>：即使你对某项投资非常有信心，也要避免在单一标的上投入过高的仓位，以防“黑天鹅”事件导致毁灭性打击。</li><li><strong>定期审视投资组合的风险暴露</strong>：随着市场环境和自身情况的变化，你的投资组合所面临的风险也在变化，需要定期评估和调整。</li><li><strong>对杠杆保持极度审慎</strong>：杠杆可以放大收益，但更会急剧放大风险。对于普通投资者而言，应尽量避免使用杠杆进行投资。</li><li><strong>学习从失败中汲取教训</strong>：每一次投资亏损，都是对你风险认知和管理能力的一次检验和提升。</li></ol><p><strong>为什么 (Why)：风险意识是投资能否持续的关键</strong></p><ul><li><strong>保护本金</strong>：“在投资的战场上，活下来是第一位的。”只有保住了本金，才有机会在未来获取回报。</li><li><strong>避免灾难性损失</strong>：一次无法承受的巨大亏损，可能会让你彻底失去继续投资的信心和能力。</li><li><strong>提升决策质量</strong>：充分考虑风险，能让你做出更审慎、更全面的投资决策。</li><li><strong>保持心态平和</strong>：当你知道自己已经为可能的风险做好了准备时，面对市场的波动会更加从容。</li></ul><h4 id="四从简单的开始循序渐进">四、从简单的开始，循序渐进</h4><p><strong>是什么(What)：投资学习的路径——先学会走，再尝试跑</strong></p><p>投资是一个复杂的系统工程，没有人能一口吃成胖子。<strong>对于初学者而言，最好的方式是从最简单、最容易理解、风险相对可控的投资方式开始，逐步积累经验和知识，然后再去尝试更复杂的策略和工具。</strong></p><ul><li><strong>避免眼高手低</strong>：不要一开始就试图模仿投资大师进行复杂的个股分析和操作，或者去追逐那些看似高深莫测的衍生品交易。</li><li><strong>“不懂不做”的再强调</strong>：这是贯穿全书的核心原则。在实践的初期，更要严格遵守。</li></ul><p><strong>怎么做 (How)：初学者的实践路径建议</strong></p><ol type="1"><li><strong>从指数基金定投开始</strong>：这是被广泛证明适合大多数普通投资者的入门方式。<ul><li><strong>选择宽基指数</strong>：如沪深300、标普500等，它们代表了市场的主流表现，风险相对分散。</li><li><strong>坚持长期定投</strong>：通过定期定额投资，平滑成本，积少成多，体验复利。</li><li><strong>在这个过程中，你可以学习观察市场，理解指数的构成，感受不同市场环境下的波动，而不需要承担过大的个股选择风险。</strong></li></ul></li><li><strong>小额尝试你感兴趣且能理解的个股</strong>：<ul><li>在你对公司分析有了一定基础后，可以选择1-2家你日常生活中熟悉其产品或服务、并且其商业模式相对容易理解的公司，用小额资金进行尝试。</li><li><strong>重点是实践分析方法，验证你的判断，而不是追求短期盈利。</strong></li></ul></li><li><strong>逐步扩大能力圈</strong>：随着知识和经验的积累，你可以逐渐尝试去理解和分析更广泛的行业和公司。</li><li><strong>不要急于追求复杂的投资工具</strong>：期权、期货、杠杆ETF等衍生品，虽然可能带来高回报，但其风险和复杂性也远超普通股票和基金。在没有充分理解其机制和风险之前，切勿轻易尝试。</li></ol><p><strong>为什么 (Why)：循序渐进有助于建立信心和控制风险</strong></p><ul><li><strong>降低学习成本</strong>：从简单的开始，可以让你在风险较低的环境中学习和犯错，避免一开始就遭受重大损失。</li><li><strong>逐步建立信心</strong>：通过在简单投资中获得正向反馈，可以增强你对投资的信心和兴趣。</li><li><strong>巩固基础知识</strong>：实践是检验和巩固理论知识的最佳方式。</li><li><strong>培养良好的投资习惯</strong>：从一开始就养成良好的投资习惯（如记录、反思、控制风险），对长期的投资生涯至关重要。</li></ul><h4id="五保持记录并反思持续学习与进化">五、保持记录并反思，持续学习与进化</h4><p><strong>是什么(What)：投资成长之路——没有终点，只有不断迭代</strong></p><p><strong>投资是一个永无止境的学习过程。市场在变，经济在变，优秀的公司在变，你自己的认知和风险偏好也在变。因此，保持记录、定期反思、持续学习，并根据新的认知和经验不断优化自己的投资体系，是每一个成功投资者必备的素质。</strong></p><ul><li><strong>避免“刻舟求剑”</strong>：过去的成功经验不一定能完全复制到未来。需要根据变化的环境调整策略。</li><li><strong>承认自己的无知</strong>：学得越多，越会发现自己不懂的也越多。保持谦逊和好奇心，是持续学习的动力。</li></ul><p><strong>怎么做 (How)：构建你的学习与反馈闭环</strong></p><ol type="1"><li><strong>建立详细的投资日志</strong>：记录你的每一次买卖决策、背后的理由、当时的思考、预期的目标、以及最终的结果。</li><li><strong>定期进行投资复盘</strong>：<ul><li>回顾你的成功与失败案例，分析原因，总结经验教训。</li><li>评估你的投资纪律执行情况。</li><li>检查你的投资组合是否依然符合你的目标和风险偏好。</li></ul></li><li><strong>广泛阅读，跨界学习</strong>：<ul><li><strong>经典投资著作</strong>：反复阅读，常读常新。</li><li><strong>商业传记与案例</strong>：了解成功企业和企业家的故事与思考方式。</li><li><strong>经济学、心理学、历史学、社会学等相关学科</strong>：这些能为你理解市场和人性提供更广阔的视角。</li></ul></li><li><strong>关注市场动态与行业发展</strong>：但要有选择性，避免被短期噪音淹没。</li><li><strong>与优秀的投资者交流（但保持独立判断）</strong>：学习他人的经验和思考方式，但不要盲目复制。</li><li><strong>拥抱变化，勇于迭代</strong>：不要固守僵化的教条。当事实证明你过去的某些认知是错误或不完善的时，要勇于承认并修正。你的投资体系应该是一个开放的、能够不断进化的系统。</li></ol><p><strong>为什么 (Why)：持续学习是应对不确定性的最佳武器</strong></p><ul><li><strong>提升认知水平</strong>：让你能更深刻地理解市场规律和投资机会。</li><li><strong>适应变化的环境</strong>：帮助你跟上时代的发展，抓住新的机遇，规避新的风险。</li><li><strong>避免重复犯错</strong>：通过反思，将过去的错误转化为未来的智慧。</li><li><strong>实现个人成长</strong>：投资不仅仅是关于金钱，它也是一个认识世界、认识自己、实现个人成长的过程。</li></ul><p><strong>最后的寄语：</strong></p><p>亲爱的读者，这本书即将画上句号，但你的投资之旅才刚刚开始。记住，投资是一场充满挑战也充满机遇的修行。它需要智慧，更需要品格；需要知识，更需要纪律；需要勇气，更需要耐心。</p><p><strong>永远保持谦逊，永远保持好奇，永远在学习的路上。</strong></p><p>不要害怕犯错，因为错误是最好的老师。不要追求完美，因为完美只存在于理论中。不要放弃思考，因为思考是你最有力的武器。</p><p><strong>从今天开始，用你学到的知识，以一个企业所有者的心态，去审视你身边的商业世界；以一个理性决策者的姿态，去规划你的财务未来；以一个终身学习者的姿态，去拥抱这个充满变化的世界。</strong></p><p>愿你在这条道路上，不仅能收获财富的增长，更能收获智慧的提升和内心的丰盈。</p><p><strong>开始吧！祝你投资顺利，人生增值！</strong></p><h2 id="附录-估值方法及其应用">附录 估值方法及其应用</h2><p><ahref="https://github.com/zqten/Investment-Toolbox">投资工具箱</a>点击这个链接可以去到网站下载，也可以直接点击下面的download直接下载。</p><p>我上传到github上的文件有估值工具，在页面中点击<strong>“绿色code”</strong>菜单里面的<strong><ahref="https://github.com/zqten/Investment-Toolbox/archive/refs/heads/main.zip">downloadzip</a></strong>就可以下载，里面有使用说明文件。</p>]]></content>
    
    
    <categories>
      
      <category>投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统哈思维导论读书参考</title>
    <link href="/2025/05/16/2025-05-16-%E7%B3%BB%E7%BB%9F%E5%8C%96%E6%80%9D%E7%BB%B4%E5%AF%BC%E8%AE%BA%E7%9C%8B%E4%B9%A6%E5%8F%82%E8%80%83/"/>
    <url>/2025/05/16/2025-05-16-%E7%B3%BB%E7%BB%9F%E5%8C%96%E6%80%9D%E7%BB%B4%E5%AF%BC%E8%AE%BA%E7%9C%8B%E4%B9%A6%E5%8F%82%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h1id="系统化思维导论辅助阅读指南-杰拉尔德温伯格">《系统化思维导论》辅助阅读指南(杰拉尔德·温伯格)</h1><p>这本书不是一本教你具体技能的“操作手册”，更像是一本提升你“内功心法”的秘籍。它教你一种观察和理解世间万物（尤其是复杂事物）的通用思维框架。</p><h2 id="引言这本书是关于什么的">引言：这本书是关于什么的？</h2><p>简单说，温伯格告诉你：</p><ul><li>我们身边的一切，从你的家庭、公司团队，到一台电脑、一个生态系统，甚至是你自己，都可以看作是一个“<strong>系统</strong>”。</li><li>这本书的目的，是让你学会用“<strong>系统</strong>”的眼光去看待和思考这些事物，从而更深刻地理解它们，更有效地解决与之相关的问题。</li><li><strong>你看待系统的方式，本身就会影响你对系统的理解。</strong></li></ul><h2 id="核心概念解析带例子">核心概念解析（带例子！）</h2><p>以下是书中一些核心概念的通俗解释和例子：</p><h3 id="系统-system">1. 系统 (System)</h3><ul><li><strong>是什么</strong>：一堆相互关联、相互作用的元素，它们共同合作（或者不合作），以实现某种功能或目标。</li><li><strong>特点</strong>：系统不是零件的简单相加。</li><li><strong>例子</strong>：<ul><li><strong>自行车</strong>：车架、轮子、链条、脚踏板等零件相互连接，共同实现“骑行”的功能。</li><li><strong>你的家庭</strong>：家庭成员之间有各种关系和互动，共同构成一个情感、经济、生活的单元。</li><li><strong>一个软件项目团队</strong>：程序员、测试员、产品经理等角色，通过沟通协作，共同开发软件。</li></ul></li></ul><h3 id="观察者-observer-边界-boundary中文理解就是换个角度看问题">2.观察者 (Observer) &amp; 边界 (Boundary)：中文理解就是换个角度看问题</h3><ul><li><strong>观察者</strong>：就是“你”——那个正在看待和定义系统的人。你的视角、经验、关注点，都会影响你如何理解系统。</li><li><strong>边界</strong>：是你（观察者）在头脑中为系统划定的一条线，用来区分什么是系统“内部”的，什么是系统“外部”的。</li><li><strong>关键点</strong>：<strong>边界不是天然存在的，而是观察者定义的。</strong>不同的观察者，或者同一个观察者在不同情境下，可能会划定不同的边界。</li><li><strong>例子</strong>：<ul><li><strong>问题：交通堵塞</strong><ul><li><strong>司机小王（观察者）</strong>：他可能把“他的车和前面的几辆车”看作一个系统（<strong>边界很小</strong>）。他会觉得“前面的车开太慢了！”</li><li><strong>交通规划师（观察者）</strong>：他可能把“整条路段，包括红绿灯、路口设计”看作系统（<strong>边界较大</strong>）。他可能会思考“是不是信号灯配时不合理？”</li><li><strong>市长（观察者）</strong>：他可能把“整个城市的交通网络，包括公共交通、道路规划、市民出行习惯”都看作系统（<strong>边界更大</strong>）。他可能会考虑“是不是公共交通投入不足，导致私家车过多而拥挤？”</li></ul></li><li>你看，对于同一个“交通堵塞”现象，不同的观察者因为划定的边界不同，看到的“系统”和可能的原因也完全不同。</li></ul></li></ul><h3 id="关系连接-relationshipinterconnection">3. 关系/连接(Relationship/Interconnection)</h3><ul><li><strong>是什么</strong>：系统内部各元素之间的相互影响和联系。</li><li><strong>关键点</strong>：<strong>关系往往比元素本身更重要。</strong>系统的很多特性是由这些关系决定的。</li><li><strong>例子</strong>：<ul><li><strong>电脑故障</strong>：有时电脑坏了，不是CPU或内存条本身坏了，而是它们之间的插槽接触不良（连接出了问题）。</li><li><strong>团队效率低下</strong>：可能不是某个员工能力不行，而是团队成员之间沟通不畅、缺乏信任（关系出了问题）。</li></ul></li></ul><h3 id="整体性-wholenessholism-涌现-emergence">4. 整体性(Wholeness/Holism) &amp; 涌现 (Emergence)</h3><ul><li><strong>整体性</strong>：系统作为一个整体，其特性大于（或不同于）各部分特性之和。即“1+1&gt; 2” 或 “1+1 ≠ 2”。</li><li><strong>涌现</strong>：系统整体层面出现的一些新的、无法从单个组成部分简单预测出来的特性或行为。这些是元素间相互作用“冒出来”的。</li><li><strong>例子</strong>：<ul><li><strong>水(H₂O)</strong>：氢气（可燃）和氧气（助燃）都是气体，但它们以特定方式结合（关系）后，变成了液态的水（整体），具有了灭火（涌现特性）的功能，这和氢气、氧气各自的特性完全不同。</li><li><strong>球队的“化学反应”</strong>：一群优秀的球员组合在一起，如果配合默契（关系良好），可能会产生超强的战斗力（涌现）；如果各自为战，可能还不如一支普通球队。</li><li><strong>意识</strong>：大脑由无数神经元组成，但“意识”这个东西是如何从神经元的电化学活动中“涌现”出来的，至今仍是科学之谜。</li></ul></li></ul><h3 id="反馈-feedback">5. 反馈 (Feedback)</h3><ul><li><strong>是什么</strong>：系统输出的一部分信息，反过来又作为输入，影响系统后续的行为。</li><li><strong>类型</strong>：<ul><li><strong>负反馈 (NegativeFeedback)</strong>：试图使系统恢复稳定，纠正偏差。像“踩刹车”。<ul><li><strong>例子</strong>：空调控温。室温高于设定值，空调制冷；低于设定值，空调停止或制热，使温度保持在设定范围。人体体温调节也是如此。</li></ul></li><li><strong>正反馈 (PositiveFeedback)</strong>：使系统偏离初始状态，放大变化。像“踩油门”。<ul><li><strong>例子</strong>：话筒靠近音箱产生的啸叫声。声音被放大，再被话筒拾取，再放大，越来越响。或者，一个产品口碑好，用的人多了，口碑更好，吸引更多人（病毒式传播）。</li></ul></li></ul></li><li><strong>关键点</strong>：理解反馈回路，有助于我们预测系统行为，并找到干预点。</li></ul><h3 id="复杂性-complexity">6. 复杂性 (Complexity)</h3><ul><li><strong>是什么</strong>：系统因为其组成部分众多、关系多样且动态变化，导致其行为难以完全理解和预测。</li><li><strong>关键点</strong>：不要试图完全消除复杂性，而是学会与复杂性共处，理解其模式。</li><li><strong>例子</strong>：<ul><li><strong>天气预报</strong>：大气系统极其复杂，所以天气预报很难做到100%准确。</li><li><strong>股票市场</strong>：受无数因素影响，其走势难以预测。</li></ul></li></ul><h3 id="模型-model-简化-simplification">7. 模型 (Model) &amp; 简化(Simplification)</h3><ul><li><strong>模型</strong>：为了理解复杂的现实系统，我们构建的对现实系统的简化表示。</li><li><strong>简化</strong>：在构建模型时，我们会忽略一些细节，抓住主要矛盾。</li><li><strong>关键点</strong>：<ul><li><strong>“地图不是实际的领土” (The map is not theterritory)</strong>：模型只是现实的近似，永远不等于现实本身。</li><li>所有模型都是错的，但有些是有用的。关键在于选择合适的简化程度和关注点。</li></ul></li><li><strong>例子</strong>：<ul><li><strong>城市地图</strong>：它简化了真实的城市，省略了很多细节（比如每栋楼的样子），但它能帮助我们导航。</li><li><strong>公司组织架构图</strong>：它显示了部门和汇报关系，但忽略了非正式的沟通网络和人际关系。</li></ul></li></ul><h2 id="温伯格的思考三问实践工具">温伯格的“思考三问”：实践工具</h2><p>当你面对一个情境或问题时，可以尝试用这三个问题来启动系统化思考：</p><ol type="1"><li><strong>它是什么？ (What is it?)</strong><ul><li>尝试定义你正在观察的系统。</li><li>它的组成部分有哪些？</li><li>你为这个系统划定的边界在哪里？哪些是系统内的，哪些是系统外的？</li></ul></li><li><strong>它如何运作？ (How does it behave?)</strong><ul><li>这些组成部分之间是如何相互连接和影响的？</li><li>系统中存在哪些重要的反馈回路（正反馈？负反馈？）</li><li>这个系统整体上表现出什么样的行为或特性（涌现特性）？</li></ul></li><li><strong>我如何影响它？ (How do I influence it?)</strong><ul><li>如果我想改变这个系统，可以从哪些点入手？</li><li>我的干预可能会触发哪些连锁反应（直接的、间接的、预期的、意外的）？</li></ul></li></ol><p><strong>举个例子：孩子不爱学习</strong></p><ol type="1"><li><strong>它是什么？</strong>系统可能包括：孩子、家庭作业、学校、老师、家长、学习环境、娱乐活动等。边界：是只关注孩子本身，还是把家庭、学校环境都纳入？</li><li><strong>它如何运作？</strong> 可能是：作业多 -&gt; 压力大 -&gt;逃避学习 -&gt; 成绩下降 -&gt; 家长批评 -&gt; 压力更大 -&gt;更不爱学习（一个恶性循环的负反馈，或者说是一个不断强化的正反馈，导致情况越来越糟）。也可能有其他因素，如学习方法不对、缺乏兴趣、社交问题等。</li><li><strong>我如何影响它？</strong>直接批评可能加剧问题。或许可以：改变沟通方式、帮助找到合适的学习方法、减轻不必要的学业压力、创造积极的学习氛围、发现孩子的兴趣点等。每种干预都可能有不同的后续影响。</li></ol><h2 id="阅读建议">阅读建议</h2><ol type="1"><li><strong>慢慢读，多思考</strong>：这本书不是快餐读物。每读一个概念，停下来想想你生活中的例子。</li><li><strong>联系实际</strong>：尝试用书中的概念去分析你工作、学习、生活中遇到的问题。</li><li><strong>不要怕一开始看不懂</strong>：温伯格的语言富有哲理，有些地方可能需要反复琢磨。可以先囫囵吞枣，再回头细品。</li><li><strong>做笔记，画图表</strong>：把你的理解和思考记录下来，尝试画出你所分析系统的结构图、关系图、反馈回路图。</li></ol><h2 id="总结这本书能带给你什么">总结：这本书能带给你什么？</h2><ul><li><strong>更深刻的洞察力</strong>：帮助你看到问题的本质，而不是表面现象。</li><li><strong>更全面的决策能力</strong>：在做决策时，能考虑到更多的关联因素和潜在影响，避免“头痛医头，脚痛医脚”。</li><li><strong>应对复杂性的智慧</strong>：让你在面对复杂情况时，不至于手足无措，而是能找到分析和介入的思路。</li><li><strong>一种通用的思维框架</strong>：适用于几乎所有领域。</li></ul>]]></content>
    
    
    <categories>
      
      <category>哲学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>费马-帕斯卡的排列组合原理</title>
    <link href="/2025/05/16/2025-05-16-%E8%B4%B9%E9%A9%AC%E5%B8%95%E6%96%AF%E5%8D%A1%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    <url>/2025/05/16/2025-05-16-%E8%B4%B9%E9%A9%AC%E5%B8%95%E6%96%AF%E5%8D%A1%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p><strong>费马-帕斯卡的排列组合原理</strong></p><p>在17世纪，法国数学家布莱兹·帕斯卡（BlaisePascal）和皮埃尔·德·费马（Pierre deFermat）在通信中探讨了赌博中的概率问题，这些讨论奠定了概率论和组合数学的基础。</p><p>核心原理可以概括为以下两点：</p><ol type="1"><li><strong>排列 (Permutation, P)：</strong><ul><li><strong>定义：</strong> 从 n 个不同元素中，取出 k个元素，<strong>并按照一定的顺序排列起来</strong>，称为排列。强调的是<strong>顺序</strong>。</li><li><strong>通俗理解：</strong>“排队”。同样的人，排队顺序不同，就是不同的排列。</li><li><strong>公式：</strong> P(n, k) = n! / (n-k)!<ul><li>其中 "!" 代表阶乘，例如 5! = 5 × 4 × 3 × 2 × 1。</li><li>如果所有元素都参与排列 (k=n)，则 P(n, n) = n!</li></ul></li></ul></li><li><strong>组合 (Combination, C)：</strong><ul><li><strong>定义：</strong> 从 n 个不同元素中，取出 k个元素，<strong>不考虑它们的排列顺序</strong>，称为组合。强调的是<strong>选择</strong>，不在乎选出来的东西怎么排。</li><li><strong>通俗理解：</strong>“分组”或“选人”。从一群人里选几个人出来，只要人选定了，不管谁先被叫到名字，都是同一个组合。</li><li><strong>公式：</strong> C(n, k) = n! / (k! * (n-k)!)<ul><li>也常写作 (n k) 或 "n choose k"。</li></ul></li></ul></li></ol><p><strong>关键区别：</strong> 排列讲顺序，组合不讲顺序。</p><p><strong>通俗易懂的实际案例：</strong></p><p><strong>排列的案例：</strong></p><ol type="1"><li><strong>密码锁：</strong>你有一个4位数的密码锁，每位数字可以是0-9。如果你设置密码为 "1234"，那么"4321" 就是一个不同的密码，因为顺序变了。<ul><li>这里是从10个数字中选4个进行排列（允许重复，属于重复排列，更复杂些，但基本思想是顺序重要）。如果是不允许重复的数字密码，比如从10个数字选4个不重复的组成密码，就是P(10, 4) = 10! / (10-4)! = 10 × 9 × 8 × 7 = 5040 种。</li></ul></li><li><strong>比赛名次：</strong> 5个人参加跑步比赛，决出冠、亚、季军。<ul><li>甲第一、乙第二、丙第三，与 乙第一、甲第二、丙第三是不同的结果。</li><li>这是从5个人中选3个人进行排列：P(5, 3) = 5! / (5-3)! = 5 × 4 × 3 = 60种不同的名次结果。</li></ul></li><li><strong>书架摆书：</strong> 你有3本不同的书（A, B,C），要把它们都放到书架上。<ul><li>ABC, ACB, BAC, BCA, CAB, CBA 都是不同的摆法。</li><li>这是 P(3, 3) = 3! = 3 × 2 × 1 = 6 种摆法。</li></ul></li></ol><p><strong>组合的案例：</strong></p><ol type="1"><li><strong>选课代表：</strong>班上有30个学生，要选出3名课代表（不分职务高低）。<ul><li>选出小明、小红、小刚，和小刚、小明、小红是同一组课代表，顺序不重要。</li><li>这是从30个人中选3个人：C(30, 3) = 30! / (3! * (30-3)!) = (30 × 29 ×28) / (3 × 2 × 1) = 4060 种选法。</li></ul></li><li><strong>买彩票（双色球红球区）：</strong> 从33个红球号码中选择6个。<ul><li>你选了01, 02, 03, 04, 05, 06，和你朋友选了06, 05, 04, 03, 02,01，只要开奖号码是这六个，你们都中奖，顺序无所谓。</li><li>这是从33个号码中选6个：C(33, 6) = 33! / (6! * (33-6)!) = 1,107,568种组合。</li></ul></li><li><strong>点菜：</strong> 菜单上有10道菜，你想点其中3道。<ul><li>点了“宫保鸡丁、鱼香肉丝、麻婆豆腐” 和 “麻婆豆腐、宫保鸡丁、鱼香肉丝”是一样的组合。</li><li>这是从10道菜中选3道：C(10, 3) = 10! / (3! * (10-3)!) = (10 × 9 × 8)/ (3 × 2 × 1) = 120 种点菜方案。</li></ul></li></ol><p><strong>将排列组合应用到投资股票上</strong></p><p>直接用排列组合公式来预测某只股票明天是涨是跌，或者预测具体价格，是<strong>不现实的，也是错误的</strong>。股票市场是一个极其复杂的系统，受到宏观经济、公司基本面、市场情绪、新闻事件、政策法规等无数因素的影响，这些因素很多是不可量化或难以预测的。</p><p>但是，排列组合的<strong>思想</strong>和<strong>概率论的基础</strong>可以间接地应用于投资股票的某些方面，主要是帮助你<strong>思考可能性、构建策略框架和管理风险</strong>：</p><ol type="1"><li><strong>构建投资组合（Portfolio Construction - 组合思想）：</strong><ul><li><strong>场景：</strong>你研究了20只潜力股票，但你的资金和风险承受能力只允许你投资其中的5只。</li><li><strong>应用：</strong> 你有多少种选择这5只股票的组合方式？C(20, 5)= 20! / (5! * 15!) = 15,504 种。</li><li><strong>意义：</strong>这提醒你选择范围非常广。但<strong>更重要的是</strong>，这只是第一步。后续你需要结合股票的相关性（避免过度集中在同一行业或同一类型风险）、预期收益、波动性等因素来优化你的选择，而不是随机选一个组合。排列组合帮你理解了选择的“数量级”。</li></ul></li><li><strong>期权策略（Options Strategies - 组合思想）：</strong><ul><li><strong>场景：</strong>期权交易中有很多组合策略，比如蝶式套利（需要3个不同执行价的期权）、跨式套利（同执行价的看涨和看跌期权）。</li><li><strong>应用：</strong>如果有多个可供选择的执行价格和到期日，你可以计算出可以构建多少种不同的特定策略（例如，从10个执行价中选3个来构建蝶式套利）。</li><li><strong>意义：</strong>帮助理解策略构建的复杂性和多样性，辅助筛选。</li></ul></li><li><strong>因子投资/量化策略参数选择（组合/排列思想）：</strong><ul><li><strong>场景：</strong>你在构建一个量化模型，可能会用到多个因子（如市盈率、市净率、增长率、动量等），每个因子可能有不同的参数设置（如取值范围、回看周期）。</li><li><strong>应用：</strong>如果你有5个备选因子，想选择3个；或者一个因子有多种参数设置，你想测试不同参数组合的效果。排列组合可以帮你计算有多少种可能的因子组合或参数组合需要测试。</li><li><strong>意义：</strong>在回测和优化策略时，理解测试空间的规模，帮助规划计算资源和时间。</li></ul></li><li><strong>风险管理与情景分析（基本计数原理，排列组合的延伸）：</strong><ul><li><strong>场景：</strong>你在评估一项投资可能面临的几种关键风险因素，每个因素有几种可能的状态（例如，利率：上升/不变/下降；行业政策：利好/不变/利空）。</li><li><strong>应用：</strong>如果有3个独立的风险因素，每个因素有3种状态，那么总共有 3 × 3 × 3 = 27种可能的情景组合。</li><li><strong>意义：</strong>这有助于你更全面地思考所有可能发生的情况，并为不同的情景制定应对预案，而不是只关注最乐观或最悲观的情况。</li></ul></li><li><strong>理解概率（概率论的基础）：</strong><ul><li>排列组合是计算概率的基础。虽然你不能直接用它算股票涨跌概率，但理解其原理有助于你更好地理解统计数据、历史回测结果的意义以及某些事件发生的“理论可能性”（尽管市场实际情况远比理论复杂）。</li><li>例如，如果你发现某种K线组合在历史上出现100次，其中70次后股价上涨，你会对这个模式的“胜率”有一个初步概念。排列组合是理解这种计数和概率的基础。</li></ul></li></ol><p><strong>重要警告和注意事项：</strong></p><ul><li><strong>市场不是赌场：</strong>股票市场不是一个封闭的、概率固定的系统（如掷骰子或抽牌）。历史数据可以提供参考，但未来是不确定的。</li><li><strong>不要过度简化：</strong>不要试图用简单的排列组合公式去“破解”市场。真正的投资决策需要深入的基本面分析、技术分析、宏观分析以及风险管理。</li><li><strong>P&amp;C是工具，不是答案：</strong>排列组合可以作为一种辅助思考工具，帮助你组织思路、评估选择范围或分析情景，但它本身不能告诉你应该买哪只股票。</li><li><strong>关注更重要的因素：</strong>对于股票投资，理解公司的商业模式、盈利能力、行业前景、管理团队、估值水平等因素远比计算有多少种选股组合重要得多。</li></ul><p>总而言之，排列组合是数学中一个强大的工具，用于计算“有多少种可能性”。在投资股票上，它不能直接预测市场，但其思想可以帮助投资者在构建组合、制定策略、管理风险时进行更系统和全面的思考。记住，它更多的是一种思维框架的辅助，而不是直接的决策工具。</p>]]></content>
    
    
    <categories>
      
      <category>投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融炼金术读书参考</title>
    <link href="/2025/05/16/2025-05-16-%E9%87%91%E8%9E%8D%E7%82%BC%E9%87%91%E6%9C%AF%E7%9C%8B%E4%B9%A6%E5%8F%82%E8%80%83/"/>
    <url>/2025/05/16/2025-05-16-%E9%87%91%E8%9E%8D%E7%82%BC%E9%87%91%E6%9C%AF%E7%9C%8B%E4%B9%A6%E5%8F%82%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p><strong>引言（可以理解为开篇点题）</strong></p><p>想象一下，传统的经济学理论告诉你，市场就像一面镜子，准确地反映着公司的价值、经济的状况（也就是“基本面”）。价格围绕着真实价值波动。但索罗斯说，不对！市场更像是一个演员，不仅反映现实，还会<strong>影响和改变</strong>现实。参与者的想法和行动会改变游戏规则本身，这就是“炼金术”——思想能改变现实。</p><hr /><p><strong>第一部分：理论 (The Theory)</strong></p><ul><li><strong>核心概念：反身性 (Reflexivity)</strong><ul><li><strong>通俗解释：</strong>这部分是全书的灵魂。索罗斯认为，我们对世界的看法（思考）和世界本身（现实）不是单向影响的（现实→思考），而是<strong>双向互动</strong>的。你的想法会影响你的行动，你的行动会改变现实，改变后的现实又会反过来影响你的想法，形成一个<strong>反馈循环</strong>。</li><li><strong>金融市场的例子：</strong><ol type="1"><li><strong>想法：</strong> 投资者普遍认为某只股票会涨。</li><li><strong>行动：</strong> 于是大家纷纷买入。</li><li><strong>现实改变：</strong> 大量买盘推动股价真的上涨了。</li><li><strong>想法改变/强化：</strong>上涨的股价似乎验证了最初的想法“这股果然会涨”，吸引更多人买入，或者让原来的投资者更坚定。</li><li><strong>循环继续：</strong>股价可能因此远远偏离了它最初的“真实价值”。这个过程可能一直持续，直到某个因素打破循环（比如涨得太离谱，或者基本面真的恶化），然后可能引发反向的下跌循环。</li></ol></li><li><strong>关键点：</strong><ul><li>市场参与者不是完全理性的旁观者，他们的<strong>偏见和预期</strong>本身就是市场的一部分，会影响价格。</li><li>价格不仅仅反映基本面，它还能<strong>反作用于基本面</strong>。比如，高股价能帮助公司更容易融资、进行收购，从而改善公司的基本面，这反过来又支撑了高股价。</li><li>这种反馈循环导致市场经常处于<strong>不均衡</strong>状态，而不是传统理论认为的趋向均衡。繁荣和萧条（Boomand Bust）就是反身性最典型的表现。</li></ul></li></ul></li></ul><hr /><p><strong>第二部分：历史的回顾 (Historical Retrospect)</strong></p><ul><li><strong>内容：用历史案例验证反身性理论</strong><ul><li><strong>通俗解释：</strong>索罗斯回顾了一些历史上的金融事件，用他的反身性理论来解释这些事件为什么会发生、如何演变。他想证明，反身性不是空想，而是实实在在影响历史进程的力量。</li><li><strong>典型案例：</strong><ul><li><strong>60年代的企业集团热潮 (Conglomerate Boom)：</strong>一些公司通过不断收购其他公司来壮大，市场给予它们很高的估值（想法）。高估值让它们能用自己的股票作为“货币”去收购更多公司（行动改变现实），收购成功又让市场觉得它们增长迅速，进一步推高估值（现实强化想法）。这个循环最终因为无法持续而破灭。</li><li><strong>80年代的国际债务危机：</strong>银行大量贷款给发展中国家（想法：这些国家能发展并偿还），贷款促进了这些国家的繁荣（行动改变现实），繁荣又让银行更愿意贷款（现实强化想法）。后来，当风险暴露，银行停止贷款（想法改变），导致这些国家陷入困境（现实改变），危机爆发。</li></ul></li></ul></li></ul><hr /><p><strong>第三部分：历史实验 (The Real-Time Experiment)</strong></p><ul><li><strong>内容：索罗斯的“实盘日志”</strong><ul><li><strong>通俗解释：</strong>这是本书最独特的部分。索罗斯记录了他在1985年9月到1986年11月期间，管理他的量子基金（QuantumFund）时的思考过程和交易决策。他试图在<strong>真实的市场波动中，运用并检验他的反身性理论</strong>。</li><li><strong>看点：</strong><ul><li><strong>实时应用：</strong>他会分析当时的宏观经济、市场情绪，判断是否存在反身性循环，并据此下注（做多或做空）。</li><li><strong>坦诚错误：</strong>他并没有把自己描绘成神，而是记录了自己的犹豫、误判和修正过程。这表明，即使理解了反身性，预测市场和赚钱依然非常困难，因为要时刻对抗自己的偏见和市场噪音。</li><li><strong>重要事件：</strong> 这段时间涵盖了广场协议（PlazaAccord）后美元大幅贬值等重要市场动荡，索罗斯详细记录了他如何分析和应对。</li></ul></li><li><strong>意义：</strong>这部分让理论变得非常具体，展示了一个顶级交易员如何在不确定性中挣扎、思考和决策。</li></ul></li></ul><hr /><p><strong>第四部分：评述 (Critique)</strong></p><ul><li><strong>内容：对理论和实验的反思</strong><ul><li><strong>通俗解释：</strong>索罗斯在这一部分对自己的理论和之前的“实验”进行了评价和反思。</li><li><strong>主要观点：</strong><ul><li><strong>理论的局限性：</strong>他承认反身性理论不像自然科学那样精确，很难量化和建立数学模型。它更多是一种思维框架，帮助理解市场动态，而不是预测未来的水晶球。</li><li><strong>实践的困难：</strong>他再次强调，在实际操作中应用反身性非常难。识别反身性过程处于哪个阶段、何时会转折，需要洞察力，也带有很大的主观性。</li><li><strong>挑战传统经济学：</strong>他批评主流经济学（尤其是有效市场假说）过于简化，忽略了思考与现实之间的互动，无法解释金融市场中常见的泡沫和崩溃。</li></ul></li></ul></li></ul><hr /><p><strong>第五部分：前瞻 (The Future)</strong></p><ul><li><strong>内容：将反身性延伸到更广阔的领域</strong><ul><li><strong>通俗解释：</strong>索罗斯认为，反身性不仅仅适用于金融市场，它是一个普遍现象。</li><li><strong>延伸应用：</strong><ul><li><strong>政治领域：</strong>民意调查结果会影响选民的投票意向，从而影响选举结果，而选举结果又会改变政治格局和未来的民意。</li><li><strong>社会领域：</strong>社会观念的形成和演变也存在反身性。比如，对某种行为的普遍看法会影响法律和规范的制定，而法律规范又会反过来塑造人们的行为和观念。</li><li><strong>科学研究：</strong>科学家的理论和预期可能在某种程度上影响实验的设计和结果的解读。</li></ul></li><li><strong>哲学思考：</strong>最后，索罗斯将反身性与他的“开放社会”理念联系起来。他认为，承认我们认识的局限性（易错性）和我们的行动会对现实产生反作用（反身性），是建立一个能够自我纠错、不断进步的开放社会的基础。</li></ul></li></ul><hr /><p><strong>总结一下《金融炼金术》的核心思想：</strong></p><p>别把市场想得太简单，以为价格只反映价值。记住索罗斯说的“反身性”：人的想法和行动会改变市场现实，改变后的现实又回头影响人的想法。这是一个不断反馈、可能放大偏离的循环。理解了这一点，你就能更深刻地看待金融市场的波动、泡沫和崩溃，甚至能拓展到理解社会和政治的复杂动态。但这套理论用起来非常难，索罗斯本人也承认这一点。</p>]]></content>
    
    
    <categories>
      
      <category>投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024年度投资备忘录</title>
    <link href="/2025/04/22/2025-04-22-%E5%B9%B4%E6%8A%95%E8%B5%84%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    <url>/2025/04/22/2025-04-22-%E5%B9%B4%E6%8A%95%E8%B5%84%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p><strong>2024年度投资备忘录</strong></p><p><strong>核心目标：</strong>基于价值投资理念，持续寻找并持有估值合理或低估的优质资产，实现长期、稳健的资本增值。</p><p><strong>一、 投资业绩回顾 (基于提供数据的时间段)</strong></p><ul><li><strong>资金情况：</strong><ul><li>初始资金：85,000元</li><li>期间追加投入：57,800元</li><li>期末总资产：176,186元</li><li>账户整体浮动盈利：33,319元</li><li>已实现分红收益：约 7,868元 (根据各股票分红数据加总估算)</li><li>期间总投入资本：142,800元 (初始 + 追加)</li><li>整体投资收益率：<strong>27.96%</strong>(您提供的数据，可能包含了特定计算方式，如考虑了资金投入时间权重等)</li><li><em>注：若简单以 (浮盈+分红) / 总投入 计算，收益率约为 (33319 +7868) / 142800 ≈28.8%</em>。无论采用哪种精确算法，均取得了显著的正收益。</li></ul></li><li><strong>主要盈利贡献者：</strong><ul><li><strong>中国平安：</strong> 浮盈14,937元 + 分红2,550元 =17,487元。作为核心持仓之一，贡献了最大的利润。</li><li><strong>格力电器：</strong> 浮盈11,266元 + 分红2,380元 =13,646元。同样是重要的利润来源，且通过置换永新股份的操作，体现了在机会成本权衡下的主动管理。</li><li><strong>高股息资产：</strong>银行股（农行、兴业、工行）、中国海油、双汇发展等均提供了正向的浮动盈利和可观的现金分红，体现了股息作为安全垫和总回报组成部分的重要性。双汇发展的分红尤为突出。</li></ul></li><li><strong>亏损及风险管理：</strong><ul><li>永新股份：虽账面亏损2,333元卖出，但该决策是基于对格力电器更优投资机会的判断，属于主动风险管理和机会成本置换行为。</li><li>中国石化：小额浮亏111元，影响甚微。</li><li>其他：塞力转债、标普500 ETF贡献较小，但也实现了正收益。</li></ul></li></ul><p><strong>二、 投资逻辑与策略评估</strong></p><ul><li><strong>核心策略：</strong>严格遵循价值投资理念，买入并持有内在价值被低估的公司。</li><li><strong>估值方法应用：</strong><ul><li><strong>多元化估值工具：</strong>针对不同行业特性，采用了合适的估值方法：保险（内涵价值EV）、制造业/消费品（现金流折现DCF）、银行（市净率P/B结合股息率）。这显示了对估值工具的理解和灵活运用。</li><li><strong>强调安全边际：</strong>买入价格显著低于估算的内在价值区间（如平安45元 vs 76元，格力33-38元 vs68-80元），这是价值投资的核心要求，也是控制风险的关键。</li><li><strong>股息作为考量：</strong>对于银行股和双汇发展等，高股息率不仅提供了现金回报，也作为低估值判断的佐证和持有的安全垫。</li></ul></li><li><strong>主动管理与决策：</strong>卖出永新股份转投格力电器的操作，显示了在承认错误或发现更好机会时进行调整的灵活性和决心，而非僵化持有。</li><li><strong>潜在优化点：</strong><ul><li><strong>行业集中度：</strong>目前持仓高度集中于金融（保险、银行）和传统蓝筹（家电、能源、食品），虽然这些是典型的价值投资领域，但也可能带来一定的行业系统性风险。</li><li><strong>地域集中度：</strong>绝大部分投资集中于中国内地A股市场，标普500ETF仓位较小，地域多元化程度不高。</li></ul></li></ul><p><strong>三、 宏观环境展望 (2024年)</strong></p><ul><li><strong>中国经济：</strong>预计将继续在“稳增长”和“高质量发展”之间寻求平衡。政策重点可能围绕刺激内需、稳定房地产市场、支持科技创新和现代化产业体系建设。需关注财政和货币政策的力度与方向，以及消费复苏的可持续性。</li><li><strong>全球经济：</strong>全球增长可能放缓，通胀压力虽有缓解但仍存不确定性。主要央行（尤其是美联储）的利率政策路径将是关键影响因素。地缘政治风险持续存在，对能源价格、供应链等产生影响。</li><li><strong>对投资组合的影响：</strong><ul><li><strong>银行/保险：</strong>可能受益于经济企稳和潜在的“中特估”行情，但也需关注净息差压力（若降息）和资产质量风险（尤其涉房贷款）。</li><li><strong>消费（格力/双汇）：</strong>受益于内需提振政策和居民消费信心恢复，但需关注行业竞争和成本（如原材料价格）。</li><li><strong>能源（海油/石化）：</strong>受益于全球经济活动和地缘政治对油价的支撑，但也需关注全球需求变化和能源转型长期趋势。</li><li><strong>整体市场：</strong>低估值、高股息策略在不确定性较高的宏观环境下可能继续表现出防御性。</li></ul></li></ul><p><strong>四、 微观层面与持仓检视 (2024年)</strong></p><ul><li><strong>持续跟踪内在价值：</strong>定期（如每季度/半年度）根据公司最新财报和行业动态，重新评估核心持仓的内在价值。<ul><li><strong>中国平安：</strong>关注寿险改革成效、代理人队伍质态、投资端表现（尤其是不动产风险敞口）、分红政策稳定性。EV增长是否符合预期？</li><li><strong>格力电器：</strong>关注空调主业市场份额、多元化业务（生活电器、工业制品）进展、渠道改革效果、分红持续性。DCF模型的关键假设（增长率、折现率）是否需要调整？</li><li><strong>银行股：</strong>关注净息差（NIM）变化趋势、不良贷款率和拨备覆盖率、资本充足率、分红支付率。低P/B状态是否因基本面恶化还是市场情绪导致？</li><li><strong>中国海油/中国石化：</strong>关注油气价格波动、公司资本开支计划、成本控制能力、新能源转型布局、派息政策。</li><li><strong>双汇发展：</strong>关注猪周期对成本端的影响、肉制品结构升级和创新、渠道拓展、食品安全问题、分红政策。DCF估值是否需要根据最新的盈利预测调整？</li></ul></li><li><strong>标普500 ETF：</strong>作为小仓位的全球分散配置，关注美国经济走向、通胀与利率、科技股表现。思考该仓位在整体组合中的战略意义和未来是否调整。</li></ul><p><strong>五、 投资机会与风险 (2024年)</strong></p><ul><li><strong>潜在机会：</strong><ul><li><strong>现有持仓价值回归：</strong>如果市场情绪改善或公司基本面持续向好，现有低估值持仓可能迎来价值重估。</li><li><strong>高股息再投资：</strong>利用收到的分红，在估值合理时继续增持现有优质标的或发掘新的低估机会，发挥复利效应。</li><li><strong>市场波动带来的买入机会：</strong>坚持价值投资纪律，利用市场非理性下跌，买入符合标准的好公司。</li><li><strong>“中特估”深化：</strong>部分持仓（如银行、能源）可能受益于“中国特色估值体系”的推进和市场对国企价值的重新认识。</li></ul></li><li><strong>主要风险：</strong><ul><li><strong>宏观经济不及预期：</strong>国内外经济复苏乏力，可能压制企业盈利和市场整体估值。</li><li><strong>价值陷阱：</strong>部分低估值股票可能因行业长期逻辑变化、公司竞争力下降等原因，持续保持低估状态。</li><li><strong>政策风险：</strong>特定行业的监管政策调整可能影响相关公司经营和估值。</li><li><strong>地缘政治风险：</strong>可能影响能源价格、全球贸易和市场情绪。</li><li><strong>集中度风险：</strong>金融、能源等权重板块若出现系统性问题，会对组合造成较大冲击。</li><li><strong>估值模型风险：</strong>DCF等模型对假设参数敏感，若关键假设与实际情况偏差较大，会导致估值失真。</li></ul></li></ul><p><strong>六、 行动计划与思考 (2024年)</strong></p><ol type="1"><li><strong>坚守核心策略：</strong>继续以价值为锚，不追逐市场热点，保持投资纪律和耐心。</li><li><strong>动态评估与调整：</strong>定期审视持仓基本面，更新内在价值评估。对偏离初始投资逻辑或基本面显著恶化的标的，考虑减持或置换。</li><li><strong>优化组合结构：</strong><ul><li><strong>审视集中度：</strong>评估当前行业和地域集中度是否符合自身的风险承受能力。是否需要适度增加其他行业（如科技、医药、消费升级等领域中符合价值标准的标的）或增加海外配置（如考虑增持标普500ETF或布局其他区域ETF）来分散风险？</li><li><strong>股息再投资策略：</strong>明确收到的股息是投入到现有最佳机会，还是用于建立新头寸。</li></ul></li><li><strong>持续学习与研究：</strong>跟踪宏观经济动态、行业发展趋势和公司公告，不断提升认知水平。</li><li><strong>风险管理：</strong>对单一个股的仓位进行审视，确保没有过度集中的风险。理解极端情况下可能的回撤。</li></ol><p><strong>七、 结语</strong></p><p>过去一段时间的投资表现证明了您价值投资框架的有效性，取得了令人满意的回报。2024年，宏观环境依然充满挑战与不确定性，但也为坚持价值投资、注重安全边际和长期回报的投资者提供了机会。关键在于保持清醒的头脑，持续跟踪、独立思考、审慎决策，在风险可控的前提下，力争实现资产的长期稳健增值。</p>]]></content>
    
    
    <categories>
      
      <category>投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给初学者的哲学学习计划</title>
    <link href="/2025/04/09/2025-04-09-%E5%93%B2%E5%AD%A6%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%921%E5%B9%B4/"/>
    <url>/2025/04/09/2025-04-09-%E5%93%B2%E5%AD%A6%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%921%E5%B9%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="给初学者的哲学学习计划">给初学者的哲学学习计划</h1><p><strong>核心原则：</strong></p><ol type="1"><li><strong>从概览到深入：</strong>先了解哲学版图，再深入具体流派和哲学家。</li><li><strong>历史脉络：</strong>按时间顺序学习有助于理解思想的演变和相互影响。</li><li><strong>东西方兼顾：</strong>平衡西方哲学和中国哲学（或其他东方哲学）的学习。</li><li><strong>主动学习：</strong>不只是阅读，更要思考、记录、讨论（如果可能）。</li><li><strong>保持节奏，允许调整：</strong>这不是考试，重要的是理解和享受过程。进度可以根据兴趣和理解程度灵活调整。</li></ol><p><strong>第一阶段：哲学入门与古代智慧 (第1-3个月)</strong></p><ul><li><strong>目标：</strong>了解哲学是什么，基本的问题领域（知识论、伦理学、形而上学等），熟悉古代东西方哲学的源头和核心人物。</li><li><strong>学习内容：</strong><ul><li><strong>哲学导论：</strong><ul><li>阅读1-2本优秀的哲学入门书籍。推荐：<ul><li>《哲学家们都干了些什么？》（写给普通人的哲学史，有趣易懂）</li><li>《苏菲的世界》（故事性强，串联西方哲学史）</li><li>《大问题：简明哲学导论》（罗伯特·所罗门，更系统一些）</li></ul></li><li>了解哲学的基本分支：形而上学（研究存在/实在）、认识论（研究知识）、伦理学（研究道德）、逻辑学（研究推理）、美学（研究美）。</li></ul></li><li><strong>古希腊哲学：</strong><ul><li>重点：苏格拉底（通过柏拉图的对话了解）、柏拉图（理型论、理想国概要）、亚里士多德（逻辑学基础、形而上学、伦理学的中庸思想）。</li><li>可以阅读柏拉图的《申辩篇》、《理想国》（节选），亚里士多德的《尼各马可伦理学》（节选）。或者先看二手解读。</li></ul></li><li><strong>古代中国哲学：</strong><ul><li>重点：老子（道、无为）、孔子（仁、礼、君子）、庄子（逍遥游、齐物论、相对主义）。</li><li>阅读《道德经》、《论语》、《庄子》（可以先从感兴趣的篇章或寓言故事开始）。</li></ul></li></ul></li><li><strong>学习方法：</strong><ul><li><strong>做笔记：</strong>记录关键人物、核心概念、主要观点和自己的疑问。</li><li><strong>画思维导图：</strong> 梳理哲学家之间的关系和思想脉络。</li><li><strong>思考与生活联系：</strong>比如，思考孔子的“仁”在现代社会的体现，用苏格拉底的方式问自己一些基本问题。</li></ul></li></ul><p><strong>第二阶段：中世纪的过渡与近代的曙光 (第4-6个月)</strong></p><ul><li><strong>目标：</strong>了解中世纪哲学（信仰与理性的关系），重点掌握近代西方哲学的两大流派——理性主义和经验主义，以及康德的批判哲学。</li><li><strong>学习内容：</strong><ul><li><strong>中世纪哲学（简要了解）：</strong><ul><li>了解奥古斯丁、托马斯·阿奎那如何试图调和信仰与古希腊哲学。知道这个时期的特点即可，不必深究。</li></ul></li><li><strong>近代西方哲学 - 理性主义：</strong><ul><li>重点：笛卡尔（我思故我在、心物二元论）、斯宾诺莎（实体、泛神论）、莱布尼茨（单子论、预定和谐）。</li><li>尝试阅读笛卡尔的《第一哲学沉思集》（或其导读）。</li></ul></li><li><strong>近代西方哲学 - 经验主义：</strong><ul><li>重点：洛克（白板说、天赋权利）、贝克莱（存在就是被感知）、休谟（因果关系、自我、怀疑主义）。</li><li>了解他们对知识来源的不同看法。</li></ul></li><li><strong>康德（关键人物！）：</strong><ul><li>理解他如何试图调和理性主义和经验主义（认识论的“哥白尼革命”）。</li><li>了解他的伦理学思想（绝对命令）。</li><li>康德比较难，建议先看二手解读，了解其核心思想框架。</li></ul></li></ul></li><li><strong>学习方法：</strong><ul><li><strong>对比学习：</strong> 比较理性主义和经验主义的异同。</li><li><strong>抓住核心问题：</strong>关注他们如何回答“知识从哪里来？”“我们能认识什么？”</li><li><strong>开始接触二手文献：</strong>阅读一些哲学史书籍中关于这些哲学家的章节。</li></ul></li></ul><p><strong>第三阶段：现代哲学的浪潮 (第7-9个月)</strong></p><ul><li><strong>目标：</strong>了解19世纪到20世纪初的主要哲学思潮，感受思想的碰撞与多元化。</li><li><strong>学习内容：</strong><ul><li><strong>德国古典哲学（康德之后）：</strong><ul><li>简要了解黑格尔（辩证法、绝对精神），他的思想影响深远但也较难。</li></ul></li><li><strong>功利主义：</strong><ul><li>边沁、密尔（最大多数人的最大幸福）。思考其伦理原则的优缺点。</li></ul></li><li><strong>存在主义的先驱：</strong><ul><li>克尔凯郭尔（关注个体选择和信仰的飞跃）、尼采（上帝死了、权力意志、超人）。</li></ul></li><li><strong>马克思主义哲学：</strong><ul><li>了解其唯物史观、异化理论等核心概念。</li></ul></li><li><strong>实用主义：</strong><ul><li>皮尔士、詹姆士、杜威（关注思想的效果和实践）。</li></ul></li></ul></li><li><strong>学习方法：</strong><ul><li><strong>关注思想背景：</strong>理解这些哲学思潮产生的社会历史背景。</li><li><strong>理解核心主张：</strong>每个流派都有其独特的切入点和核心关切，抓住关键。</li><li><strong>批判性思考：</strong> 尝试分析不同流派的优点和局限性。</li></ul></li></ul><p><strong>第四阶段：当代哲学与专题探索 (第10-12个月)</strong></p><ul><li><strong>目标：</strong>了解20世纪至今的主要哲学流派，并根据兴趣选择1-2个专题进行初步探索。</li><li><strong>学习内容：</strong><ul><li><strong>分析哲学：</strong><ul><li>了解其对语言、逻辑的重视（罗素、维特根斯坦早期和后期思想的转变）。</li></ul></li><li><strong>现象学：</strong><ul><li>了解胡塞尔的“回到事物本身”。</li></ul></li><li><strong>存在主义（正式形成）：</strong><ul><li>萨特（存在先于本质、自由与责任）、加缪（荒诞哲学）。</li></ul></li><li><strong>结构主义与后结构主义/后现代主义（选读）：</strong><ul><li>了解福柯（权力与知识）、德里达（解构）等对传统观念的挑战（这些可能较难，初步了解即可）。</li></ul></li><li><strong>选择专题（根据兴趣）：</strong><ul><li><strong>伦理学专题：</strong>如生命伦理（安乐死、堕胎）、环境伦理等。</li><li><strong>政治哲学专题：</strong>如正义理论（罗尔斯）、自由主义与社群主义之争等。</li><li><strong>心灵哲学专题：</strong> 如心物关系、人工智能哲学等。</li><li><strong>中国现代哲学：</strong>如新儒家（熊十力、牟宗三等）的发展。</li></ul></li></ul></li><li><strong>学习方法：</strong><ul><li><strong>阅读导论性文章或书籍章节：</strong>对于当代哲学流派，先通过概览性文字了解其主旨。</li><li><strong>利用网络资源：</strong><ul><li><strong>斯坦福哲学百科全书 (Stanford Encyclopedia of Philosophy,SEP):</strong> 非常权威，适合查阅具体概念和哲学家，但内容较深。</li><li><strong>哲学播客：</strong> 如 "Philosophize This!", "History ofPhilosophy Without Any Gaps"，用听的方式辅助学习。</li><li><strong>线上课程平台：</strong> Coursera, edX上有一些不错的哲学入门课程。</li></ul></li><li><strong>尝试写作：</strong>就某个感兴趣的哲学问题或观点，写写自己的理解和看法。</li></ul></li></ul><p><strong>贯穿全年的建议：</strong></p><ul><li><strong>保持阅读习惯：</strong> 每周设定固定的阅读时间。</li><li><strong>精读与泛读结合：</strong>对核心人物和著作精读，对其他内容泛读了解。</li><li><strong>善用二手资料：</strong>优秀的哲学史、哲学导论、哲学家传记、解读性文章能帮你更快入门。</li><li><strong>不畏难，允许卡壳：</strong>遇到难懂的地方，先跳过或查阅资料，不要因此放弃。哲学本身就充满争议和晦涩。</li><li><strong>思考重于记忆：</strong>理解哲学家的论证过程和问题意识，比单纯记住观点更重要。</li><li><strong>开放心态：</strong>接触不同的观点，即使你不同意，也要尝试理解其逻辑。</li><li><strong>找到同伴（如果可能）：</strong>和朋友讨论哲学问题会非常有启发。</li></ul><p>这个计划提供了一个框架，你可以根据自己的兴趣和节奏进行调整。最重要的是享受这个探索人类智慧的旅程！祝你学习顺利，收获满满！</p>]]></content>
    
    
    <categories>
      
      <category>哲学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原理</tag>
      
      <tag>哲学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给初学者的投资学习计划</title>
    <link href="/2025/04/09/2025-04-09-%E6%8A%95%E8%B5%84%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%921%E5%B9%B4/"/>
    <url>/2025/04/09/2025-04-09-%E6%8A%95%E8%B5%84%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%921%E5%B9%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="给初学者的投资学习计划">给初学者的投资学习计划</h1><p><strong>核心原则：</strong></p><ul><li><strong>理解先于行动：</strong> 不懂不做。</li><li><strong>循序渐进：</strong> 从基础开始，逐步深入。</li><li><strong>理论结合实践：</strong>阅读、思考，并通过模拟或小额实践。</li><li><strong>保持耐心和好奇心：</strong> 投资是终身学习的过程。</li></ul><p><strong>一年学习计划（分为四个阶段）：</strong></p><p><strong>第一阶段：基础入门与思维建立 (第 1-3 个月)</strong></p><ul><li><strong>目标：</strong>了解投资的基本概念、术语、主要资产类别和市场运作方式，树立正确的投资心态。</li><li><strong>学习内容：</strong><ul><li><strong>什么是投资？</strong> 投资与投机的区别，复利的力量。</li><li><strong>基本金融工具：</strong>股票、债券、基金（指数基金、主动基金）、现金等价物是什么？它们各自的风险和收益特征。</li><li><strong>市场基础：</strong>什么是交易所？股价如何波动？什么是牛市、熊市？</li><li><strong>基本经济概念：</strong> 通货膨胀、利率、GDP对投资的影响。</li><li><strong>核心投资理念：</strong>了解价值投资（格雷厄姆、巴菲特）、成长投资（彼得·林奇）、指数投资（约翰·博格）的基本思想。认识到风险与回报的关系。</li><li><strong>克服心理障碍：</strong>了解常见的投资心理误区（如追涨杀跌、过度自信、损失厌恶）。</li></ul></li><li><strong>行动建议：</strong><ul><li><strong>阅读入门书籍：</strong><ul><li>《小狗钱钱》或《富爸爸穷爸爸》（建立财商思维）</li><li>《穷查理宝典》（学习思维模型，虽然不全是投资，但非常重要）</li><li>《漫步华尔街》（了解市场有效性、指数投资和资产配置）</li></ul></li><li><strong>浏览财经网站/APP：</strong> 如 Investopedia(英文，非常好的基础教学网站)、雪球、东方财富等，熟悉术语和市场动态（先看懂，不急于交易）。</li><li><strong>观看纪录片/视频：</strong>搜索关于巴菲特、金融危机等的纪录片，或 B站、YouTube上的优质财经科普内容。</li><li><strong>思考：</strong>记录自己对风险的看法，初步思考自己的投资目标（比如，是为了养老、买房还是财富增值？）。</li></ul></li></ul><p><strong>第二阶段：公司分析与估值基础 (第 4-6 个月)</strong></p><ul><li><strong>目标：</strong>学会阅读财务报表，理解公司基本面分析的核心要素，初步掌握估值概念。</li><li><strong>学习内容：</strong><ul><li><strong>财务报表入门：</strong><ul><li><strong>利润表 (Income Statement)：</strong>公司赚了多少钱？（收入、成本、利润）</li><li><strong>资产负债表 (Balance Sheet)：</strong>公司有多少家底？（资产、负债、股东权益）</li><li><strong>现金流量表 (Cash Flow Statement)：</strong>公司的钱从哪里来，到哪里去？（经营、投资、筹资活动现金流）——这个非常重要！</li></ul></li><li><strong>关键财务指标：</strong>毛利率、净利率、ROE（净资产收益率）、负债率、市盈率 (P/E)、市净率 (P/B)等，理解它们的含义和局限性。</li><li><strong>定性分析入门：</strong>什么是护城河（竞争优势）？如何判断管理层？公司所处的行业前景如何？</li><li><strong>估值基础：</strong> 理解内在价值的概念，了解相对估值法（如P/E 对比）和绝对估值法（如 DCF贴现现金流，先了解概念即可，不必深入计算）的基本逻辑。</li></ul></li><li><strong>行动建议：</strong><ul><li><strong>阅读经典书籍：</strong><ul><li>《巴菲特致股东的信》（巴菲特思想的精华）</li><li>《彼得·林奇的成功投资》（学习如何从生活中发现好公司）</li><li>《手把手教你读财报》（唐朝 著，适合 A股投资者入门）或类似财报解读的书籍。</li></ul></li><li><strong>实践分析：</strong>选择几家你熟悉或感兴趣的公司（比如你常用的消费品牌、工作的行业巨头），尝试阅读它们的年报（先看“管理层讨论与分析”部分和主要财务数据），尝试计算一些基本指标。</li><li><strong>开始模拟交易 (Paper Trading)：</strong>在不投入真实资金的情况下，根据你的分析进行模拟买卖，记录理由和结果，检验自己的判断。</li></ul></li></ul><p><strong>第三阶段：策略深化与组合构建 (第 7-9 个月)</strong></p><ul><li><strong>目标：</strong>深入理解不同的投资策略，学习资产配置和风险管理，开始形成自己的投资框架。</li><li><strong>学习内容：</strong><ul><li><strong>深入价值投资：</strong>《聪明的投资者》（格雷厄姆著，重点读第8章“市场波动”和第20章“安全边际”）。</li><li><strong>深入成长投资：</strong>进一步理解如何评估成长性，警惕“增长陷阱”。</li><li><strong>指数基金投资：</strong>深入了解指数基金的优势、选择方法（如跟踪误差、费率）、定投策略。</li><li><strong>资产配置：</strong>理解为什么不要把所有鸡蛋放在一个篮子里，学习股债平衡、不同风险资产如何搭配。</li><li><strong>风险管理：</strong>认识不同类型的风险（市场风险、信用风险、流动性风险等），如何通过分散化、安全边际来控制风险。</li></ul></li><li><strong>行动建议：</strong><ul><li><strong>阅读进阶书籍/文章：</strong><ul><li>《投资最重要的事》（霍华德·马克斯著，理解市场周期和逆向思维）</li><li>阅读巴菲特、芒格、彼得·林奇、达利奥等的访谈、演讲稿。</li></ul></li><li><strong>思考个人策略：</strong>结合自己的性格、风险承受能力、知识圈，思考哪种投资风格（价值、成长、指数、或其他）更适合自己？是打算集中投资少数几家公司，还是广泛分散？</li><li><strong>制定初步的投资计划草稿：</strong>包括投资目标、期限、风险承受能力、拟采用的策略、资产配置的大致比例（如多少股票、多少债券/现金）。</li><li><strong>继续模拟交易：</strong>尝试应用更明确的策略进行模拟操作。</li></ul></li></ul><p><strong>第四阶段：实践准备与持续学习 (第 10-12 个月)</strong></p><ul><li><strong>目标：</strong>完善个人投资体系，了解交易实务，为小额实盘操作做准备，并建立持续学习的习惯。</li><li><strong>学习内容：</strong><ul><li><strong>选择券商/交易平台：</strong>了解开户流程、交易佣金、软件使用。</li><li><strong>交易基础：</strong>了解不同的订单类型（市价单、限价单）。</li><li><strong>投资纪律：</strong>制定买入和卖出的基本原则，如何应对亏损？如何避免情绪化交易？</li><li><strong>信息渠道：</strong>如何筛选高质量的财经信息？警惕噪音和虚假信息。</li><li><strong>税务知识：</strong>了解基本的投资相关税收（如股息税、资本利得税等，各国/地区不同）。</li></ul></li><li><strong>行动建议：</strong><ul><li><strong>完善投资计划：</strong>基于前期的学习和思考，完成一份相对详细的个人投资计划书。</li><li><strong>小额实盘（可选）：</strong>如果你感觉准备好了，可以考虑用一小部分“亏得起”的钱开始实盘投资（强烈建议从指数基金或你深入研究过的、有足够安全边际的蓝筹股开始）。<strong>记住，初始目标是学习，不是赚钱。</strong></li><li><strong>建立学习系统：</strong>确定长期关注的投资大师、财经媒体、研究报告来源。定期回顾自己的投资记录（无论是模拟还是实盘），总结经验教训。</li><li><strong>保持阅读和思考：</strong>投资是一场永无止境的学习，持续阅读经典和市场分析。</li></ul></li></ul><p><strong>重要提醒：</strong></p><ol type="1"><li><strong>不要追求速成：</strong>投资需要时间和耐心，一年打基础，之后的路还很长。</li><li><strong>独立思考：</strong>大师的观点是参考，最终要形成自己的判断。</li><li><strong>风险自负：</strong>任何投资都有风险，做好承担损失的准备。</li><li><strong>从简单开始：</strong>如果觉得复杂，就从最简单的指数基金定投开始了解和实践。</li><li><strong>保持记录：</strong>写投资日记，记录你的思考、决策依据、成功与失败，这是宝贵的财富。</li></ol><p>这个计划提供了一个框架，你可以根据自己的时间和兴趣进行调整。祝你学习顺利，在投资的道路上稳步前行！</p>]]></content>
    
    
    <categories>
      
      <category>投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原理</tag>
      
      <tag>投资</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可转债投资简明解释</title>
    <link href="/2024/11/01/2024-11-01-%E5%8F%AF%E8%BD%AC%E5%80%BA/"/>
    <url>/2024/11/01/2024-11-01-%E5%8F%AF%E8%BD%AC%E5%80%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="可转债投资简明解释">可转债投资简明解释</h1><p>声明:rotating_light:：本文不作任何投资建议和意见，投资者依照本文进行投资，后果自负。</p><p>:zap:这篇为转载：</p><p>作者：一路向楠OK 来源：雪球</p><h2 id="可转债的基本概念"><strong>01 可转债的基本概念</strong></h2><h3 id="什么是可转债"><strong>1.1 什么是可转债</strong></h3><p>如果说债券相当于上市公司为了借钱开出的借条，那么可转债就是一种特殊的借条，特殊性在于持有可转债的投资者可以在一定的条件下把手中的债券转换成公司股票，这时候债主就会变成股东。</p><p>优点在于既可以享受债券的稳定收益，又可以在对应公司股票（正股）价格上涨时获得额外收益</p><h3 id="可转债和普通债券有什么区别"><strong>1.2可转债和普通债券有什么区别</strong></h3><p>普通债券每张面值一般是100元，利率固定，每年会支付固定的利息，最后一年还本付息，发行期限不等，有三年有五年也有十年等等。</p><p>可转债每张面值是永远不会变的100元，利率则是逐年递增，并且普遍低于普通债券，最后一年还本付息，除此之外还有公司额外的奖励，具体金额每个公司不等，发行期限是5年或者6年，98%以上的可转债发行期限是6年。</p><figure><img src="https://xqimg.imedao.com/185de5b23e84f7563fe9a503.png!800.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>由于具备了到期还钱的债券属性，所以也算<strong>下有保底</strong>。</p><p>当然可转债的利息并不多，尤其是在前三年，几乎可以说忽略不计，不过咱们买可转债也不是为了这点利息，主要是看中了额外的增值功能（股票的看涨期权价值），所以江湖人称<strong>上不封顶</strong></p><h3 id="可转债的额外增值功能"><strong>1.3可转债的额外增值功能</strong></h3><p>可转债发行的同时会约定一个转股价，在可转债发行6个月后（进入转股期），投资者可以按照自己的意愿，随时选择要不要把手中的可转债，按照约定好的转股价换成相应的股票。</p><p><strong>转股数量 = 可转债面值（固定100元）/ 转股价*持有的可转债张数</strong></p><p>一般来讲转股价约定好了之后不会随意调整，可转债的面值100元也永远不变，那么每张转债可以转换的股票数量也不会变动。</p><p>虽然转股价一般不会变动，但是公司的股价却是每天在变，所以为了方便知道手里的转债转换成股票后值多少钱，通常会计算转股价值。</p><p><strong>转股价值=（100元 / 转股价）x 正股价</strong></p><p>所以决定每张转债价值的是公司的股价，股价涨多少转股价值就会涨多少，股价跌多少转股价值就会跌多少。</p><p>举个栗子：小红科技公司为了发展要拓展新的项目，于是发行可转债借钱，初始转股价定为10元，那么一张面值100元的转债可以转换的股票数量就是100/10=10股。</p><p>假如公司未来发展较好，股价涨到了15元，如果这时候把1张转债转股后卖出，可以获得的收益是10股*15元=150元，所以这时候转股价值就是150元。</p><p>因为转股价值远远高于债券的面值，那么小红科技公司的可转债交易价格就会水涨船高，每张转债交易价格大于或等于它的转股价值150元。</p><p>但是如果公司没有涨反而跌了怎么办，比如小红科技公司股价一直低于初始转股价10元，甚至跌到了2元，这时候一张转债的转股价值只有10股*2元=20元。</p><p>100元面值的转债转股之后只值20元，明显转股就是不划算的，所以投资人不会选择转股，而是持有到期还本付息，至少也不算亏</p><h3 id="初始转股价是怎么定的"><strong>1.4初始转股价是怎么定的</strong></h3><p>当然可转债发行时的转股价是多少，监管有明确的规定，初始转股价格不低于募集说明书公告日前二十个交易日公司股票交易均价和前一个交易日公司A股股票交易均价。</p><p>比如小红科技公司5月14日发募集公告书说我要发可转债啦，那么转股价就是5月14日往前推算二十个交易日公司股票交易的平均价格，或者是5月13日的股票交易平均价格，选择高的定为初始转股价。</p><p>而可转债的上市日期距离募集公告书日期通常不会超过1个月，所以初始转股价反映的是可转债上市日期附近的公司股票平均交易价格。</p><h2 id="可转债的三大重点条款"><strong>02可转债的三大重点条款</strong></h2><p>既然选择投资可转债，那么可转债的三大条款就有必要了解清楚</p><h3 id="强赎条款"><strong>2.1 强赎条款</strong></h3><p>也叫条件赎回条款，有两种情况会触发强制赎回条款：在转股期内下述两种情形出现任意一种时，公司都有权利按照债券面值加上当期应计利息的价格赎回全部或部分未转股的可转债。</p><p>第一，如果公司A股股票连续30个交易日中至少有15个交易日的收盘价不低于当期转股价格的130%（含130%）。</p><p>第二，本次发行的可转债未转股余额不足人民币3000万元时。</p><p>说人话：本来转债的生命周期是6年，但是现在公司股价比转股价高了30%啦（转股价值大于130元），触发了强赎条款，上市公司要提前结束这只转债的生命，按照101元的价格强制还本付息哦，赶紧给我转换成股票，不然的话到嘴的收益就没了。</p><p>这时候投资者手里的每张转债价值大于130元，公司会按照101元的价格赎回，所以投资者要么选择卖出转债，要么选择转股，否则会面临巨大损失。</p><p>我们在集思录上可以看到<strong>强赎天计数（0/15｜30）</strong>的字段，实际上就是对第一种强赎触发情况的简便表示。</p><p>0代表的是满足转股价值大于130元的天数，15代表的是需要满足15个交易日，30代表的是在连续的三十个交易日中。</p><p>0/15｜30 = 没有满足强赎条件</p><p>10/15｜30 =最近30个交易日有10天转股价值大于130元，即将满足强赎条件</p><p>15/15｜30 = 满足强赎条件</p><p>满足强赎条件的当天上市公司会发公告决定是否强赎，这是由上市公司来决定的，经过长期的观察，实际过程中公司的强赎意愿很难判断，有的公司第一次满足强赎条件就会立马强赎，有的则会很长一段时间都选择不强赎。</p><p>即便是通过现金流、负债率、国企民企、上市时间来判断公司的强赎意愿，也没有很明显的规律。就像男人不知道女人为啥忽然生气，女人也不知道男人为什么沉默不语，上市公司的心思你别猜。</p><p>虽然判断不出一个公司是否会选择强赎，但是通过历史数据的统计来看有以下几个规律。</p><p><strong>规律一：95%以上的转债会强赎。</strong></p><p><strong>规律二：80%以上的转债会在三年内完成强赎，强赎转债平均存续时间是1.9年左右。</strong></p><p><strong>规律三：公告强赎之后转债价格跌多涨少。</strong></p><p>那么通过这前两个规律我们就可以知道，一只转债上市之初的价格如果低于130元，我们买入，持有不到三年的时间，大概率就是赚钱的投资，而实际上可能都不用三年，你就会开始赚钱。</p><p>第三个规律告诉我们强赎之后转债价格跌多涨少，主要的原因是一旦公司公告强赎之后，显然大家都不想以101元左右的价格把手中的转债赎回给公司，毕竟手中转债价值超过130元，所以会争先恐后的卖出转债跑路，卖的人多了价格就会被压制。</p><p>除了卖出转债，另外一个选择是转股，转股之后如果卖出股票，公司股价同样也会遇到抛压，所以强赎对于转债来说是利空。</p><p>当然也有一些公司会选择不强赎，转债价格一直涨，所以可以看到几百甚至上千元的转债。</p><p>对于新手来说，不要轻易去一直拿着转债不卖出，去赌公司不强赎，有赢的概率，但是不大，而一旦亏起来可是嘎嘎肉疼。</p><p>一般老司机会在即将满足强赎条件之前先卖出转债避一避潜在的下跌风险，这些都是花钱买出来的经验。</p><p>对于公司来说，无论投资人之间怎么互相倒卖，到最后基本上所有转债终将转换成股票，那么当初发转债借来的钱就可以不用还了，真棒。</p><p>所以公司宣布强赎，并不是想要真的赎回转债，真正的目的是逼着市场进行转股。</p><h3 id="下修条款"><strong>2.2 下修条款</strong></h3><p>前面说过转股价在可转债发行时会规定好，一般不会变，但如果出现下面的情况，上市公司是可以在中途发公告向下修正转股价的。</p><p>当公司股票在任意连续三十个交易日中至少有十五个交易日的收盘价低于当期转股价格的85%时（每个公司略有区别，有的是80%，有的是90%）。</p><p>说人话：公司股价不给力啊，完全涨不起来，以后想要满足强赎条件太难了，但是借来的钱又不想还，连逐年递增的利息都不想给了，那怎么办，下修一下转股价吧，未来强赎难度降低，还是可以促进转股的。</p><p>举个栗子：小红科技公司初始转股价定的是10元，满足强赎条件需要公司股价站上13元，但实际上公司运营不佳，股价一直在5元左右波动，完全涨不起来。</p><p>这时候如果公司将转股价下修到5元，那么未来公司股价只需要涨到5元*130%=6.5元之上，同样也可以满足强赎条件，然后促进转股。</p><p>下修之前：每张转股数量是100/10=10股，转股价值10股*5元=50元</p><p>下修之后：每张转股数量是100/5=20股，转股价值20股*5元=100元</p><p><strong>所以转股价下修之后，每张转债转股数量会增加，转股价值会提升，对于转债投资人来说，本来手里面价值50元的转债一下子变成了100元，手中转债的价格也会有相应的上涨，是利好。</strong></p><p>那有没有小可爱会想小红科技公司直接把转股价下修到3.8元不行吗，这样3.8元*130%=4.94元，公司现在的股价可以立即满足强赎条件。</p><p>太贪了，本来下修条款就是一件很bug的存在（中国可转债独有），但是也不能这么没底线吧，转股价的下修底价是下修股东大会召日前二十个交易日公司股票交易均价和前一个交易日公司A股股票交易均价。</p><p>和初始转股价的确定一样，最低可以到近期公司股价的平均水平。也就是小红科技公司股价最近一直在5元左右波动，那么转股价最低可以下修到5元。</p><p>万一下修之后股价还继续下跌，跌到了2元怎么办？没关系，小红科技公司还可以继续选择下修，这时候股价只需要涨到2元*130%=2.6元就可以满足强赎条件。</p><p>我们在集思录上可以看到<strong>下修天计数（0/15｜30）</strong>的字段，实际上就是对下修条款触发情况的简便表示，和强赎天计数的意思一样。</p><p>0/15｜30 = 没有满足下修条件</p><p>10/15｜30 =最近30个交易日有10天转股价值低于85元，即将满足下修条件</p><p>15/15｜30 = 满足下修条件</p><p>满足下修条件的当天上市公司会发公告决定是否下修，如果上市公司决定下修，会公告提议下修，只是提议哦。</p><p>然后规定一个日期召开股东大会，一般是提议下修后的半个月左右，需要全体没有持有转债的股东投票，三分之二以上的同意才能确定下修。</p><p>为什么需要股东投票表决，其实也不难理解，下修之后每张可转债可以转换的股票变多了，转债持有人受益，公司降低强赎难度也受益，那么损害了谁的利益。</p><p>损害了没有持有转债的中小股东的利益，因为转债转股之后，他们手中的持有的股份会被稀释，所以需要他们来投票决定是否同意下修。</p><p>经过长期的观察，实际过程中只要公司提议下修，大部分都会同意并且下修到底。</p><p>通过对历史数据的统计来看有以下几个规律。</p><p><strong>规律一：最大的涨幅来源提议下修</strong></p><p>只要公司公告提议下修，市场会提前认为下修成功并且到底，转债的价格会在董事会提议下修之后大幅上涨，等到真正公告下修之后反而涨幅较小。</p><figure><img src="https://xqimg.imedao.com/185de5e56c0470993fbc309f.png!800.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p><strong>规律二：下修概率一般在10%以内</strong></p><p>不是每个公司都愿意稀释自己的股份，历史数据统计只有18年有18.7%的公司下修，那一年可是跌了整整一年。</p><p>而同样很惨的2022年总共有460只转债，下修的有45只，概率不到10%。</p><figure><img src="https://xqimg.imedao.com/185de5e5c614709a3fdeeb72.png!800.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>所以对于投资者来说，单纯的为了博弈下修的收益而买入一只转债，从概率上来看这样的性价比并不高。</p><p>更多的是从多方面分析之后买入它，结果某一天突然公告提议下修，这样的意外之喜会让人更<ahref="https://xueqiu.com/S/KXIN?from=status_stock_match">开心</a>一些。</p><h3 id="回售条款"><strong>2.3 回售条款</strong></h3><p>在可转债存续期的最后两年，如果股票在任何连续三十个交易日的收盘价低于当期转股价格的70%时，投资者有权将可转债按面值加上利息提前回售给公司。</p><p>说人话：在可转债生命周期的最后两年，如果股价跌的太惨，转股价值在70元之下，投资者可以选择把转债按照102元（100元+利息）左右的价格卖回给公司，不用等到到期。</p><p>实际上这样的机会并不多见，需要你在100元之下买入转债，持有到回售条款触发之后卖回给公司才能获益。</p><p>但是上市公司到了转债最后两年，会想方设法避免自己回售可转债，比如释放利好让股价上涨，或者下修转股价。</p><p>所以回售条款的存在相当于一个保护屏障的作用，随着时间的推进，转债的价格不会轻易跌破100元面值，否则就会有人回售套利。</p><h2 id="价格溢价率和转股价值"><strong>03价格、溢价率和转股价值</strong></h2><p>溢价率对于可转债是一个非常重要的指标。其实溢价率分为两种：转股溢价率和纯债溢价率，我们平时在炒股软件看到的溢价率，就是转股溢价率。</p><p><strong>转股溢价率=（转债价格-转股价值）/ 转股价值</strong></p><p>举个栗子：小红科技公司转债价格是120元，转股价值是100元，转股溢价率 =（120元-100元）/ 100元 = 20%。</p><p>什么意思呢，每张价值100元的可转债，如果我要在市场上买到它，需要花120元的价格，多出来的这部分就是溢价率，也就是价格比价值贵的那一部分。</p><p>溢价率是个非常有意思的指标，通常为正，主要包含了对正股的看涨预期，也包含了当下市场的热度或者低迷等等。</p><p>溢价率就像是链接转债价格和转股价值的一条可伸缩的线，有时候长有时候短。</p><p>如果线太长，转股价值的波动（股价的波动）就很难影响到转债价格的波动。</p><p>如果线很短，转股价值的波动（股价的波动）会很容易影响到转债价格的波动。</p><p>对于溢价率低高低，没有绝对的标准，每个转债也不一样，也不能简单的认为低就是好，高就是不好，不同的行情表现不一样，这是市场通过不断交易博弈出来的结果。</p><p>不过通过历史数据来看，也可以发现一个规律，当转股价值不断上涨变高时，溢价率会逐渐降低。</p><figure><img src="https://xqimg.imedao.com/185de5e5a074f75a3fc01212.png!800.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>原因是正股已经经历过大涨，后市的看涨预期会逐渐减弱，并且当转股价值到130以上时还有强赎风险。</p><p>除此之外，我们还可以通过价格和溢价率低高低，把转债分到四个区域里面，每个区域的转债都会有一些共同点。</p><figure><img src="https://xqimg.imedao.com/185de5e5d454709b3fd77823.png!800.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>价格多高算高，溢价率多高算高，因人而已，也与市场行情相关，在这里小岛就按照自己的理解去分，给大家作为参考。</p><p><strong>A区：</strong>高价格高溢价率，一般价格超过150元，同时溢价率还在30%以上的转债都可以分到这个区域。</p><p>一些被资金炒作控盘的妖债，例如蓝盾转债（212.971元+302.29%溢价率），横和转债（496.5元+288.86%溢价率）都在这个区域。</p><p>这些转债价格的涨跌基本上和正股的涨跌没有太大关联或者关联较弱，完全看资金的意愿，风险高波动大，一般是不建议新手去买的。</p><p><strong>B区：</strong>低价格高溢价率，一般价格低于120元，同时溢价率还在50%以上的转债可以分到这个区域。</p><p>一些公司爆雷了，或者因为所在赛道熄火被资金抛弃，无论是什么原因，最终导致正股跌幅过大，例如<ahref="https://xueqiu.com/S/SZ128124?from=status_stock_match">科华转债</a>（101.728元+74.96%溢价率），<ahref="https://xueqiu.com/S/SZ123122?from=status_stock_match">富瀚转债</a>（114.9元+92.15%溢价率）都在这个区域。</p><p>这些转债价格的涨跌基本上和正股的涨跌也没有太强的关联，有可能正股上涨了10%，转债只会涨1%。</p><p>由于有债底的保护向下的跌幅有限，通常来讲波动会比较小，适合作为防守仓位，同时提议下修的转债大多数都属于这个区域。</p><p>:star:<strong>C区：</strong>低价格低溢价率，一般价格低于120元，同时溢价率还在20%以下的转债可以分到这个区域。</p><p>例如<ahref="https://xueqiu.com/S/SH110080?from=status_stock_match">东湖转债</a>（117.802元+19.44%溢价率），<ahref="https://xueqiu.com/S/SH110047?from=status_stock_match">山鹰转债</a>（119.818元+15.03%溢价率）都在这个区域。</p><p>低价格意味着有债底保护跌幅有限，低溢价率意味着如果正股上涨，会很容易的带动转债的价格上涨。</p><p>理论上这是低风险爱好者最佳选择区域，但是由于大众对转债的认知越来越深入，目前还这个区域的转债，未来的预期回报率相对于之前会有所降低，但是也仍然值得配置一部分仓位。</p><p><strong>D区：</strong>高价格低溢价率，一般价格高于130元，同时溢价率还在30%以下的转债可以分到这个区域。</p><p>例如<ahref="https://xueqiu.com/S/SH113047?from=status_stock_match">旗滨转债</a>（134.582元+28.69%%溢价率），<ahref="https://xueqiu.com/S/SZ123166?from=status_stock_match">蒙泰转债</a>（135.558元+22.28%溢价率）都在这个区域。</p><p>高价格意味着没有有债底保护，但是低溢价率意味着如果正股上涨，会很容易的带动转债的价格上涨。</p><p>有很多有潜力的转债都会在这个区域，如果对转债比较熟悉并且愿意承受一定的波动风险，属于这个区域的转债也许会带来不错的收益。</p><h2 id="如何挑选容易上涨的转债"><strong>04如何挑选容易上涨的转债</strong></h2><p>除了用价格和溢价率对转债进行一个简单的区分，进一步考虑下面这几点也对我们筛选潜在涨幅较大转债会有帮助。</p><h3 id="剩余规模"><strong>4.1 剩余规模</strong></h3><p>下图给出了12月19日转债剩余规模的统计结果。不难发现市场上接近70%的转债规模在10个亿以下。所以只要我们把规模限定到10亿以内就可以覆盖到大部分转债。</p><figure><img src="https://xqimg.imedao.com/185de5e62aa4709c3fd40565.png!800.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>可转债的剩余规模越小，炒作的价值就越高，例如那些高价格高溢价的妖债，剩余规模都在1亿左右。</p><p>所以当我们在筛选转债的时候，剩余规模小的转债（小盘债），是一个加分项。</p><h3 id="热门行业概念"><strong>4.2 热门行业概念</strong></h3><p>A股的尿性就是喜欢炒作概念，无论是信创，<ahref="https://xueqiu.com/S/CSI931582?from=status_stock_match">数字经济</a>还是<ahref="https://xueqiu.com/S/SH000941?from=status_stock_match">新能源</a>又或者医药，总要带一点概念，这样炒作才算得上师出有名，庄家也会根据热点信息来借势炒作。</p><p>一般像医药、科技这些行业未来的想象力空间比较大，概念也多，就容易被炒，所以是一个加分项。</p><p>而银行类的转债，本身没什么热点，规模也大，基本上是很难走出大行情，还没有回售保底的条款，所以我们一般不会去持有银行类的转债，唾。</p><h3 id="历史波动率"><strong>4.3 历史波动率</strong></h3><p>被炒作过的转债热度会比没有被炒作过的高，如果再次炒作会更容易的吸引到更多的资金进来。</p><p>下面这张图就是小岛自己做的转债热力图，把转债按照板块分类，方块面积越大说明最近这只转债的历史波动率比较高。</p><figure><img src="https://xqimg.imedao.com/185de5e482a470963fe86d79.png!800.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>所以曾经被炒作过的，未来被再次炒作的概率更大。在选债的时候考虑历史波动率比较大的转债，同样是一个加分项。</p><h2 id="可转债的量化策略"><strong>05 可转债的量化策略</strong></h2><p>什么是量化策略？指的是使用数学模型和统计学方法来进行投资决策的策略。通常包括使用大量历史数据来建立预测模型，并使用<ahref="https://xueqiu.com/S/CSIH30182?from=status_stock_match">计算机</a>程序来执行交易，用于多种投资领域，例如股票、债券、外汇等。</p><p>通俗的来讲你有一个好的想法或者是好的选股经验，可以通过历史数据来模拟买卖，看一下你的想法在过去的行情中实际表现如何，如果验证之后在过去的表现较好，那么我们会期望该组合在未来的一段时间同样表现较好。</p><h3 id="三低一高策略"><strong>5.1 三低一高策略</strong></h3><p>就比如我们前面总结了剩余规模、热门概念、历史波动率对转债是加分项。</p><p>那么我们就可以按照这个思路，设置一个合理的价格和溢价率范围，针对于不同的因子设置不同的参数，然后用程序进行模拟买卖，经过多次测试后找到一个相对比较好的结果。</p><figure><img src="https://xqimg.imedao.com/185de5e497b4f7573fe2153a.jpg!800.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>18年1月1日到现在累计净值7.49，也就是说18年投入了100元，交给程序自己去卖卖，到现在会得到749元。</p><figure><img src="https://xqimg.imedao.com/185de5e4bbd470973fd7cca3.jpg!800.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>总的来说除了2019年小幅跑输，不过对于属于大盘股牛市的年份来说也情有可原，其他年份都大幅跑赢，从历史模拟买卖的角度来看收益效果显著。</p><p>每天运行程序之后会自动给出程序当天的买入卖出操作，以及目前的持仓转债，这对于我们实际的买卖来说非常值得参考。</p><figure><img src="https://xqimg.imedao.com/185de5e4fa34f7583fe634d2.jpg!800.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="偏离策略"><strong>5.2 偏离策略</strong></h3><p>在实际交易的过程中，有一些对市场研究比较多的人会发现，当一些股票刚开始启动上涨时，但此时由于可转债存在溢价率，实际上转债价格涨幅要小于正股涨幅，甚至没有上涨。</p><p>那么这时候正股涨的多，转债涨的少，溢价率就会降低，这种现象也叫做偏离现象，当溢价率降低到一定程度之后，例如20%以内，此时股价如果继续上涨，将会非常容易推动转债的价格上涨。</p><p>根据这个经验，找到股票已经开始上涨，而此时转债涨幅较小的进行买入，在未来可能会有比较不错的收益。</p><p>但是如果是人工每天去计算实在太麻烦，那么我们就可以用程序帮我们实现这个功能。</p><p>首先换算成程序能看懂的语言，例如：可转债5天涨幅-正股5天涨幅 +溢价率，根据算出来的数值对每个转债进行排名，取排名靠前的买入，然后用程序进行模拟买卖，就可以得到下面这个结果。</p><figure><img src="https://xqimg.imedao.com/185de5e52204f7593fde2284.png!800.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>18年1月1日到现在累计净值7.45，也就是说18年投入了100元，交给程序自己去卖卖，到现在会得到745元。</p><figure><img src="https://xqimg.imedao.com/185de5e53aa470983fe336ae.png!800.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>偏离策略和前面的三低一高策略收益率基本差不多，但是如果从年份来看，三低一高策略2020年表现最好，而偏离策略2021年表现最好。</p><p>从程序给出来的持仓转债以及买入和卖出操作来看，所筛选出来的标的和三低一高策略重合度也并不高。</p><figure><img src="https://xqimg.imedao.com/185de5e5fd74f75b3fe1c861.jpg!800.jpg"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>从历史数据模拟买卖来看，两个策略总体收益差不多，但在不同的行情中会有不同的表现，所以参考不同的策略选出来的转债结果，对于我们实际的买卖来说可以起到分散风险的作用。</p><p>截止到2023年1月20日，全市场总共有472只转债，相对于2018年110只的数量增加了4倍多，在转债数量越来越多的趋势中，如何更高效的挑选出更容易上涨的转债，量化程序可以有效的辅助我们做投资决策。</p><p>最后，可转债的投资策略还有很多，量化策略只是其中一种，有经验的老司机通过自己的经验或者分析进行买卖，同样也会有不错的收益，因为可转债本来就是一个胜率高，底部容易测算的投资品种。</p>]]></content>
    
    
    <categories>
      
      <category>投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原理</tag>
      
      <tag>投资</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>债券投资简明解释</title>
    <link href="/2024/10/28/2024-10-28-%E5%80%BA%E5%88%B8/"/>
    <url>/2024/10/28/2024-10-28-%E5%80%BA%E5%88%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="债券投资简明解释">债券投资简明解释</h1><h2 id="债券类别">债券类别：</h2><ul><li>国债（低风险，低利率）</li><li>地方债（中风险，中低利率）</li><li>金融债（低风险，低利率）比如逆回购</li><li>企业债（高风险，高利率）</li></ul><h2 id="债券收益计算方式">债券收益计算方式：</h2><blockquote><p>例：某公司发行债券（一般是面值<strong>100元</strong>），<strong>5年</strong>到期，利率<strong>6%</strong>。我们花了1000元购买了10张。</p><p>那么我们持有5年的收益就是：1000 * 6% * 5 = 300元 ；加上本金我们就有了1300 元</p><p>另一种收益方式就是在二级市场买卖债券（跟买卖股票类似）</p><p>:star:这里详细说明一下在二级市场上的买卖价格，因为有的高有的低：</p><ul><li>如果<strong>银行利率</strong>降低到 3% ，100 * 3% * 5 =15元，算上本金收益为 115 元。 而我们买的是 6% 的利率的债券可以获得 100 *6% * 5 = 30元，算上本金收益为 130 元。 这种情况下，就会有人以高于 100元的价格购买债券，但是不会高于115元，因为130-115=15元，加上本金115元和银行利率一样了，所以人们愿意购买的价格一般为115元以下，比如 110元。仔细看就会发现这里面有15元的差异。</li><li>另一种情况就是，企业经营差，投资者担心公司破产问题，其债券价格就会低于初始面值100元，比如60元。这种情况下，如果你对企业资产负债表有更好的了解，觉得这个公司不会破产，那么你就会获得每张债券40元的额外收益：40+ 30 + 100 = 170 元，那么这5年的综合收益就会达到 70% 。</li></ul></blockquote><h2 id="债券风险和购买注意点">债券风险和购买注意点</h2><p>企业债券，如果企业破产，我们也会优先与普通股得到偿还，但一般是以折价的方式偿还我们的本金，简而言之就是我们亏损了。:zap:但也有完全无法偿还的情况。</p><ol type="1"><li>期限</li><li>收益率</li><li>购买价格</li><li>风险评级（实际上就是看兑付利息是否守信），这个一般会有机构给出评级</li><li>担保事项，注意企业债券是否有担保人，有担保人的企业债相对于没有担保人的风险要小一点点。</li></ol>]]></content>
    
    
    <categories>
      
      <category>投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原理</tag>
      
      <tag>投资</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>价值评估读书笔记</title>
    <link href="/2024/10/26/2024-10-26-%E4%BB%B7%E5%80%BC%E8%AF%84%E4%BC%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/10/26/2024-10-26-%E4%BB%B7%E5%80%BC%E8%AF%84%E4%BC%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1id="价值评估公司价值的衡量与管理">价值评估：公司价值的衡量与管理</h1><hr /><p>这本书是基于普通的经济学原理写成的。</p><h2 id="经济学原理">经济学原理：</h2><ul><li>人们面临权衡取舍</li><li>某种东西的成本是为了得到它所放弃的东西的价值——机会成本</li><li>理性人考虑边际量——决策者会在边际效益大于边际成本时采取行动</li><li>人们会对激励做出反应</li><li>贸易使每个人的状况变得更好</li><li>市场是组织经济活动一种好方法</li><li>政府有时可以改善市场结果</li><li>一国的生活水平取决于该国的生产率</li><li>超发货币会引起通货膨胀</li><li>社会面临通货膨胀和失业之间的权衡取舍</li></ul><p>:star:<strong>这本书的观点</strong>：公司只要能为股东创造真正的经济价值，就能兴盛。公司是通过资本投资并取得高出资本成本的回报来创造价值的。</p><p>核心原理?</p><ul><li>:star:<strong>公司通过进行资本回报率高于资本成本的投资创造价值</strong></li><li><strong>在高回报率投资项目上投入的资本越多，公司创造的价值越大</strong></li><li><strong>资本回报超过资本成本，增长越快，创造的价值越大</strong></li></ul><p>公司是如何运用这些原理提高价值？</p><ul><li>通过绩效管理提升投入资本回报率和增长率</li><li>通过兼并、收购和剥离来创造价值</li><li>利用资本结构来支持价值创造</li><li>与投资者有效沟通以保证公司的股价反映其内在价值</li></ul><p>原理的实用途径有哪些？</p><p>本书源于麦肯锡顾问的一本手册。作者认为公司的管理者掌握价值评估技能是做好公司的先决条件，他们必须理解价值。作者希望通过本书帮助企业管理者更好的理解：</p><ul><li>如何根据对每项战略选择的价值估算，在可供选择的经营战略中做出决策</li><li>如何制定公司的业务组合战略。</li><li>评价主要的交易，包括收购、剥离和重组</li><li>改进公司的绩效管理体系</li><li>设计有效的资本结构</li></ul><h2 id="这本书的结构">这本书的结构：</h2><ul><li>第一篇，介绍了价值创造的基本原理——原理</li><li>第二篇，分步骤介绍了公司的价值评估的方法——方法</li><li>第三篇，将价值创造的原理应用于管理问题——应用</li><li>第四篇，介绍了较为复杂的估值问题和特殊案例——高级应用</li></ul><h2 id="第一篇-价值的基础原理">第一篇 价值的基础（原理）</h2><p>根据上面的介绍，我们看一看有哪些原理。</p><ul><li>由于股市热衷于关注短期盈利的心里，<strong>企业领导人面临公司短期绩效和长期健康之间的权衡取舍困境</strong></li><li>专业的投资者采用<strong>基本面分析</strong>和<strong>折现现金流模型（他们假设公司未来产生的现金流和利润决定了公司股票的价格）</strong>作为公司估值的计算标准</li><li>提到了本书的核心观点：企业为股东创造真实经济价值的过程中实现自身的茁壮成长</li><li>:star:<strong>公司通过进行资本回报率高于资本成本的投资创造价值</strong></li><li><strong>在高回报率投资项目上投入的资本越多，公司创造的价值越大</strong></li><li><strong>资本回报超过资本成本，增长越快，创造的价值越大</strong></li><li>DCF<strong>现金流折现方法</strong></li></ul><p>作者的观点：从长期看，股票市场确实是在追寻公司和经济的基本绩效。当企业、投资者和银行无视经济学原理时，市场就会偏离基本面。<strong>简而言之就是股价是跟随公司基本面的变动而变动的，时有偏离，但不会长久偏离。</strong></p><p>:bulb:1980——1999牛市背后的要素有三个：盈利的增长、利率及通货膨胀率的下降、大市值股票的出现。</p><p>总结：<strong>DCF等于经济利润的现值，ROIC和增长率驱动倍数。</strong><span class="math display">\[ROIC=\frac{净利润}{净资产+有息负债}\]</span></p><p>WACC加权平均资本成（利息和股息等）本计算公式：</p><ul><li>WACC：加权平均资本成本</li><li>K<sub>e</sub>：公司普通权益资本成本（普通股成本就是股息）</li><li>K<sub>d</sub>：公司债务资本成本（有息负债的利息）</li><li>W<sub>e</sub>：权益资本再资本结构中的占比（净资产占总资产的比例）</li><li>W<sub>d</sub>：负债占总资产的比例</li><li>T：所得税率</li></ul><p><span class="math display">\[WACC=(k_e*w_e)+(k_d*[1-t]*w_d)\]</span></p><h2 id="第二篇-核心估值技巧方法">第二篇 核心估值技巧（方法）</h2><p>本篇学习如何在实际操作中分析和评估一个公司的价值。所使用的方法是：<strong>企业折现现金流</strong>、<strong>折现经济利润</strong></p><p>:star:<ahref="../资产/公司分析（简化）终2021.xls">企业现金流折现模型</a>：<code>净利润+折旧+经营性现金净流量-资本支出-无形资产和商誉+其他营业性资产减少或增加-投资总额</code>这个只是一年的，估值的话需要计算不同的年份，比如5、7、10年等，计算这些年份时需要用到<strong>折现率（10%）</strong>，就是未来的钱现值是多少。一般我们用的是<code>10%</code>左右。然后再加总就是你估计企业未来多少年的现金流总和（也就是企业的价值），再除以总股本，就是大概的每股价值了，这是一个区间，并不是一个单一的数值。比如：<code>20---40</code>这个价值区间，股价低于最低的就是低估，高于最高的就是高估，中间的是合理的价值。</p><p>:star:<strong>经济利润估值模型</strong>：这个模型主要测算公司在单一期间所创造的价值。<strong>投入资本为总资产</strong>。也就是比较大公司与小公司的差距，因为光看增长率很容易陷入误区，100亿创造10%和10亿创造30%是有很大的差别。</p><p>公式为：<spanclass="math inline">\(经济利润=净利润-（投入资本*WACC）\)</span></p><p><strong>调整现值模型</strong>：这个模型把经营价值分成两部分：一部分是把公司的所有资本全部当做权益资本计算得出的经营价值，另一部分是由债务融资所形成的税盾的价值。<code>税盾：指可以产生避免或减少企业税负作用的工具或方法</code></p><p>公式为：<spanclass="math inline">\(调整现值=把公司所有资本全部当做权益资本计算得出的企业价值+税盾的现值\)</span></p><p><strong>资本现金流模型</strong>：当一家公司有目的地把负债比率保持在某个目标水平上时，自由现金流和利息税盾都以无负债的权益资本成本折现。其中：</p><ul><li>自由现金流：FCF</li><li>利息税盾：ITS</li><li>无负债的权益资本成本：k<sub>u</sub></li></ul><p>公式为：<span class="math inline">\(V=PV（资本现金流）=\sum_{t=1}^\propto \frac{FCF_t+ITS_T}{(1+k_u)^t}\)</span></p><p>后面还有权益现金流估值模型、基于折现现金流的其他方法等等，这些并不常用，最常用的就是企业现金流折现模型和经济利润估值模型。</p><p>总结：<strong>在所有的估值工具中，企业折现现金流是效果最好的方法，还有一种倍数分析法也应该留意。这种分析法是总资产和净利润的增长率，就是ROIC和ROE的增长率。</strong></p><h2 id="第三篇-实现价值应用">第三篇 实现价值（应用）</h2><p>这一章将从管理的角度来看待价值创造，探讨的主题有以下几个：</p><ul><li><p>通过绩效管理提升投入资本回报率和增长率</p><blockquote><p>收入增长率和投入资本回报率是衡量历史绩效最好的指标。</p><p>公司健康指标解释了财务结果是怎样实现的，并提供了对未来绩效的深入见解。.</p></blockquote><pre><code class=" mermaid">graph LR内在价值(内在价值)--&gt;长期增长(长期增长)内在价值(内在价值)--&gt;ROIC(ROIC)内在价值(内在价值)--&gt;资本成本(资本成本)长期增长(长期增长)--短期指标--&gt;销售生产率(销售生产率)ROIC(ROIC)--短期指标--&gt;经营成本生产率(经营成本生产率)ROIC(ROIC)--短期指标--&gt;资本生产率(资本生产率)销售生产率(销售生产率)--中期指标--&gt;商业健康(商业健康)经营成本生产率(经营成本生产率)--中期指标--&gt;成本结构健康(成本结构健康)资本生产率(资本生产率)--中期指标--&gt;资产健康(资产健康)商业健康(商业健康)--长期指标--&gt;核心业务&#123;核心业务和增长机会&#125;成本结构健康(成本结构健康)--长期指标--&gt;核心业务&#123;核心业务和增长机会&#125;资产健康(资产健康)--长期指标--&gt;核心业务&#123;核心业务和增长机会&#125;</code></pre><blockquote><p>:star:绩效管理：公司建立价值创造理念、澄清公司短期和长期价值驱动因素、制定员工相信并可以实现的挑战目标、实施基于事实绩效评估并有效激励员工。</p></blockquote></li><li><p>通过兼并、收购和剥离来创造价值</p><blockquote><p>通过并购创造价值：针对每个公司、协同效应和合并后的公司建立模型，直至得出<strong>自由现金流</strong>。</p><p>这一套下来使你对收购能否为股东创造价值会有一个清晰的认识。</p></blockquote></li><li><p>利用资本结构来支持价值创造</p><blockquote><p>如果业务单元对其他所有者的价值较高，或在其他所有权结构中的价值较高，则剥离将创造价值。例如，母公司文化为成熟业务所主导，从而限制了创新活动。</p><p>剥离绩效不善的业务，可以避免承担其进一步恶化所导致的直接成本。</p></blockquote></li><li><p>与投资者有效沟通以保证公司的股价反映其内在价值</p><blockquote><p>通过理解公司价值，理解公司现在和潜在投资者并与之进行沟通，可以提高公司价值与其内在价值的一致性。</p></blockquote></li></ul><h2 id="第四篇-高级的价值评估问题高级应用">第四篇高级的价值评估问题（高级应用）</h2><p>作者评估的公司估值低于单一业务的同类公司时，原因主要是公司的业务单元相对于单一业务的同类公司而言，其增长率或资本回报率较低。换句话说，存在一个绩效折扣，而不是业务多样化或企业集团化折扣。</p><p>根据各部分业务对多业务公司进行估值时，依据的也是企业折现现金流和折现经济利润，但有几个独特的问题：</p><ul><li>创建业务单元的财务报表</li><li>估计每个业务单元的资本成本</li><li>单独评估每项业务，对各业务单元加总，并解释结果</li></ul><p>经济利润和关键价值驱动因素公式：<spanclass="math inline">\(V=IC_0+\frac{经济利润}{WACC-g}\)</span>，根据这个公式，公司的企业价值（内在价值）等于投入资本的账面价值加上所有未来经济利润的现值。</p><ul><li>IC：当期投入资本</li><li>经济利润：<spanclass="math inline">\(经济利润=净利润-（投入资本*WACC）\)</span></li></ul><p>经济利润的折现值等于自由现金流的折现值：<spanclass="math inline">\(V=IC_0+\sum_{t=1}^\propto\frac{经济利润_t}{(1+WACC_t)}\)</span>，公司的企业价值等于投入资本的账面价值加上所有未来经济利润的现值。</p>]]></content>
    
    
    <categories>
      
      <category>投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>投资思维</title>
    <link href="/2024/10/26/2024-10-26-%E6%8A%95%E8%B5%84%E6%80%9D%E7%BB%B4/"/>
    <url>/2024/10/26/2024-10-26-%E6%8A%95%E8%B5%84%E6%80%9D%E7%BB%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="投资思维">投资思维</h1><hr /><h2id="一如何做出投资决策如何确定企业的内在价值">一、如何做出投资决策？如何确定企业的内在价值？</h2><p>巴菲特举了一个例子：</p><blockquote><p>我们从这里向北走了30英里，我们发现那里的农场每英亩可以生产120蒲式耳的玉米，每英亩可以生产45蒲式耳的大豆，我们知道化肥的成本、收入的税收成本，我们也知道我们需要向农民支付多少钱才能真正完成相关的工作。然后我们会得到一些我们可以用相当保守的假设得出的每英亩的利润。当你通过计算，你可以每英亩赚70美元而无需自己干更多的工作</p></blockquote><p><strong>那么问题的关键就在于，为这70美元你花了多少钱？以及你是否认为，随着时间的推移，你的产量会更高一点吗？农作物价格会随着时间的推移而上涨吗？农业的前景会变得更好一些吗？</strong></p><p>如果你综合来看，现在可能有7%的回报就很棒了，那你相当于觉得每英亩1000美元<code>70/7%</code>的价格就很好，如果此时农田卖900美元，那么你会有一个买入信号，如果他的售价是1200美元，你就会去看别的东西。</p><p><strong>努力弄清楚我们正在研究的那些企业将生产什么，要做到这一点，我们必须了解他们的竞争地位，我们必须了解业务的动态。</strong></p><p>我们必须能够展望未来，有些生意你不能看得很远，那就放弃它们。</p><p>你可能只对很少几个企业有洞察力，我的意思是，如果我们离开这里，走过一个<ahref="https://xueqiu.com/S/MCD?from=status_stock_match&amp;xueqiu_status_id=166878168&amp;xueqiu_status_source=statusdetail&amp;xueqiu_private_from_source=0105">麦当劳</a>的摊位，你会决定为那个<ahref="https://xueqiu.com/S/MCD?from=status_stock_match">麦当劳</a>的摊位支付100万美元，还是300万美元，你会想到有多大可能会有更多的竞争，麦当劳是否会改变你的特许经营安排，人们是否会继续吃汉堡，你知道，以及各种各样的事情。你可能会对自己说，<ahref="https://xueqiu.com/S/MCD?from=status_stock_match&amp;xueqiu_status_id=166878168&amp;xueqiu_status_source=statusdetail&amp;xueqiu_private_from_source=0105">麦当劳</a>的这个摊位可能会在几年内赚到多余X的钱，因为随着时间的推移，价格会略有上涨。这就是投资的全部，你必须知道你在做什么，你必须知道你什么时候超越了你的能力圈，关于投资我没有更好的办法。</p><p>芒格：</p><blockquote><p>你必须认识到，当你试图确定内在价值和安全边际之类的东西时，不存在任何简单的方法可以机械地应用在所有公司。就像没有任何计算机，能让所有按下其按钮的人变得富有。从定义上来说，这将是一个需要你用多种技术和模型来玩的游戏，因此经验是非常有用的。</p></blockquote><p><strong>伟大的投资者不能速成，就像伟大的骨肿瘤病理学家不能速成一样，这需要很多经验，这就是为什么很早开始是有帮助的。</strong></p><blockquote><p>我们从来没有任何系统能够对所有企业的价值做出正确的判断。我们几乎把所有的决定都扔进了太难的一堆，我们只是筛选出一些我们可以做出的容易的决定，这是一个比较的过程。如果你正在寻找一种在任何时候都能正确评估所有投资的能力，我们帮不了你。</p></blockquote><h2 id="二估值体系框架郑泉">二、估值体系框架（郑泉）</h2><p>这个估值体系框架将通过提出问题，并通过收集资料回答问题的方式进行。框架会提出几个问题，在层层深入研究：</p><ul><li>公司生产什么产品</li><li>公司现在属于什么阶段（初创、成长中、成熟、夕阳），对于每个阶段要有不同的要求</li><li>公司所处行业近5年的变化（了解公司在行业中的竞争地位）</li><li>近5年盈利变化（增长、负增长）财务分析</li><li>公司文化（高管口碑）</li><li>公司估值（对不同行业用不同方法进行估值）</li><li>公司的投资评价（预期投资收益），自由现金流评估</li></ul><h2 id="三巴菲特估值计算方法">三、巴菲特估值计算方法</h2><ul><li><p>选股标准</p><blockquote><p>巴菲特会问未来12个月会有多少家公司到15倍PE？有多少家5年后赚得更多（置信区间90%）？有多少家会达到7%的复合增长率（置信区间50%）？</p></blockquote></li><li><p>对确定性的理解</p><blockquote><p><strong>自由现金流</strong>：这个是企业账面可以确定的。C</p><p><strong>增长速度</strong>：这个是根据具体企业来估算的，不同的企业有不同的增长率---置信区间（可信度），简而言之就是要问，增速是多少，增长确定性有多高（就是可信度）。g</p><p><strong>折现率</strong>：增长率确定性高的企业给定折现应相应的低一点，确定性不高的折现相对给高点。r</p><p>永续增长的企业估值=<span class="math inline">\(C/(r-g)\)</span></p></blockquote></li></ul><p>15倍市盈率意味着买入当年的收益率6.67%，与前一笔投资10%年化收益差距很大，但这笔投资里企业可以成长，即此后年份的收益率会越来越高。如果此后企业能保持7%的增长，那么第5年的收益率<code>6.67%*（1+7%）^5=9.35%</code>，第10年期的收益率达到<code>6.67%*（1+7%）^10=13.11%</code>，整个十年间的累计收益率为98.55%（忽略资金的时间成本），也相当于十年回本，折合年化收益率约10%（简化计算，可以直接取6.67%和13.11%的平均数）</p><p><strong>所以，“15倍PE和7%增长的企业”和“10倍PE无增长的企业”基本等价，大致可以理解为巴菲特内心感到舒服的投资是“十年回本”。这就是巴菲特的估值逻辑，尽管巴菲特从低估值的烟蒂进化而来，但没有放弃内心的预期收益率要求，这个15倍PE是巴菲特愿意为“成长”所付出的溢价。</strong></p><p><strong>因此，巴菲特选择15倍市盈率这个买入标尺，是隐含了一个很强的预期，即未来10年企业能持续7%的年化增长——切不可忘记，这一切建立在前一部分讨论的确定性的基础之上。</strong></p><p>例：</p><blockquote><p>早期巴菲特以净资产折扣价买入烟蒂股，后来进化到以合理价格买入优秀企业的策略，本质是他愿意给予企业的成长一定的溢价。如果你有较高的把握确信<strong><ahref="https://xueqiu.com/S/SH600519?from=status_stock_match">茅台</a></strong>未来10年能以15%的速度增长，</p><p>第10年的收益率将达到<code>4%*（1+15%）^10=16.18%</code>，算术平均匡算出十年的合计收益率<code>[(4%+16.18%)/2]*10=100%</code>。这样，你还觉得25倍的茅台估值贵吗？</p></blockquote><p><strong>总结：</strong></p><ol type="1"><li>买的便宜，即使是好的企业，也轻易不在<code>15</code>倍市盈率以上出手。</li><li>追求成长和置信度，其实是现金流折现思维的一种应用。巴菲特愿意为有成长的企业支付溢价，投资这门学问的本质就是判断成长和确定性的艺术，也是如何对“成长”进行估值的艺术。</li><li>机会成本是最重要的决策依据，15倍PE和7%增长约等于10倍PE的无增长，后者可思维巴菲特的机会成本。</li><li>确定性从哪里来？客观方面要先找到好的商业模式，业务简单、护城河深、业绩可预测性强；主观方面深入研究基本面，探寻规律和真相，寻找不容易被打断的强逻辑。</li></ol><h2 id="收益率估值思维">收益率估值思维</h2><p>意思就是你买的股票数量乘以每股收益，然后在除以你买的成本。看看实际收益率是多少。分红多少。</p><p>这个思维的核心就是把每股收益当做自己应得的利润，分红作为现金流。</p><h2 id="彼得林奇投资思维分享">彼得林奇投资思维分享</h2><p>如果你没有办法在10分钟内向一个小孩解释清楚你为什么要买这只股票，那么你最好别买。</p><h2id="雪球市赚率公式-----roe大于15才考虑">雪球市赚率公式-----ROE大于15%才考虑</h2><h3 id="修正公式">修正公式</h3><p>适用于国内普通股</p><p>PR=PE*N<code>/</code>ROE<code>X</code>100</p><p>参数解释：</p><ul><li><p><strong>PR：市赚率</strong></p><blockquote><p>这个结果为1时是合理估值，小于1时为低估，大于1时为高估</p><p>当这个结果为0.5以下是，就是巴菲特说的4角买1元的时候</p></blockquote></li><li><p><strong>N：修正系数。股利支付率=税前每股股利/当年每股收益</strong></p><blockquote><p>股利支付率≥50%的企业，修正系数为1.0（50%除50%）</p><p>股利支付率≤25%的企业，修正系数为2.0（50%除以25%）</p><p>50%＞股利支付率＞25%的企业，例如40%的企业，修正系数为1.25（50%除以40%）</p></blockquote></li><li><p><strong>PE：市盈率</strong></p></li><li><p><strong>ROE：净资产收益率</strong></p></li></ul><h3 id="第一公式">第一公式</h3><p>适用于普通股</p><p>PR=PE/ROE</p><h3 id="第二公式">第二公式</h3><p>在投资周期股时，可以把<strong>当期PB和多年ROE平均值代入第二公式</strong>，从而计算出周期股的市赚率估值</p><p>PR=PB/ROE<sup>2</sup></p><h2 id="修正现金流">修正现金流</h2><p><strong>简而言之就是当ROE在10%~33%之间时，使用市赚率估值比较准确，否则就是现金流估值比较准确</strong></p><blockquote><p><strong>当ROE在10%～33%之间时，市赚率公式的计算结果竟与DCF十分接近。考虑到巴菲特投资的大部企业，</strong></p><p><strong>ROE均在10%～33%之间。这也意味着，巴菲特完全可以用心算的市赚率公式，来替代极为复杂的DCF计算器。</strong></p><p><strong>巴菲特宣称5分钟就能决定投资一家企业，看来也并非虚言！</strong></p><p><strong>上述研究表明，ROE小于10%或大于33%之时，市赚率容易失真或失效。</strong></p><p>ROE小于10%时，可以参考巴菲特投资B夫人案例。将其看作是债券，就比较容易理解了。</p><p>ROE为5%时，最多只能给到0.5PB估值。</p><p>ROE略微大于33%时，市赚率公式勉强可用。明显大于33%时（如<ahref="https://xueqiu.com/S/AAPL?from=status_stock_match">苹果</a>），</p><p>则需要用ROA替代ROE，市赚率公式则相应变成了<strong>PR=PE/ROA</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原理</tag>
      
      <tag>投资</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随机致富的傻瓜读书笔记</title>
    <link href="/2024/10/26/2024-10-26-%E9%9A%8F%E6%9C%BA%E8%87%B4%E5%AF%8C%E7%9A%84%E5%82%BB%E7%93%9C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/10/26/2024-10-26-%E9%9A%8F%E6%9C%BA%E8%87%B4%E5%AF%8C%E7%9A%84%E5%82%BB%E7%93%9C%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="随机致富的傻瓜读书笔记">随机致富的傻瓜读书笔记</h1><hr /><p>这本书的作者混迹股市多年，他平时对文学、哲学颇有见解；<strong>塔勒布</strong>把生活中的随机现象分解出基本的原理给我们看；作者还利用股市的随机现象为典型给我们讲了他的操作手法（珍惜每一次<strong>稀有事件----黑天鹅</strong>）。本书分为了三个部分来讲解。</p><h2 id="第一部分">第一部分</h2><p>这部分讲了概率分布上的不对称，黑天鹅事件的出现就是最典型的:star:<strong>偏态</strong>，现实意义就是如果失败的代价过于沉重、难以接受，那么这件事成功的概率有多高根本无关紧要。</p><p>比如说，在自家游泳池溺死的概率远远大于在恐怖袭击中死亡的概率，但民众对政府的反恐政策的关注却远胜于游泳池，就是由于恐怖袭击的可能性虽然小，但是出现恐怖袭击的后果却是民众不能承受的。</p><p>这部分也说了全靠运气得来的东西终究还是可能被运气取回，只有靠实力、打拼换来的幸福我们才能享受得心安理得。</p><p>作者用了两个背景各殊的交易员讲了一个例子：塔利波和约翰，塔利波是统计学博士，学术功底深厚，理性地规避股市风险，但他的风头却被学养、心思均和健身教练没两样的约翰盖过，约翰比他晚入行5年，收入却是他的10倍，但是最后约翰因为忽视风险，投资过于激进，丧失了全部，塔利波却因为谨慎行事，而存活了下了，并保留了所得。</p><p>用投资的思维理解的话就是，如果你关注概率很大的事情，其他人也会同样关注，你所获得的收益不过是大家的平均收益而已。如果遇到黑天鹅事件要认真对待并且珍惜，因为人一辈子怕是也遇不到几次。危机危机，有危就有机。所有人觉得机会很大的时候常常伴随着很大的危险；所有人觉得危险很大的时候，常常伴随着很大的机会。</p><p>中国有句古话是：福兮祸所伏，祸兮福所倚。</p><h2 id="第二部分">第二部分</h2><p>这部分讲了概率中的一个经典现象——:star:<strong>幸存者偏差</strong>，由于我们只看到成功者，而由此形成的对机遇的歪曲看法。</p><p>比如说，我们常会认为长得英俊漂亮的人薪水会比较高，其实这是因为我们经常只会注意到那些薪水比较高的人，或者说那些薪水比较高的人容易被我们注意到罢了。</p><p>这部分举了一个很有名的例子，就是让很多很多的猴子放在打字机前，他们肯定会有那么一两只会打出一字不差的《伊利亚特》叙事诗。换句话说，从事商业的人数越多，其中某个人单靠机遇便能有惊人表现的可能性就越高。</p><p>作者还引用了<strong>生日悖论</strong>，随便找一个人，你和他生日是同一天的概率是<code>0.27%</code>，可是如果一个房间内有<code>23</code>个人，有两个生日相同的概率高达<code>50%</code>，在生活中，我们随处遭遇着幸存者偏差，把一个变量的极大值分布误作为那个变量本身。</p><p>用投资的思维看的话，就是我们通常只会关注在投资领域成功的投资者，比如巴菲特等，我们会对我们也可以成为像他一样成功的投资者产生误解，就连巴菲特自己都说过，他只不过是中了<strong>卵巢红利</strong>（生在一个对的地方，并做了一些对的事情）。我们只要仔细观察我们的股市就会发现，中国股民有接近3亿，但是成功的寥寥可数。</p><h2 id="第三部分">第三部分</h2><p>这部分讲到了一个人性的问题，就是:star:<strong>路径依赖</strong>，这个有点像物理学上的“惯性”，人们过去做出的选择决定了他们现在及未来可能的选择。作者还用索罗斯说了，他这类股市大鳄完全不受过去的行为约束，摆脱了路径依赖，每一天对他们来说都是一张白纸。</p><p>作者举了一个有点带有迷信的例子，这个是我们每个人都会有那么一点点的东西。</p><p>塔勒布这样谙熟概率的人也会做出不合理的行为，他因为有一天上班时误打误撞在一个街口下了车，而那天的操作组合赚了不少的钱，结果以后每天他都特意在那个街口下车，可见人类的本性是多么的根深蒂固。</p><p>用投资的思维理解的话就是，我们以前的成功并不能让我们以后也可以用同样的方法再次成功。</p>]]></content>
    
    
    <categories>
      
      <category>投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>投资最重要的事学习笔记</title>
    <link href="/2024/10/26/2024-10-26-%E6%8A%95%E8%B5%84%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/10/26/2024-10-26-%E6%8A%95%E8%B5%84%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E4%BA%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="投资最重要的事学习笔记">投资最重要的事学习笔记</h1><h2 id="star第一章-学习第二层次思维">:star:第一章 学习第二层次思维</h2><h3 id="什么是第二层次思维">什么是第二层次思维？</h3><p>要理解第二层次思维，要先知道什么是第一层次思维。</p><p>这里我们先理解什么是第一层次思维，我理解的第一层次思维就是<strong>大众共识</strong>，简单的说就是对于事物的表面认识，行为和反应、思考是和大众一样的。</p><p>那么第二层次思维呢？我理解为是和大众共识对立的或者是与众不同的，大家都认为是好的时候，不一定是好的，大家都认为是坏的时候，也不一定是坏的。</p><h3 id="第二层次思维是怎么运用的">第二层次思维是怎么运用的？</h3><ul><li><strong>第一层次思维说</strong>：这是一家好公司。让我们买进公司的股票吧。<strong>第二层次思维说</strong>：这是一家好公司，但是人人都认为它是一家好公司，因此它不是一家好公司。因为股票的估价和定价都过高，让我们卖出股票吧。</li><li><strong>第一层次思维说</strong>：会出现增长低迷、通货膨胀加重的前景。让我们卖出股票吧。<strong>第二层次思维说</strong>：前景糟糕透顶，但是所有人都在恐慌中卖出股票。我们应该买进。</li></ul><p>第二层次思维和第一层次思维之间的工作量差异是巨大的。第一层次思维者所需的只是一种对于未来的看法，譬如：公司前景是光明的，表示股票会上涨。而第二层次思维者则需要考虑更多的东西，比如：</p><ul><li>未来可能出现的结果会再什么范围之内？</li><li>我认为会出现什么样的结果？</li><li>我正确的概率有多大？</li><li>人们的共识是什么？</li><li>我的预期与人们的共识有多大的差异？</li><li>资产的当前价格与大众所认为的未来价格以及我所认为的未来价格相符的程度如何？</li><li>价格中所反映的共识心理是过于乐观还是过于悲观？</li><li>如果大众的看法是正确的，资产价格将会发生怎么样的改变？如果我是正确的，资产价格有会怎么样？</li></ul><h3 id="为什么要有第二层次思维">为什么要有第二层次思维？</h3><p>你不可能在和他人做着相同事情的时候期待胜出，如果你的行为是常规性的，你很可能就会得到常规性的结果（无论好坏）。只有当你的行为是非常规性的时候，你的表现才有可能是非常规性的，而只有当你的判断高人一等时，你的表现才会高于平均水平。</p><p>我们投资的目的不是达到平均水平，我们想要的是<strong>超越平均水平</strong>。因此，我们的思维必须比别人更好、更强有力、水平更高。其他投资者也许非常聪明、消息灵通，因此我们必须找出一种他们所不具备的优势。想他们所未想，见他们所未见，我们的反应与行为必须<strong>与众不同</strong>。简而言之，保持正确可能是投资成功的必要条件（无之者不然），但不是充分条件（有之必然），我们必须比其他人做的更加正确。</p><p>为了取得优异的投资结果，我们必须对价值有非常规性的并且必须是正确的看法。这并不容易。</p><p>很多人认为投资过程简单，没有第二层次思维的需要，甚至有的还不知道有第二层次思维的存在。所以很多人被误导了，相信人人都能成为一名成功的投资者。其实并不是人人都能成功的，现在的唯一好消息是，第一层次思维者的广泛存在使得第二层次思维者的可得收益增加了。为了持之以恒地获得优异的投资回报，我们必须成为第二层次思维的人。</p><h2 id="第二章-理解市场有效性及局限性">第二章理解市场有效性及局限性</h2><h3 id="什么是有效市场理论">什么是有效市场理论？</h3><p>有效市场假说最重要的结论是“你无法战胜市场”。只能取得和大众一样的收益。</p><h3 id="有效市场理论是怎么运用的">有效市场理论是怎么运用的？</h3><p>根据有效市场投资理论，人们有规避风险的本能，即人们普遍愿意承担更少的风险。想要他们进行风险性更高的投资，必须以更高的收益承诺来诱导。</p><p>为了获得更高的收益，他们唯一要做的就是进行高风险投资。这里其实有个悖论：<strong>如果可以指望通过高风险投资来实现高收益的话，那些投资其实就不是高风险了</strong>。</p><h3id="有效市场理论的局限性和无效市场理论的理解">有效市场理论的局限性和无效市场理论的理解？</h3><p>市场价格永远是正确的是不可能的。因为有效市场理论的观点或其运作方式都是<strong>主观性</strong>的。<strong>缺少客观性</strong>。恰恰就是这一点为无效市场理论奠定了基础。</p><p>没有一个市场是完全有效或无效的，它只是一个程度问题。但是我们要认识到，有效性并没有普遍到我们该放弃良好业绩的程度。今天存在的有效性并不意味着有效性会永远存在。</p><p><strong>认为市场无效性</strong>是杰出投资的必要条件。错误总会发生，有时候某些资产定价过低，有时候又定价过高。我们必须具有比其他人更深刻的洞察力，才能更多的买到定价过低的资产。</p><p>有效市场理论应提<strong>供信息辅助我们决策而不是控制决策</strong>。如果完全无视该理论，可能会犯下大错。</p><h2 id="star第三章-准确估计价值">:star:第三章 准确估计价值</h2><p>投资要想取得切实成功，<strong>对内在价值的准确估计是根本出发点</strong>。没有它，投资者任何取得持续投资成功的希望都仅仅是希望。</p><p>这里有一个词，就是<strong>资产的内在价值</strong>。我们常规或者说应该做的就是，以低于内在价值的价格买进，以更高的价格卖出。</p><h3 id="内在价值是什么">内在价值是什么？</h3><p>要了解内在价值是什么，我们要对投资股票或企业有一个基础的认识。一般方法可以被分为两种基本类型：</p><ul><li>基于公司特性的分析，就是基本面的分析。</li><li>基于证券自身价格行为的研究。</li></ul><p>简单来说投资者有两种基本选择：</p><ol type="1"><li>判断证券的内在价值并在价格偏离内在价值时买进或卖出</li><li>将决策完全建立在对未来价格走势的预期的基础上。</li></ol><p>公司的内在价值都是基于公司<strong>基本面</strong>来做分析的。理性的投资者或者是基于内在价值的投资者又分为两种：</p><ul><li>价值投资</li><li>成长型投资</li></ul><p>价值投资者的目标是得出证券当前的内在价值，并在价格低于当前价值时买进，而成长型投资者的目标则是寻找未来将迅速增值（公司内在价值增加）的证券。这两种投资者没有明确的界限，用一句话来说就是：<em>成长型投资关心未来，而价值投资强调当前，但不可避免地要面对未来。</em></p><p>这里我们可以大概知道了，公司的价值体现在，公司财力、资源、管理、商业模式、专利、人力资源、商标、增长潜力，以及最重要的——:star:<strong>创造收益和现金流的能力</strong>。</p><h3 id="如何估算内在价值">如何估算内在价值？</h3><p>这里书中没有给出明确的方法论。不过我自己对估算内在价值是有一定的学习的:smile:，所以这段内容是我自己的经验总结。方法有以下几种：</p><ul><li>现金流折现法（这种方法适用于现金流稳定的行业，比如消费、医药等）</li><li>市净率估值法（适用于银行）</li><li>PEV内含价值（这个指标适用于保险行业，因为这个行业的保单是负债但未来会转化为利润）</li><li>NAV估值法（这种方法适用于地产行业，就是净资产价值，包括土地储备等）</li><li>周期行业估值方法比较特殊，这里彼得林奇的方法是可取的，就是根据市盈率和市净率反着买，当市盈率高而市净率低的时候买入，当市盈率低而市净率高的时候卖出。这是因为低市盈率表示行业景气，那价格和价值都应该是体现了的，所以无法以一个很好的价格买到。</li></ul><p>巴菲特举了一个例子：</p><blockquote><p>我们从这里向北走了30英里，我们发现那里的农场每英亩可以生产120蒲式耳的玉米，每英亩可以生产45蒲式耳的大豆，我们知道化肥的成本、收入的税收成本，我们也知道我们需要向农民支付多少钱才能真正完成相关的工作。然后我们会得到一些我们可以用相当保守的假设得出的每英亩的利润。当你通过计算，你可以每英亩赚70美元而无需自己干更多的工作</p></blockquote><p><strong>那么问题的关键就在于，为这70美元你花了多少钱？以及你是否认为，随着时间的推移，你的产量会更高一点吗？农作物价格会随着时间的推移而上涨吗？农业的前景会变得更好一些吗？</strong></p><p>如果你综合来看，现在可能有7%的回报就很棒了，那你相当于觉得每英亩1000美元<code>70/7%</code>的价格就很好，如果此时农田卖900美元，那么你会有一个买入信号，如果他的售价是1200美元，你就会去看别的东西。</p><h3 id="为什么要估算内在价值">为什么要估算内在价值？</h3><p>我们的目的是以低于内在价值的价格买入，那么这个内在价值我们不知道或计算不准确的话就让我们无法看清我们买的到底是什么。</p><p>如果没有对价值的准确估计，那么我们可能会高价买进自以为的特价股，对于我们来说，任何取得持续成功的希望都仅仅是希望而已。</p><p>我们只有准确估算了内在价值才能在证券下跌或上涨的时候胸有成竹的买进或卖出。实际上只有准确估算了内在价值我们才能在一个下跌的市场上获利，通过学习上面两章，我觉得我们只要在上涨的市场中保持和指数差不多的涨幅，而下跌的市场中低于指数的跌幅，我们就已经胜过绝大部分投资者了。这里有几个基本要素要讲讲：<strong>我们必须了解内在价值；同时我们必须足够自信，坚定的持有股票不断在下跌过程中买进，即使价格已经跌倒似乎在暗示我们做错了的时候，还有最重要的是我们必须估算正确。</strong></p><h2 id="star第四章-价格与价值的关系">:star:第四章 价格与价值的关系</h2><p>成功的投资不仅仅在于“买好的”，还要“买得好”。</p><h3 id="价格与价值有什么关系">价格与价值有什么关系？</h3><p>在格雷厄姆所作的《聪明的投资者》中指出，<strong>价格是围绕价值上下波动的</strong>，我认为这是价格与价值的一般关系。</p><p>价格是怎么来的？这个问题毫无疑问的关系基本面价值，不过大多数情况还受到另外两个因素的影响：<strong>心理</strong>和<strong>技术</strong>。</p><h3id="价格与价值的关系是怎么运行的">价格与价值的关系是怎么运行的？</h3><p>我们除了要知道企业的内在价值（上一章所学）外，我们还要考察相对于资产价值的资产价格。</p><p>:star:建立：基本面——价值——价格之间的关系。</p><p>确定价值的关键是熟练的财务分析，而理解价格、价值关系及其前景的关键，则主要依赖对其他投资者思维的洞察。投资者心理几乎可以导致证券在短期内出现任何定价，而无论<strong>基本面</strong>如何。因此在这里我觉得我们必须投入时间和精力去了解<strong>市场心理</strong>。只有这样做，我们才会知道什么时候会有买入和卖出的好时机。</p><p>以公平价值的价格买进某种证券，那么你可以得到的也只是公平收益，这也就是“市场有效假说”的基本前提。如果我们对内在价值的估计是大概正确的，那么随着时间推移，资产价格将会与资产价值趋于一致。</p><h3id="为什么我们要知道价格与价值的关系">为什么我们要知道价格与价值的关系？</h3><p>这里有个重点是市场心理，也就是<strong>心理学</strong>。从买进证券的那一刻起我们就必须了解，基本面价值（内在价值）只是决定证券价格的因素之一，我们还要设法让心理和技术为我们所用。</p><p>在泡沫时期和暴跌时期，对市场势头的迷恋取代了价值和公平价格的观念，贪婪和恐惧会占据人们的心理取代智慧。</p><p>我们真正需要是知道的是，资产的<strong>内在价值的增长</strong>（就是公司业绩的上升）也会带动资产的价格上涨。但我们要警惕预测未来是个不太可靠的事情。</p><p>如果我们现在估算的内在价值是正确的，以低于其价值的价格买进现在看是好的，也有可能企业经营不善，其内在价值降低了，那么其价格也会降低，我们就会发现<strong>当初估算的价值低于现在的价格了</strong>，所以我们需要动态的调整我们的估算。</p><p>也就是说在所有可能的投资获利途径中，低价买进显然是最可靠的一种。但也要注意，我们可能错误估计了当前价值。或者可能会出现价值降低的事件，或者我们的态度与市场的冷淡导致证券以更低的价格出售。也可能价格与价值趋于一致所需的时间比我们想象的要长得多。</p><p>:star:低于价值的价格买进并非万无一失，但它是我们最好的机会。</p><h2 id="第五章-理解风险">第五章 理解风险</h2><p>风险意味着可能发生的事件多于确定发生的事件。</p><h3 id="风险是什么">风险是什么？</h3><p>风险意味着可能发生的事件多于确定发生的事件。在投资中风险定义为：首要的是:star:<strong>永久性损失的概率</strong>，但我们还应该认识其他的风险：</p><ul><li><strong>没有达到目标的风险</strong>：比如我们预期的每年8%的收益是我们日常开支的需求，我们投资的收益只有6%的收益，这就出现了风险。</li><li>业绩不佳的风险：收益跟不上指数。</li><li>职业风险：当资金管理者和所有者不是同一人的情况下，会出现管理者如果业绩不好怕失业而承担的风险。</li><li>非常规风险：也就是与众不同也是有风险的。</li><li>流动性风险：也就是资金的流动性，如果急需一笔钱开销，那么投资的资金就会出现风险。</li></ul><h3 id="怎么去理解风险">怎么去理解风险？</h3><p>风险很大程度上是一个见仁见智的问题。基本面弱的企业、业绩欠佳的企业的股票，如果买进的价格足够低，也能成为一项非常成功的投资。损失风险主要归因于心理过于积极，以及由此导致的价格过高。理论认为高收益伴随着高风险，但我们应该认识到，<strong>在以低于内在价值的价格买进证券时，高收益和低风险是可以同时实现的</strong>。</p><p>:star:判断风险的主要依据应该是<strong>价值的稳定性和可靠性</strong>，以及<strong>价格与价值之间的关系</strong>。</p><p>概率与结果之间存在巨大差异。可能的事情没有发生，不可能的事情却发生了。这是我们对于投资应该知道的最重要的事。</p><h3 id="为什么要理解风险">为什么要理解风险？</h3><p>投资只关乎一件事，就是应对未来。没有人能够确切地预知未来，所以风险是不可避免的。因此应对风险是投资中一个必不可少的要素。找到好的投资标的并不难，但是如果我们不能正确地应对风险，那么我们的成功是不可能长久的。应对风险主要有三步：</p><ul><li>理解风险</li><li>识别风险</li><li>控制风险</li></ul><p>为什么说风险评估是投资过程中必不可少的要素呢？主要有三个理由：</p><ul><li><strong>风险是件坏事</strong>，大多数头脑清醒的人都希望避免风险或将其最小化。</li><li><strong>在考虑某项投资时</strong>，投资决策应将风险以及潜在收益考虑在内。简单的讲，国债和企业债都是7%的收益，你肯定会选择国债。因为相比企业债，国债风险更小。因为买国债的人多，所以国债的价格一定会比企业债的价格高。</li><li><strong>在考虑投资结果时</strong>，收益仅仅代表收益，评估所承担的风险是必须的。要评估我们的收益是承担很小的风险还是很大的风险得来的。</li></ul><h2 id="第六章-识别风险">第六章 识别风险</h2><p>人们普遍认为，风险在经济衰退以及经济由盛转衰时增大，与此相反，认为风险在经济上升时增加，并且随着经济失衡的扩大在衰退期化为现实的想法，可能更好。</p><p>无论基本面有多好，人类的贪婪与犯错倾向都会把事情搞得一团糟。</p><p>承接上一章，我们要<strong>控制风险就需要识别风险，要识别风险就要理解风险</strong>。这里再说一下风险的定义：:star:风险意味着即将发生的结果的不确定，以及不利结果发生时损失概率的不确定。</p><h3 id="如何识别风险">如何识别风险？</h3><p>识别风险往往从投资者盲目乐观并因此对某项资产出价过高的时候开始。换句话说就是，<strong>高风险主要伴随高价格出现</strong>。无论是对被估价过高从而定价过高的单项证券或其他资产，还是对在看涨情绪支持下价格高企的整体市场，:star:<strong>在高价时不知规避反而蜂拥而上都是风险的主要来源</strong>。</p><p>我认为高风险和低预期收益不过是同一硬币的两面，二者都源自于高价格。因此，:star:<strong>洞察价格与价值之间的关系是成功应对风险的重要组成部分</strong>。<em>当市场价格被推高，以至价格意味着更多的损失而不是潜在回报时，风险就增加了。</em></p><p>普遍相信没有风险本身就是最大的风险。</p><h3 id="为什么要识别风险">为什么要识别风险？</h3><p>风险的实现远比感知风险来得简单粗暴。人们过高地估计了自己认识风险的能力，过低地估计了规避风险所需的条件；因此人们在不知不觉中接受了风险，由此促进了风险的产生。这也就是我们为什么要用<em>第二层次思维</em>来思考这个问题所在的原因了。</p><h2 id="第七章-控制风险">第七章 控制风险</h2><p>投资者的工作是以盈利为目的聪明的承担风险。能够出色的做到这一点，是最好的投资者与其他投资者之间的区别。</p><h3 id="如何控制风险">如何控制风险？</h3><p>无论风险控制取得怎样的成绩，在繁荣时期是永远也表现不出来的，因为风险是隐蔽的，不可见的。能观察到的是损失，而损失通常只在风险与负面事件相碰撞时才会发生。:star:重要的是我们要意识到，即使没有发生损失，风险也有可能存在。因此没有损失并不一定意味着投资组合是安全的。我们应该在繁荣时更加注意自己的投资组合，并观察它是低风险还是高风险。</p><p>这里有两个点值得一说：</p><ul><li>承担同样的风险，但收益比普通投资者高一些</li><li>获取同样的收益，但承担的风险比普通投资者小一些</li></ul><p>作者认为第二种是杰出投资者的表现。</p><h3 id="为什么要控制风险">为什么要控制风险？</h3><p>首先我们要明确一点，:zap:就是<strong>风险控制</strong>与<strong>风险规避</strong>之间的重要区别。风险控制是规避损失的最佳方法。反之，风险规避则很有可能会连同收益一起规避。</p><p>贯穿长期投资成功之路的，是风险控制而不是冒进。在整个投资生涯中，大多数投资者取得的结果将更多的取决于<strong>失败投资</strong>的次数及程度，而不是<strong>成功投资</strong>的程度，因为良好的风险控制是优秀投资者的标志。</p><h2 id="star第八章-关注周期">:star:第八章 关注周期</h2><p>牢记万物皆有周期是至关重要的。周期永远胜在最后。任何东西都不可能朝同一个方向永远发展下去。坚持以今天的事件推测未来是对投资者健康最大的危害。<strong>反者道之动</strong></p><h3 id="什么是周期">什么是周期？</h3><p>很少有事物是直线发展的。事物有进有退，有盛有衰。经济、市场和企业同样如此：<strong>起伏不定</strong>。</p><p>周期是自我修正的，周期的逆转不一定依赖外源性时间。周期的发展趋势本身就是造成周期逆转的原因。因此我又要提到我们的一句老话：<strong>祸兮福之所倚，福兮祸之所伏</strong>。</p><p>世界具有周期性的根本原因是人类的参与，人是情绪化并且善变的，缺乏稳定性和客观性。周期的极端性主要源自人类的情绪与弱点、主观与矛盾。</p><h3 id="怎么去关注周期">怎么去关注周期？</h3><p>作为投资者，我们应重点关注:radioactive:<strong>信贷周期</strong>，它具有必然性、极端波动性，也具有为适应它的投资者创造机会的能力。只要经济有微小的波动，就能导致信贷可得性的巨大波动，并对<strong>资产价格及其背后的整体经济</strong>造成巨大影响。</p><p>这个过程如下：</p><ol type="1"><li>经济进入繁荣期。资金提供者增多，资本基础增加。</li><li>坏消息极少，因此贷款风险与投资风险似乎“已经减少”。</li><li>风险规避消失。</li><li>金融机构开始扩大业务，通过降息、降准等提供更多资本。</li><li>资本提供者开始为不具备资格的借款人和项目提供资本，即资本投资项目的资本成本超过其资本收益最终导致没有资本收益。这时候————周期的上升部分就开始出现逆转。:exclamation:</li><li>损失导致借款人畏难回避。</li><li>风险规避增加，伴随着利率、信贷限制与条款要求的提高。</li><li>可得资本减少————在周期的谷底，只有资质最好的借款人才能借到资本。</li><li>企业迫切需要资本。借款人无法展期债务，导致债务违约及企业破产。</li><li>这一过程导致并加剧经济萎缩。</li></ol><p>还有一点比较重要，认为周期性已经结束所体现的思维方式，基于一个危险的前提——“<strong>这次是不同的</strong>”。这6个字应该警醒我们，或许对我们还预示着赢利的机会。<strong>因此当出现这种形式的错误时，具有识别它的能力是至关重要的</strong>。</p><h3 id="为什么要关注周期">为什么要关注周期？</h3><p>投资就像生活一样，完全有把握的事非常少。价值可以消失，预测可能出错，环境可以改变，“有把握的事”可能失败。但我们应该把握住两个概念：</p><ul><li>:star:法则一：多数事物都是周期性的。</li><li>:star:法则二：当别人忘记法则一时，某些最大的盈亏机会就会到来。</li></ul><p>证明“一切会更好”的最佳时机是存在的，那就是当市场触底、人人都以廉价抛售的时候。</p><p>危险发生在市场创记录地触及以往从未达到过的高点的时候。这种情况过去有，未来也将会再次发生。</p><p><strong>我们应该意识到，周期是永远不会中断的，并将这种认识转化为自身的优势</strong>。</p><p>:smile:<strong>我们无法预测，但我们可以准备</strong></p><h2 id="star第九章-钟摆意识">:star:第九章 钟摆意识</h2><p>当形式良好、价格高企时，投资者迫不及待地买进，把所有谨慎忘在脑后。随后，当四周一片混乱，资产廉价待沽时，他们又完全丧失了承担风险的意愿，迫不及待地卖出。永远如此。</p><h3 id="什么是钟摆意识">什么是钟摆意识？</h3><p>投资市场遵循钟摆式摆动：</p><ul><li>处于<strong>兴奋</strong>与<strong>沮丧</strong>之间</li><li>处于值得庆祝的<strong>积极发展</strong>与令人困扰的<strong>消极发展</strong>之间</li><li>因此，处于<strong>定价过高</strong>与<strong>定价过低</strong>之间</li></ul><p>这种摆动是投资世界最可靠的特征之一。当投资者风险容忍过度时，证券价格体现的是更高的风险而不是收益。当投资者过度规避风险时，价格体现出来的收益高于风险。</p><p>作者在这一章将投资的主要风险归结为两个：<strong>亏损的风险</strong>和<strong>错失机会的风险</strong>。简而言之就是当整体市场或单个企业过于热情的时候会出现亏损的风险，而当市场或单个企业过于冷淡的时候会出现错失机会的风险。:smile:理想状态下，投资者会使两者达到平衡。当钟摆摆动到最高点时，一种风险或另一种风险一次又一次的占据上风。</p><p>这里我们总结一下作者对钟摆的认识：</p><ul><li>理论上，恐惧与贪婪是两个极端，多数时候钟摆应处于两极之间，但它在中点停留的时间并不长</li><li>投资者心理是主要因素，在它的影响下，钟摆通常处于摆向端点或从端点摆回的过程中</li><li>钟摆不可能永远朝向某个端点摆动，或永远停留在端点处</li><li>与钟摆类似，投资者心理朝向某个极端的摆动，最终回成为促进反方向回摆的力量</li><li>自端点摆回的速度通常更快——因此，比朝向端点摆动的事件要短得多</li></ul><h3 id="怎么去利用钟摆意识">怎么去利用钟摆意识？</h3><p>牛市有三个阶段：</p><ul><li>第一阶段，少数有远见的人开始相信一切会更好。</li><li>第二阶段，大多数投资者意识到进步的确已经发生。</li><li>第三阶段，人人断言一切永远会更好。</li></ul><p>熊市也有三个阶段：</p><ul><li>第一阶段，少数善于思考的投资者意识到，尽管形势一片大好，但不可能永远称心如意。</li><li>第二阶段，大多数投资者意识到势态的恶化。</li><li>第三阶段，人人相信形势只会更糟</li></ul><p>一切都是相辅相成的。任何事件都不是孤立的或偶然的。相反，他们都是一定的循环模式的组成部分，是可以掌握并从中获利的。</p><h3 id="为什么要有钟摆意识">为什么要有钟摆意识？</h3><p>我们能够肯定的事情之一是，极端市场行为会发生逆转。相信钟摆将朝着一个方向永远摆动——或永远停留在端点的人，最终将损失惨重；了解钟摆行为的人则将受益无穷。</p><h2 id="第十章-抵御消极影响">第十章 抵御消极影响</h2><p>得到更多的渴望、担心错过的恐惧、与他人比较的倾向、群体的影响以及对胜利的期望——这些因素几乎是普遍存在的。因此它们对大多数投资者和市场都有着深远的影响。结果就是错误——频繁的、普遍的、不断重复发生的错误。</p><h3 id="消极影响有哪些">消极影响有哪些？</h3><ul><li><p><strong>贪婪</strong>（对财富或利润过度的或无节制的占有欲）</p><blockquote><p>对利润的渴望是驱动市场及整体经济运转的最重要的因素之一。:zap:危险就产生于<strong>渴望</strong>变成<strong>贪婪</strong>的时候。</p></blockquote></li><li><p><strong>恐惧</strong></p><blockquote><p>在投资领域，这个词不代表理性的、明智的风险规避。相反，恐惧就像贪婪一样，意味着过度。因此有时恐惧更像是恐慌。恐惧是一种过度忧虑，妨碍了投资者采取本应采取的积极行动。</p></blockquote></li><li><p><strong>自愿终止怀疑</strong>。这种情绪是的人们愿意接受任何能让他们致富的可疑的建议。在投资过程中需要大量的怀疑，而怀疑并不会导致投资损失。</p></li><li><p><strong>从众心理</strong>。即使群体共识存在显而易见的荒谬，也不坚持己见。不从众会感觉受到了排斥。从众的压力和赚钱的欲望致使人们放弃了自己的<strong>独立性和怀疑精神</strong>，将与生俱来的风险规避抛诸脑后，转而去相信毫无意义的东西。</p></li><li><p><strong>嫉妒</strong>。一个在孤立环境下感觉快乐的人，当他看到别人做的更好时，可能会变得痛苦不堪。在投资领域大多难以坐视别人赚钱比自己多这一事实。</p><blockquote><p>这里作者举了一个例子：一个防御型投资基金年收益16%，但是同行的23%令他沮丧不堪。但后来这只防御型基金只有3%的收益，而同行大多出现亏损，他反而兴高采烈。这很有意思。当16%的收益时他沮丧，而3%时他却很高兴。这就是人们都有与别人相比较的倾向，这种倾向会对投资过程产生不利的影响。</p></blockquote></li><li><p><strong>自负</strong>。就是在得到更好的收益时，要认清是自己的能力还是运气，这一点很多人容易搞混，认为运气是实力的一部分。而我要说的是——<strong>运气带来的东西，也会被运气带走</strong>。实力带来的东西，即使短暂的被运气拿走了，但是实力还会再带来更多。</p></li><li><p><strong>妥协</strong>。这种现象通常出现在周期后期的投资行为特征。投资者会尽他们的最大努力坚持自己的信念，但是当经济和心理压力变得无法抗拒时，他们会放弃并跟风倒。</p></li></ul><p>:star:我们应该默默无闻的认真工作，在好的年份赚取稳定的收益，在坏的年份承担更低的损失。</p><p>这一章还讲了一个比较有意思的词:smile:“银弹”——当市场、个体或一种投资技术获得短期高额收益时，它通常会吸引人们的过度（盲目）崇拜。</p><p>作者的结论是，:zap:理性者有可能屈服于情感的破坏性力量。</p><h3 id="怎样抵御消极影响">怎样抵御消极影响？</h3><p>没有告诉我们市场已经摆向非理性极端的公式；没有保证我们永远做出正确决策的完美工具；也没有保护我们不受消极情绪影响的魔法药丸。我们应该注意下面这几点：</p><ul><li><strong>对内在价值有坚定的认识</strong>。</li><li><strong>当价格偏离价值时，坚持做该做的事</strong>。</li><li><strong>足够了解以往的周期</strong>——先从<strong>阅读</strong>和与经验丰富的投资者交谈开始，之后通过<strong>经验积累</strong>——从而了解市场过度膨胀或过度萎缩最终得到的是惩罚而不是奖励。</li><li><strong>透彻理解市场对极端市场投资过程的潜在影响</strong>。</li><li><strong>当事情看起来“好到不像真的”时，它们通常不是真的</strong>。</li><li><strong>当市场错误估价的程度越来越深以致自己貌似错误的时候，愿意承受这样的结果</strong>。</li><li><strong>与志趣相投的朋友或同时相互支持</strong>。</li></ul><p>:smile:这些方法并不一定奏效，但它们能够赋予我们可以一搏的机会。</p><h3 id="为什么要抵御消极影响">为什么要抵御消极影响？</h3><p>很多人会通过分析得出相似的认知结论。但是，因为各自所受的心理的影响不同，他们在这些结论的基础上所采取的行动各不相同。:star:最大的投资错误不是来自信息因素或分析因素，而是来自<strong>消极心理因素</strong>。这些因素往往会导致错误决策。</p><h2 id="star第十一章-逆向投资">:star:第十一章 逆向投资</h2><p>在别人沮丧地抛售时买进，在别人兴奋地买进时抛售需要最大的勇气，但它能带来最大的收益。</p><h3 id="什么是逆向投资">什么是逆向投资？</h3><p>这里我们要先知道，大多数投资者都是——趋势跟踪者，而杰出的投资者恰恰相反。</p><p>卓越投资需要第二层次思维——一种不同于常人的更复杂、更具洞察力的思维方式。从定义上来看。大多数投资者不具备这种思维能力，因此成功的关键不可能是群体的判断。</p><p>这里有几点可以让我们能很好的理解逆向投资的原理：</p><ul><li>我们永远不知道市场的钟摆能摆多远，也不知道什么时候会发生逆转。</li><li>可以肯定的是，一旦市场达到极端，它最终会摆回。</li><li>由于影响市场的各种因素的易变性，没有任何工具是完全靠得住的（包括逆向投资）。</li><li>逆向投资并不是稳赚不赔的方法，在大多数情况下，没有值得下注的<strong>过度市场</strong>。</li><li><strong>估价过高与明天就会跌</strong>是截然不同的。市场可以被高估或低估，并且能够将这种状态维持一段时间有时候长有时候短。</li><li>:star:有时候<strong>逆向投资</strong>本身会变得过于热门，从而有可能会被误以为是群体行为。</li></ul><h3 id="怎么去逆向投资">怎么去逆向投资？</h3><p>“低买高卖”是一句古老的名言，但是被卷入市场周期中的投资者却常常反其道而行之。正确的做法应该是逆向投资：</p><p>:star:在人们冷落时买入，在人们追捧时卖出。这样做需要很大的勇气。</p><p>有时候我们仅仅做与大众相反的投资是不够的。我们必须在推理和分析的基础上，辨别如何脱离群体思维才能获利，我们必须在进行逆向投资的时候，知道与大众的做法相反，还要知道大众错在哪里。</p><p>投资成功需要坚定的立场，即使它因为与群体共识存在分歧而<strong>令人不安</strong>。如果我相信别人都相信的故事，我就会和他们做同样的事。显然这不是逆向投资者应该做的。</p><p>:smile:我们应时刻保持怀疑，在恰当的时间说出：<strong>不对，事情好到不像真的</strong>。或者，<strong>不对，事情坏到不像真的</strong>。比如最近的中国2024年7、8月份，大家都抛售房地产行业，以致于房地产行业股票的价格低到令人发指，但是有少部分人已经认识到，事情好像坏道不是真的。果真如此？到2024年10月份房地产行业的股票价格短短两个月就上升了50%至100%。</p><p>我们需要认识到，我们<strong>不可能买在最低点和卖在最高点</strong>，当我们去接<em>刀子</em>时，如果<em>刀子</em>停止下落，尘埃已然落定，不确定性得到解决的时候，<strong>利润丰厚的特价股也将不复存在</strong>。</p><h3 id="为什么要逆向投资">为什么要逆向投资？</h3><p>几乎所有的最佳投资中，他们通常都是<strong>逆向投资</strong>。作为逆向投资者，:zap:我们的任务就是尽可能谨慎熟练的接住落下的“刀子”。这也是<strong>内在价值</strong>的概念如此重要的原因。如果我们对价值的认识能够让我们在<strong>别人都在卖出的时候买进</strong>——并且如果我们的<strong>观点事后被证明是正确的</strong>——那么这就是以<strong>最低风险获取最高回报</strong>的途径。</p><h2 id="第十二章-寻找便宜货">第十二章 寻找便宜货</h2><p>:star:在大多数人不愿做的事情中，通常能够发掘出最佳机会。</p><h3 id="如何定义便宜货">如何定义便宜货？</h3><p><strong>价格显著低于内在价值的公司</strong>，大众所厌恶的。但其基本面是稳定的（就像彼得林奇说的，没有负债的公司，你想让他破产都是见非常困难的事）但表面看上去是有问题的。</p><h3id="怎么寻找并构建便宜货投资组合">怎么寻找并构建便宜货投资组合？</h3><p>便宜货一般具有下列特征：</p><ul><li>鲜为人知或人们一知半解。</li><li>表面上看基本面有问题的。</li><li>有争议、不合时宜或令人恐慌的。</li><li>被认为不适于“正规”投资组合的。</li><li>不被欣赏、不受欢迎和不受追捧的。</li><li>收益不佳的追踪记录。</li><li>最近有亏损问题、没有资本增益的。</li></ul><p>:zap:便宜货存在的必要条件是感觉必须远不如现实。也就是说，最好的机会通常是在大多数人不愿做的事情中发掘出来的。</p><p>构建投资组合的过程是卖出不那么好的投资从而留出空间买进最好的投资（:star:投资是相对选择的训练），不碰最差的投资，这个过程需要以下步骤：</p><ul><li>潜在投资的清单:star:（在能力圈范围的投资，超出认知的就不要放在这个清单里面）</li><li>对它们内在价值的估计</li><li>对其价格相对于内在价值的感知</li><li>对每种投资涉及到的风险及其对在建投资组合的影响的了解</li></ul><h3 id="为什么要寻找便宜货">为什么要寻找便宜货？</h3><p>我们改变不了市场，若想参与其中，我们唯一的选择就是从现存的可能性中选择最好的。这就是相对决策。</p><p>便宜货的价值在于其<strong>不合理的低价位</strong>——因而具有不寻常的收益风险比率，因此它们呢就是投资者的“圣杯”。:smile:我们是积极投资者，因为我们相信我们可以通过识别好的机会而击败市场。另一方面，<strong>许多摆在我们面前的“特殊交易”好到不像真的，避开它们是取得投资成功的关键</strong>。因此，我们要对<strong>有效市场假说的怀疑和成为一个积极的投资者两方面保持平衡</strong>。投资者可能会因心理弱点、错误分析或拒绝进入不确定领域而犯错。:zap:这些错误为能够看到别人错误的第二层次思维者创造了便宜货。</p><p>公平定价的资产从来不是我们的目标，因为他们只能带来有风险的一般收益，当然，定价过高的资产对我们更没有任何好处。我们的目标是寻找估价过低的资产。</p><h2 id="第十三章-耐心等待机会">第十三章 耐心等待机会</h2><p>市场不是有求必应的机器，它不会仅仅因为你需要就提供高额收益。</p><h3 id="什么对于我们来说是机会">什么对于我们来说是机会？</h3><p>在低收益环境（普遍价格偏高）中要想得到较高收益，需要具备逆流而上的能力，以及找到相对较少的制胜投资的能力。这显然不是我们所说的机会。:star:高收益环境（普遍价格较低）所提供的高额收益机会是通过低价买进实现的，并且通常是低风险的，这才是我们所说的<strong>机会</strong>。比如，2000年的互联网泡沫后，2008年的危机后。这些时机都出现了高额收益的机会，而且是通过<strong>损失概率</strong>很小的投资做到这一点的。</p><h3 id="如何耐心等待机会">如何耐心等待机会？</h3><p>我们要等待投资机会的到来而不是追逐投资机会。在卖家积极卖出的东西中挑选，而不是固守想要什么才买什么的观念，这样的交易往往会更划算。</p><p>买入的绝佳机会出现在资产持有者被迫卖出的时候，在经济危机中这样的人比比皆是。比如近期中国从2021年开始，房地产泡沫开始破裂后，大部分基金投资者开始赎回他们的投资，所以基金经理不得不<strong>被迫卖出</strong>所持有的资产，这个时间段一直持续到了至今（2024年9月），国家开始出台强效政策试图救活房地产行业在经济中的流动性，才有所缓止。但是否有效，我们静心观之。:zap:但是2023到2024这个过程中确实出现了我们所说的机会（有一部分优质公司，因房地产行业下行的带动下，股价跌到了非常低的水平）。</p><p>:smile:潜在卖家会在卖个好价和尽快卖掉之间做出权衡。而强制卖家的妙处在于他们别无选择，他们必须不计价格卖出。如果我们是交易的另一方，那么“不计价格”这四个字将是世界上最美妙的词汇。</p><p>在危机中关键要做到远离强制卖出的力量，并<strong>把自己定位为买家</strong>。要达到这一标准，我们需要做到以下几点：</p><ul><li>坚信价值</li><li>少用或不用杠杆</li><li>有长期资本和顽强的意志力</li></ul><p>在逆向投资态度和强大资产负债表支撑下，耐心等待机会，便能在灾难中收获惊人的收益。</p><h3 id="为什么要等待机会">为什么要等待机会？</h3><p>在周期中逆势而动的逆向投资者们有了扬名立万的黄金机遇，但并不是总有伟大的事情等着我们去做，有时候我们可以通过敏锐的洞察和相对消极的行动将成果最大化。耐心等待机会——等待便宜货——往往是最好的策略。</p><h2 id="第四十章-认识预测的局限性">第四十章 认识预测的局限性</h2><p>:smile_cat:世界上有两类预言家：无知的，和不知道自己无知的。赔钱的人有两种：<strong>一无所知</strong>的和<strong>无所不知</strong>的。</p><h3 id="预测的局限性有哪些">预测的局限性有哪些？</h3><p>我们有可能推知未来将会发生什么，但是在最需要预测的紧要关头，我们却几乎无法预测未来将会发生什么。</p><ul><li>多数时候人们会根据以往预测未来。</li><li>人们不一定是错的：未来多数时候在很大程度上是以往的重复。</li><li>然而根据以往的经验作出的准确预测并不具备太大价值（概率太小）。</li><li>然而，未来每隔一段时间就会与过去大不相同。此时的准确预测具有巨大价值，但也是预测最难准确的时候。</li><li>某些关键时刻（比如2000年，2008年）作出的预测能最终被证实是对的，表明准确地预测关键事件是有可能的，但同一个人持续做出准确预测是不太可能的。</li><li>总而言之，预测的价值很小。</li></ul><p>这里我补充一点：巴菲特在1999年提示过，美国股市泡沫严重。2007年也提示过股市泡沫。两次他都用行动（抛售）证明了，人狂热的时候做出逆向决策是多么重要，也说明有人能大概推测未来，但并不是所有人都可以，他也只是<strong>个例</strong>。但仔细观察会发现，其实他遵循的就是<strong>价值和价格的关系</strong>这一点。</p><h3 id="怎么去认识预测的局限性">怎么去认识预测的局限性？</h3><p>如何去看待说自己能预测，并预测准确的人呢？</p><p>:smile:这里我们可以借用<strong>塔勒布</strong>的《随机致富的傻瓜》一书中的知识。</p><blockquote><p>概率中的一个经典现象——:star:<strong>幸存者偏差</strong>，由于我们只看到成功者，而由此形成的对机遇的歪曲看法。</p><p>比如说，我们常会认为长得英俊漂亮的人薪水会比较高，其实这是因为我们经常只会注意到那些薪水比较高的人，或者说那些薪水比较高的人容易被我们注意到罢了。</p><p>这部分举了一个很有名的例子，就是让很多很多的猴子放在打字机前，他们肯定会有那么一两只会打出一字不差的《伊利亚特》叙事诗。换句话说，从事商业的人数越多，其中某个人单靠机遇便能有惊人表现的可能性就越高。</p><p>作者还引用了<strong>生日悖论</strong>，随便找一个人，你和他生日是同一天的概率是<code>0.27%</code>，可是如果一个房间内有<code>23</code>个人，有两个生日相同的概率高达<code>50%</code>，在生活中，我们随处遭遇着幸存者偏差，把一个变量的极大值分布误作为那个变量本身。</p><p>用投资的思维看的话，就是我们通常只会关注在投资领域成功的投资者，比如巴菲特等，我们会对我们也可以成为像他一样成功的投资者产生误解，就连巴菲特自己都说过，他只不过是中了<strong>卵巢红利</strong>（生在一个对的地方，并做了一些对的事情）。我们只要仔细观察我们的股市就会发现，中国股民有接近3亿，但是成功的寥寥可数。</p></blockquote><p>很少有人把预测未来转化为投资优势的知识，<strong>但是我们对细节关注越多，越有可能获得知识优势。我们应尽量弄清自己在周期和钟摆中所处的阶段。这不会令未来变得可知，但是它能帮助我们为可能的发展作好准备</strong>。简单的说是，我们不能靠预测的结果指导我们的行为，但是我们可以细心观察或预测大概概率（就像，我不需要精确的错误，我需要的是模糊的正确），并作好准备应对。</p><h3 id="为什么要认识预测的局限性">为什么要认识预测的局限性？</h3><p>无论是进行脑外科手术、数学竞赛还是投资，过高估计自己的认知或行动能力都是<strong>极度危险</strong>的。正确认识自己的<strong>可知范围</strong>（巴菲特说的能力圈）——适度行动而不冒险越界——会令我们获益匪浅。</p><h2 id="star第十五章-正确认识自身">:star:第十五章 正确认识自身</h2><p>我们不知道一个趋势会持续多久，不知道它何时反转，也不知道导致反转的因素以及反转的程度。但我们应该相信，趋势迟早都会终止。没有任何东西能够永远存在。</p><h3 id="自身指的是什么">自身指的是什么？</h3><p>这里我们说的自身是以下两点：</p><ul><li>自己的知识、常识、情绪</li><li>自己的资源（可以利用的投资资金）</li></ul><p>当然这其中还有，自身现在处于市场周期的那个阶段。</p><h3id="在投资中怎么认识自身处于周期的哪个阶段">在投资中怎么认识自身处于周期的哪个阶段？</h3><p>我们在投资中面对周期，我们或许永远不会知道要去往何处，但最好弄明白我们身在何处。也就是说，即使我们不能预测周期性波动的时间和幅度，力争<strong>弄清我们处于周期的哪个阶段并采取相应的行动</strong>也是很重要的。这并不是说知道自己处于哪个阶段就会准确地预知接下来的事情。但对我们自身处境的正确认识会为我们了解未来事件、采取相应对策提供宝贵的洞见。</p><p>下面几点做法在对认识自身中或许会有帮助：</p><ul><li>当市场已经到达极端的时候，保持警惕。</li><li>相应地调整我们的行为。</li><li>:star:拒绝向<strong>导致无数投资者在市场顶部或底部犯下致命错误的群体行为</strong>看齐。</li></ul><p>:smile:了解未来很困难，但是了解现在没有那么难。第九章的牛市和熊市的几个阶段也可以用来观察。</p><p>我们必须力求了解我们身边所发生的事情的含义。当其他人盲目自信、积极买入时，我们应加倍小心；当其他人不知所措或恐慌性抛售时，我们应该更加积极。</p><ul><li><p>收益率差（利差）是收窄还是扩大？——收益率差 = 企业债券收益率 -国债收益率</p><blockquote><p><strong>利差收窄</strong></p><p>在信用风险降低的情况下，低等级债券与无风险债券之间的收益率差可能会减小。:zap:通常发生在经济环境改善、企业盈利能力增强、违约风险降低、经济稳定增长、通货膨胀率较低、央行政策利率保持稳定的时期。</p><p><strong>利差扩大</strong></p><p>在信用风险方面，收益率差扩大可能反映市场对某些行业或企业的担忧增加。例如，在经济衰退或行业不景气的情况下，特定行业或企业的违约风险可能会上升，导致相关债券的收益率差扩大。:zap:通常发生在经济不确定性增加、通货膨胀率上升、央行政策利率调整或市场预期未来利率变化较大的时期。</p></blockquote></li></ul><p>作者这里给出了个表格用于测试市场温度（市场现在的阶段），当<strong>呆滞项</strong>逐渐变成<strong>活跃项</strong>时是往牛市走，反过来则是往熊市走。全部项目都在一个大项里面就代表最高和最低了。</p><table><thead><tr><th style="text-align: center;">经济</th><th style="text-align: center;">活跃</th><th style="text-align: center;">呆滞</th></tr></thead><tbody><tr><td style="text-align: center;">前景</td><td style="text-align: center;">积极</td><td style="text-align: center;">消极</td></tr><tr><td style="text-align: center;">贷款人</td><td style="text-align: center;">急切</td><td style="text-align: center;">谨慎</td></tr><tr><td style="text-align: center;">资本市场</td><td style="text-align: center;">宽松</td><td style="text-align: center;">紧缩</td></tr><tr><td style="text-align: center;">资本</td><td style="text-align: center;">充足</td><td style="text-align: center;">短缺</td></tr><tr><td style="text-align: center;">贷款条款</td><td style="text-align: center;">宽松</td><td style="text-align: center;">严格</td></tr><tr><td style="text-align: center;">利率</td><td style="text-align: center;">低</td><td style="text-align: center;">高</td></tr><tr><td style="text-align: center;">利差</td><td style="text-align: center;">窄</td><td style="text-align: center;">宽</td></tr><tr><td style="text-align: center;">投资者</td><td style="text-align: center;">乐观、自信、渴望买入</td><td style="text-align: center;">悲观、担忧、丧失购买兴趣</td></tr><tr><td style="text-align: center;">资产持有人</td><td style="text-align: center;">乐于持有</td><td style="text-align: center;">急于出手</td></tr><tr><td style="text-align: center;">卖家</td><td style="text-align: center;">少</td><td style="text-align: center;">多</td></tr><tr><td style="text-align: center;">市场（整个市场交易量）</td><td style="text-align: center;">拥挤</td><td style="text-align: center;">急需关注</td></tr><tr><td style="text-align: center;">基金</td><td style="text-align: center;">申购门栏高、每天都有新基金</td><tdstyle="text-align: center;">对所有人开放、只有最好的才能募到资金</td></tr><tr><td style="text-align: center;">近期表现</td><td style="text-align: center;">强</td><td style="text-align: center;">弱</td></tr><tr><td style="text-align: center;">资产价格</td><td style="text-align: center;">高</td><td style="text-align: center;">低</td></tr><tr><td style="text-align: center;">预期的回报</td><td style="text-align: center;">低</td><td style="text-align: center;">高</td></tr><tr><td style="text-align: center;">风险</td><td style="text-align: center;">高</td><td style="text-align: center;">低</td></tr><tr><td style="text-align: center;">人群特征</td><td style="text-align: center;">积极进取、广泛投资</td><td style="text-align: center;">谨慎守纪、有选择地投资</td></tr></tbody></table><h3 id="为什么要认识自身">为什么要认识自身？</h3><p>市场在周期性运动，有涨有跌。钟摆在不断摆动，极少停留在弧线的中点。这是危险还是机会？投资者该如何应对？对于这两个问题我们只要:muscle:<strong>努力了解我们身边所发生的事情，并以此指导我们的行动</strong>。</p><h2 id="第十六章-重视运气">第十六章 重视运气</h2><p>每隔一段时间，就会有一个在不可能或不明朗的结果上下了高风险赌注的人，结果他看起来像个天才。但我们应该认识到，他之所以能够成功，靠的是运气和勇气。而不是技能。（幸存者偏差）</p><h3 id="怎么识别运气">怎么识别运气？</h3><p>随机性（运气）对结果起着巨大的作用，我们应区别对待<strong>随机事件</strong>与<strong>非随机事件</strong>带来的结果。我们在评判投资结果是否具有<strong>可重复性</strong>时，必须考虑随机性对我们的影响，必须考虑我们的业绩靠的是<strong>技能</strong>还是单纯的<strong>运气</strong>。</p><p>例：有一个投资者在2023年获得200%的收益，超过了所有人，但其他年份收益率却表现平平只有3%甚至有时是负的，你认为他的业绩靠的是运气还是技能？</p><p>例：另一个投资者从1956年开始直到2023年，每年平均收益而19%左右，很显然2023年他的收益远远低于200%，那你认为他的投资业绩是靠运气还是技能？</p><h3 id="为什么要重视运气">为什么要重视运气？</h3><p>有很大概率发生并不代表一定发生，也有可能发生小概率事件。在一个人成功的时候，运气看起来就像是技能一样。作为投资者所取得的成功深受偶然因素的影响。</p><p>:star:适度尊重风险，知道未来不能预知，明白未来是概率分布的并相应地进行投资，坚持防御型投资，强调避免错误的重要性，这点在作者看来，就是有关聪明投资的一切。</p><h2 id="第十七章-多元化投资">第十七章 多元化投资</h2><p>有老投资者，有大胆的投资者，但没有大胆的老投资者。</p><h3 id="什么是多元化投资">什么是多元化投资？</h3><p>投资不同领域、不同的产业，通过分散投资来降低整体投资组合的风险。:zap:多元化投资属于防御型投资，反之，集中化投资属于进攻型投资。这两种策略的<strong>思维模型</strong>有很大的不同。</p><h3 id="怎么去多元化投资">怎么去多元化投资？</h3><p>多元化投资是防御型投资的关键策略之一。通过投资多个不同的资产，可以分散风险，提高投资组合的稳定性。比如我常有的如下比例：</p><ul><li>国债 15%</li><li>货币基金或企业债券 39%</li><li>黄金 8%</li><li>大宗商品 8%</li><li>股票 30%</li></ul><h3 id="为什么要多元化投资">为什么要多元化投资？</h3><p>在主流股票市场主动寻求<strong>致胜投资</strong>未必有好处。相反，投资者应尽量避免<strong>致败投资</strong>。换句话说，攻守选择没有对错之分。条条大陆通罗马，我们的决策必须基于我们的性格与学识、我们对自己能力的信任程度以及我们所在的市场。</p><p>这本书强调的也是<strong>防御型投资</strong>（就是避免错误投资），也就是在投资组合中要有足够的<strong>安全边际</strong>。这里可以用一个例子来解释安全边际：</p><blockquote><p>:star:我们通过计算、分析，发现一些估值为100元的资产。如果90元买进，我们就得到一个获利的好机会，同时，如果我们推断过于乐观，也会有一定的损失概率。但是如果我们用60元而不是90元买进，我们的损失概率就会减少。减少的这30元就为我们的失误提供了额外的空间，同时仍然有很好的获利机会。低价是安全边际的源泉。</p></blockquote><p>我们在长期的投资生涯中持续性是我们能够存活的根基，所以防守型投资是我们这样的业余投资者最好的选择。尤其在资金不断增长后，越是大资金越寻求的是安全。</p><h2 id="star第十八章-避免错误">:star:第十八章 避免错误</h2><p>投资者几乎无须做对什么事，他只需能够避免犯重大错误。</p><h3 id="有哪些错误">有哪些错误？</h3><p>错误的形式多种多样——多到不胜枚举。以下是一些常见的错误：</p><ul><li>分析过程中数据或计算错误导致错误股价。<strong>（分析错误）</strong></li><li>对各种可能性及其后果估计不足。<strong>（想象无能错误）</strong></li><li>贪婪、恐惧、嫉妒、自负、终止怀疑、盲从和屈服达到极致。最终，风险承担或风险容忍过度。<strong>（心理错误）</strong></li><li>价格显著偏离价值，投资者没有注意到这种偏离甚至还要推波助澜。<strong>（认识错误）</strong></li></ul><h3 id="怎么去避免错误">怎么去避免错误？</h3><p>对于分析错误，我们应该更仔细的收集资料，以及对不同资产的估值方式区别对待，没有一种估值方式可以估计所有资产类别。</p><p>对于想象无能错误，我们要理解一种资产可能会对另一种资产的变化做出反应。理解并预测相关性的影响——进而理解并预测多元化的局限——是风险控制和投资组合管理的主要任务，这很难实现。但是<strong>不能正确预测投资组合内的协同运动是投资失败的一个关键原因</strong>。<em>比如，一家汽车制造商的股票下跌，共同因素将会导致所有汽车股同时下跌等。</em>如果我们的投资组合内类别不同且有良好的比例控制可以避免这样的情况出现。</p><p>对于心理错误，我们必须保持警惕，尤其是当人们狂热的时候。</p><p>对于认识错误，市场就是课堂，每天都在传授着各种经验教训。投资成功的关键在于<strong>观察和学习</strong>。</p><p>:smile:尽管识别和避免具体错误并不容易，但这是一个很好的时机，令我们意识到有许多错误潜伏在暗处，进而持有防御型更强的仓位。做不到这一点也是一个巨大的错误。我们应该做到以下几点：</p><ul><li>留意他人的轻率举动。</li><li>做好应对低迷的心理准备。</li><li>卖出资产，或至少卖出风险更高的资产。</li><li>减少杠杆。</li><li>筹集现金。</li><li>加强投资组合的防御性。</li></ul><p>从定义来看，大多数人都会犯错误，因为如果不是他们的一致性，错误就不会存在。采取相反的行动<strong>需要逆向投资态度</strong>，而长期逆向投资会带来<strong>孤独感</strong>和<strong>错误感</strong>。</p><h3 id="为什么要避免错误">为什么要避免错误？</h3><p>设法<strong>避免损失</strong>比<strong>争取伟大的成功</strong>更加重要。后者有时会实现，但偶尔失败可能会导致严重后果。前者可能是我们可以更经常做的，并且更可靠，失败的结果也更容易接受。</p><ul><li>投资组合风险过高时，向下的波动会令我们失去信心或低价抛售。</li><li>投资组合风险过低时，会令我们在牛市中表现不佳，但从未有人曾经因此而失败。</li></ul><p>普通的投资者能避免错误就算万幸了，而优秀的投资者期待的却是从错误中获利。</p><h2 id="第十九章-增值的意义">第十九章 增值的意义</h2><p>增值型投资者的表现是<strong>不对称</strong>的。他们获得的市场收益率高于他们蒙受的损失率，只有依靠技术，才能保证有利环境中的收益高于不利环境中的损失。这就是我们寻找的投资不对称性。</p><p>不对称性——（牛市收益率尽量跟随指数，熊市收益率超过指数或损失低于指数。）</p><h3id="增值对于经验丰富的投资者的意义是什么">增值对于经验丰富的投资者的意义是什么？</h3><p>这里作者讲了两个投资理论术语：::smile:我们可以仅当参考。</p><ul><li><p>β系数。衡量投资组合相对市场走势的敏感度。<strong>公式为</strong>：$投资组合β系数=w_1<em>β_1+w_2</em>β_2++w_n*β_n$（其中 <strong>w</strong> 代表组合中每支股票的资金比例，<strong>β</strong>代表每只股票的被系数，可以通过金融软件来获取每只股票的β系数）</p><blockquote><p>如果β为1，则市场上涨10%，股票上涨10%；市场下滑10%，股票相应下滑10%。</p><p>如果β为1.1，市场上涨10%时，股票上涨11%；市场下滑10%时，股票下滑11%。</p><p>如果β为0.9，市场上涨10%时，股票上涨9%；市场下滑10%时，股票下滑9%。</p><ul><li><strong>β &gt; 1</strong>：投资组合的波动性高于市场。</li><li><strong>β = 1</strong>：投资组合的波动性与市场一致。</li><li><strong>β &lt; 1</strong>：投资组合的波动性低于市场。</li><li><strong>β = 0</strong>：投资组合与市场完全不相关。</li><li><strong>β &lt;0</strong>：投资组合与市场呈负相关，即当市场上涨时下跌，反之亦然。</li></ul></blockquote></li><li><p>α系数。个人投资技术，与市场走势无关的获利能力。</p><blockquote><p>假设有一投资组合，通过对其的风险水平分析，资本资产定价模型预测其每年回报率为14%。但是该投资组合的实际回报率为每年19%。此时，这个投资组合的α系数为5%（19%－14%），即表示该组合的实际回报率超过由资本资产定价模型预测的回报率5个百分点。</p><p>α＞0，表示基金或股票的价格可能被低估，建议买入。亦即表示该基金或股票以投资技术获得平均比预期回报大的实际回报。</p><p>α＜0，表示基金或股票的价格可能被高估，建议卖空。亦即表示该基金或股票以投资技术获得平均比预期回报小的实际回报。</p><p>α=0，表示基金或股票的价格准确反映其内在价值，未被高估也未被低估。亦即表示该基金或股票以投资技术获得平均与预期回报相等的实际回报。</p></blockquote></li></ul><table><caption>zap:<span class="math inline">\(投资组合的表现 = α + β *x\)</span>(其中x为市场平均收益)</caption><thead><tr><th style="text-align: center;">时间</th><th style="text-align: center;">市场平均收益</th><th style="text-align: center;">投资组合收益</th></tr></thead><tbody><tr><td style="text-align: center;">:x:1</td><td style="text-align: center;">10</td><td style="text-align: center;">20</td></tr><tr><td style="text-align: center;">:x:2</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">:x:3</td><td style="text-align: center;">-10</td><td style="text-align: center;">-20</td></tr><tr><td style="text-align: center;">:o:4</td><td style="text-align: center;">10</td><td style="text-align: center;">12</td></tr><tr><td style="text-align: center;">:o:5</td><td style="text-align: center;">0</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;">:o:6</td><td style="text-align: center;">-10</td><td style="text-align: center;">-1</td></tr><tr><td style="text-align: center;">:heavy_check_mark:7</td><td style="text-align: center;">10</td><td style="text-align: center;">25</td></tr><tr><td style="text-align: center;">:heavy_check_mark:8</td><td style="text-align: center;">0</td><td style="text-align: center;">-5</td></tr><tr><td style="text-align: center;">:heavy_check_mark:9</td><td style="text-align: center;">-10</td><td style="text-align: center;">-15</td></tr></tbody></table><p>上面这个表格粗略的表示了一个投资组合风格的好坏：</p><ul><li>:x:表示并不是一个好的组合或一个好的资风格</li><li>:o:表示一个比较好的组合或投资风格</li><li>:heavy_check_mark:如果能容忍波动，这个组合或这种投资风格就是技术最高的。</li></ul><h3 id="如何利用技术实现增值">如何利用技术实现增值？</h3><p>我们怎么实现增值取决于，我们要认清周期，也就是第十五章说的内容。在衰退期，防御型投资者的损失少于积极进取型投资者，在繁荣期，积极进取型投资者比防御性投资者赚得更多。但他们提升价值了吗？未必。</p><table><caption>grin:我个人认为这里讲的<strong>技术</strong>就是：</caption><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">积极进取型投资者</th><th style="text-align: center;">防御型投资者</th></tr></thead><tbody><tr><td style="text-align: center;">无技术</td><tdstyle="text-align: center;">市场上涨时获利丰厚，市场下跌时损失惨重</td><tdstyle="text-align: center;">市场下跌时损失不多，但市场上涨时获利也不多</td></tr><tr><td style="text-align: center;">有技术</td><tdstyle="text-align: center;">市场上涨时获利丰厚，下跌时不会同等程度下跌</td><tdstyle="text-align: center;">市场下跌时损失不多，但上涨时获利颇丰</td></tr></tbody></table><ul><li><strong>准确估值、时刻记住安全边际、保持良好的心态、仔细观察周期的变化</strong>:heavy_check_mark:</li></ul><h3 id="为什么要知道增值的意义">为什么要知道增值的意义？</h3><p>就风险与收益来看，达到市场一致的表现并不难，难的是比市场表现的更好：增值。这里就又要回到第二层次思维者身上去思考。</p><p>:star:为了在市场表现良好时与市场表现一致，一个投资组合必须有适当的β系数和市场相关性，但是，如果市场在上涨时我们得益于β系数，它们会不会在市场下跌的时候伤害我们？如果我们能持之以恒地做到在市场衰退时损失更少、在市场上涨时充分参与，那么原因只有一个：<strong>α系数</strong>，或技术。</p><p>不对称性——上涨时收益高于下跌时的损失，并且超过单纯投资风格所致的结果——应成为我们的目标。</p><p>:zap:<span class="math inline">\(投资组合的表现 = α + β *x\)</span>(其中x为市场平均收益)</p><h2 id="star第二十章-最重要的事">:star:第二十章 最重要的事</h2><p>成功的投资或成功的投资生涯的基础，是<strong>价值</strong>。我们必须清楚的认识到我们想买进的东西的价值。价值简单来说就是：</p><ul><li><p>账面现金和有形资产价值（账面价值）</p></li><li><p>公司或资产产生现金流的能力（商业模式）</p></li><li><p>以及所有这些东西的增值潜力（增长潜力）</p><blockquote><p>这里可以将增长潜力设置一个<strong>置信区</strong>（参考现实经济形势），比如，你依照以往来看，下一年该公司盈利能力可能增长30%，但是任何事物都有周期，不可能好的一直好，坏的一直坏，我们假设置信区为50%，那么我们得到公司增长潜力就是<code>30%*50%=15%</code></p></blockquote></li></ul><p>为了取得卓越的投资结果，<strong>我们必须学会别人不会的东西、以不同的视角看待问题、对问题分析得更到位</strong>。</p><h2 id="评语">评语</h2><p>本书主要讲解了<strong>逆向思维</strong>的重要性，通过逆向思维来理解市场周期，理解风险，和定义投资风格的好坏，并强调<strong>价值和价格的关系</strong>是最重要的事。</p><p>我认为作者的理论论证是符合现实情况的。但有些时候是有些执着和路径依赖的，虽然防御性投资风格在很多时候是理性并且好的，但是也有很多进攻型投资风格取得连续很好的成绩，比如巴菲特，费雪等。</p><p>作为投资者的我来理解是，不管进攻性还是防御性投资风格，最重要的是要认识到<strong>资产的价值</strong>并在合适的周期阶段进行投资动作（买入和卖出），还要衡量资产比重（仓位），才能取得好的结果，这才是关键。这一点在所有投资大师身上都可以看得到，本杰明格雷厄、巴菲特、彼得林奇、费雪、格林布拉特、西蒙斯等，当然还有本书的作者霍华德马克思。</p><p>一个合理的组合应该是根据市场而定：</p><p>经济周期：繁荣——衰退——萧条——复苏</p><ul><li>经济衰退、萧条期，防御型资产占比应该为70%-80%，进攻型资产占比为30%-20%</li><li>经济复苏、繁荣期，进攻型资产占比应该为70%-80%，防御型资产占比为30%-20%</li><li>平常期（这个时间段非常短），防御型和进攻型各占50%</li></ul>]]></content>
    
    
    <categories>
      
      <category>投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo制作博客教程</title>
    <link href="/2024/10/25/2024-10-25-Hexo%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    <url>/2024/10/25/2024-10-25-Hexo%E5%BB%BA%E7%AB%8B%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>Hexo常用命令 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 文章的书写<br>hexo new [layout] &lt;title&gt;<br><br>eg: hexo new <span class="hljs-string">&quot;post title with whitespace&quot;</span> 其中 layout为_config.yml中的默认参数值。<br><br>-p --path 自定义新文章<br>-r --replace 存在同名文章，替换<br>-s --slug 文章的slug，作为新文章的文件名和发布后的URL<br>eg： hexo new page --path about/me <span class="hljs-string">&quot;About me&quot;</span><br><br>2. 生成静态文件<br>hexo generate 或 hexo g<br><br>-d 或--deploy 文件生成后部署网站<br>-w 或--watch 监视文件变动<br>-b 或--bail 生成过程中出现异常则抛出。<br>-f 或--force 强制重新生成文件<br>-c 或--concurrency 最大同时生成文件数量，默认无限制。<br>3. 发布草稿<br>hexo publish [layout] &lt;filename&gt;<br><br>4.启动服务器<br>hexo server 启动服务器，ctrl+c 结束，默认地址为：http://localhost:4000/<br><br>5.部署网站<br>hexo deploy 或hexo d<br><br>-g 或--generate 部署之前写成静态文件<br>6.渲染文件<br>hexo render &lt;file1&gt; [file2]<br><br>-o或--output 设置输出路径<br>7. 清除缓存文件<br>hexo clean<br><br>8. 列出网站资料<br>hexo list &lt;<span class="hljs-built_in">type</span>&gt;<br><br>9. 显示草稿<br>hexo --deaft<br><br>10. 自定义当前工作目录<br>hexo --cwd /path/to/cwd<br></code></pre></td></tr></table></figure></p><p>建立一个基于GitHub的个人博客网站是一个既实用又能提升技术能力的好项目。以下是一个详细的步骤清单，帮助你从零开始搭建个人博客：</p><h2 id="第一步-注册">第一步 注册</h2><h3 id="注册和设置github账户">1.<strong>注册和设置GitHub账户</strong></h3><ul><li><strong>注册GitHub</strong>：如果你还没有GitHub账户，需要先注册一个。</li><li><strong>设置个人信息</strong>：完善你的个人资料，包括头像、简介等，这将展示在你的博客页面上。</li></ul><h3 id="选择博客框架工具">2. <strong>选择博客框架/工具</strong></h3><ul><li><strong>静态网站生成器</strong>：如Jekyll（Ruby）、Hugo（Go）、Hexo（Node.js）等，它们可以从Markdown文件生成静态HTML页面。</li><li><strong>主题选择</strong>：选择一个你喜欢的主题，很多框架都有现成的主题库可以选择，也可以自定义。</li></ul><h3 id="安装和配置博客框架">3. <strong>安装和配置博客框架</strong></h3><ul><li><strong>安装必要的软件</strong>：根据你选择的框架，安装相应的软件（如Ruby、Node.js等）。</li><li><strong>初始化博客</strong>：按照框架的官方文档，通过命令行工具初始化一个新的博客项目。</li><li><strong>配置_config.yml</strong>（以Jekyll为例）：修改配置文件，设置博客的基本信息，如标题、作者、社交链接等。</li></ul><h3 id="创建和编辑内容">4. <strong>创建和编辑内容</strong></h3><ul><li><strong>Markdown文件</strong>：使用Markdown编写你的文章，存放在指定的文件夹中（通常是<code>_posts</code>）。</li><li><strong>添加页面</strong>：根据需要添加其他页面，如关于我、作品集等，也是使用Markdown编写。</li></ul><h3 id="本地预览">5. <strong>本地预览</strong></h3><ul><li><strong>运行博客</strong>：在本地运行博客，预览效果。大多数框架都提供了命令行工具来启动一个本地服务器。</li><li><strong>调试和修改</strong>：根据预览效果，调整文章内容和样式。</li></ul><h3 id="部署到github-pages">6. <strong>部署到GitHub Pages</strong></h3><ul><li><strong>创建仓库</strong>：在GitHub上创建一个新的仓库，命名为<code>username.github.io</code>（<code>username</code>是你的GitHub用户名），这是GitHubPages的默认域名。</li><li><strong>推送代码</strong>：将你的博客代码推送到这个仓库。</li><li><strong>启用GitHubPages</strong>：在仓库的设置中，找到“Pages”部分，选择“main”或“gh-pages”分支（取决于你的配置），然后保存设置。</li><li><strong>自定义域名</strong>（可选）：如果你想使用自己的域名，可以在Pages设置中添加CNAME记录，并在域名提供商处配置A记录指向GitHubPages的IP地址。</li></ul><h3 id="优化和维护">7. <strong>优化和维护</strong></h3><ul><li><strong>SEO优化</strong>：添加meta标签，使用SEO友好的URL结构，确保内容易于被搜索引擎索引。</li><li><strong>更新内容</strong>：定期发布新文章，保持博客活跃。</li><li><strong>备份</strong>：定期备份你的博客代码和文章，以防万一。</li><li><strong>安全性</strong>：注意GitHub仓库的安全设置，避免敏感信息泄露。</li></ul><h3 id="推广和互动">8. <strong>推广和互动</strong></h3><ul><li><strong>社交媒体</strong>：通过社交媒体分享你的文章，增加曝光度。</li><li><strong>读者互动</strong>：添加评论系统（如Disqus、Utterances），鼓励读者留言反馈。</li><li><strong>加入社区</strong>：参与技术社区，与其他博主交流，互相学习。</li></ul><p>完成以上步骤后，你就拥有了一个基于GitHub的个人博客网站。记得持续学习和探索，不断优化你的博客，让它成为你展示才华和分享知识的平台。</p><p>没问题，即使你对编程不太熟悉，我们仍然可以一步一步地搭建你的个人博客。既然你已经完成了GitHub账户的注册和设置，接下来我们将选择并配置一个适合初学者的博客框架。</p><h2 id="第二步选择博客框架工具">第二步：选择博客框架/工具</h2><p>对于初学者来说，我推荐使用<strong>Hexo</strong>或<strong>Hugo</strong>这样的静态网站生成器，因为它们相对简单且易于上手，尤其是Hexo，它使用Markdown编写内容，非常适合不熟悉编程的人。</p><h4 id="选择hexo的原因">选择Hexo的原因：</h4><ul><li><strong>Markdown支持</strong>：你可以使用Markdown语法来编写文章，这是一种轻量级标记语言，易于学习和使用。</li><li><strong>主题丰富</strong>：Hexo有大量的第三方主题可供选择，你可以很容易地找到一个你喜欢的样式。</li><li><strong>插件支持</strong>：Hexo有丰富的插件生态系统，可以扩展博客的功能，比如添加评论系统、SEO优化等。</li><li><strong>部署简单</strong>：Hexo可以轻松地将你的博客部署到GitHubPages上。</li></ul><h4 id="安装hexo">安装Hexo</h4><ol type="1"><li><strong>安装Node.js和npm</strong>：<ul><li>首先，你需要安装Node.js，这是Hexo运行的基础。你可以从Node.js的官方网站（https://nodejs.org/）下载并安装适合你操作系统的版本。</li><li>安装Node.js时，npm（Node Package Manager）会一并安装。</li></ul></li><li><strong>全局安装Hexo</strong>：<ul><li>打开你的命令行工具（在Windows上是CMD或PowerShell，在macOS或Linux上是Terminal）。</li><li>输入以下命令来全局安装Hexo： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure></li><li>这将安装Hexo的命令行工具，允许你通过命令行来创建和管理Hexo博客。</li></ul></li><li><strong>初始化Hexo博客</strong>：<ul><li>选择一个你想要存放博客代码的文件夹，并导航到该文件夹。</li><li>输入以下命令来初始化一个新的Hexo博客： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init myblog<br></code></pre></td></tr></table></figure></li><li>这将创建一个名为<code>myblog</code>的新文件夹，里面包含了Hexo博客的基本结构和默认主题。</li><li>进入<code>myblog</code>文件夹： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> myblog<br></code></pre></td></tr></table></figure></li></ul></li><li><strong>安装依赖</strong>：<ul><li>在<code>myblog</code>文件夹内，运行以下命令来安装博客所需的依赖项：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install<br></code></pre></td></tr></table></figure></li></ul></li><li><strong>启动本地服务器</strong>：<ul><li>输入以下命令来启动Hexo的本地服务器，并预览你的博客：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br></code></pre></td></tr></table></figure></li><li>默认情况下，服务器会在<code>http://localhost:4000</code>上运行。你可以在浏览器中打开这个地址来查看你的博客。</li></ul></li><li><strong>创建和编辑文章</strong>：<ul><li>在<code>myblog/source/_posts</code>文件夹中，你可以创建新的Markdown文件来编写文章。</li><li>Hexo会自动将这些Markdown文件转换为HTML页面，并在你启动本地服务器时显示。</li></ul></li><li><strong>生成静态文件</strong>：<ul><li>当你准备好将博客部署到GitHubPages时，你可以使用以下命令来生成静态HTML文件： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br></code></pre></td></tr></table></figure></li><li>这将在<code>myblog/public</code>文件夹中生成静态文件。</li></ul></li><li><strong>部署到GitHubPages</strong>（我们将在后续步骤中详细讨论）。</li></ol><p>现在你已经成功安装了Hexo，并创建了一个基本的博客。</p><h2 id="第三步创建和编辑内容">第三步：创建和编辑内容</h2><h4 id="了解hexo的文件结构">1. <strong>了解Hexo的文件结构</strong></h4><p>在你之前初始化的Hexo博客文件夹（比如<code>myblog</code>）中，有几个重要的文件夹和文件：</p><ul><li><code>source/</code>：存放你的原始内容，包括Markdown文章、图片等。</li><li><code>source/_posts/</code>：存放你的文章，每个文章都是一个<code>.md</code>文件。</li><li><code>themes/</code>：存放你选择的Hexo主题。</li><li><code>_config.yml</code>：Hexo博客的全局配置文件。</li></ul><h4 id="编写新文章">2. <strong>编写新文章</strong></h4><ol type="1"><li><strong>创建Markdown文件</strong>：<ul><li>进入<code>source/_posts/</code>文件夹。</li><li>创建一个新的Markdown文件，文件名通常遵循<code>YYYY-MM-DD-title.md</code>的格式，其中<code>YYYY</code>是年份，<code>MM</code>是月份，<code>DD</code>是日期，<code>title</code>是你的文章标题（用英文短横线<code>-</code>分隔单词）。</li></ul></li><li><strong>编写文章头部信息</strong>（Front-matter）：<ul><li>在Markdown文件的顶部，添加如下信息（用三个短横线<code>---</code>包围）：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">title:</span> <span class="hljs-string">你的文章标题</span><br><span class="hljs-attr">date:</span> <span class="hljs-string">YYYY-MM-DD</span> <span class="hljs-string">HH:MM:SS</span> <span class="hljs-comment"># 发布日期和时间</span><br><span class="hljs-attr">categories:</span> <span class="hljs-comment"># 文章的分类</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">分类1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">分类2</span><br><span class="hljs-attr">tags:</span> <span class="hljs-comment"># 文章的标签</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">标签1</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">标签2</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure></li><li>替换<code>你的文章标题</code>、<code>YYYY-MM-DD HH:MM:SS</code>、<code>分类1</code>、<code>分类2</code>、<code>标签1</code>和<code>标签2</code>为实际的内容。</li></ul></li><li><strong>编写文章内容</strong>：<ul><li>在Front-matter之后，你可以开始编写你的文章内容了。使用Markdown语法来格式化文本，比如标题、段落、列表、图片、链接等。</li></ul></li><li><strong>保存文件</strong>：<ul><li>完成文章编写后，保存Markdown文件。</li></ul></li></ol><h4 id="预览文章">3. <strong>预览文章</strong></h4><ul><li>回到你的命令行工具，确保Hexo的本地服务器还在运行（如果关闭了，重新运行<code>hexo server</code>）。</li><li>在浏览器中打开<code>http://localhost:4000</code>，你应该能看到你的新文章已经出现在博客上了。</li></ul><h4 id="编辑现有文章">4. <strong>编辑现有文章</strong></h4><ul><li>如果需要编辑现有的文章，只需在<code>source/_posts/</code>文件夹中找到对应的Markdown文件，进行修改，然后保存。</li><li>Hexo会自动检测文件的更改，并刷新本地服务器上的预览。</li></ul><h4 id="添加其他页面">5. <strong>添加其他页面</strong></h4><ul><li>除了文章之外，你还可以添加其他页面，比如关于我、作品集等。</li><li>创建一个新的Markdown文件，放在<code>source/</code>文件夹中（而不是<code>_posts/</code>），然后按照文章的方式编写头部信息和内容。</li><li>在Hexo的主题配置文件中，你可能需要添加一些路由规则来确保这些页面能够正确显示。</li></ul><p>现在你已经知道如何创建和编辑Hexo博客的内容了。</p><h2 id="第四步本地预览和调试">第四步：本地预览和调试</h2><h4 id="启动hexo本地服务器">1. <strong>启动Hexo本地服务器</strong></h4><p>确保你的Hexo博客项目文件夹（比如<code>myblog</code>）是打开的，然后在命令行工具中导航到该文件夹。运行以下命令来启动Hexo的本地服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br></code></pre></td></tr></table></figure><p>或者，如果你安装了<code>hexo-cli</code>并且想要从任何位置启动服务器，你可以使用全局命令（但需要先导航到博客项目文件夹的父目录，然后使用相对路径或绝对路径指定博客文件夹）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server -d myblog<br></code></pre></td></tr></table></figure><p>其中<code>myblog</code>是你的博客项目文件夹的名称。</p><h4 id="在浏览器中预览">2. <strong>在浏览器中预览</strong></h4><p>默认情况下，Hexo的本地服务器会在<code>http://localhost:4000</code>上运行。打开你的网页浏览器，输入这个地址，你应该能看到你的博客的本地预览。</p><h4 id="浏览和导航">3. <strong>浏览和导航</strong></h4><ul><li>点击博客上的链接，确保导航正常。</li><li>检查文章的布局和样式，确保它们符合你的期望。</li><li>如果你的博客有侧边栏、页脚等组件，也请确保它们显示正确。</li></ul><h4 id="调试和修改">4. <strong>调试和修改</strong></h4><ul><li>如果发现任何问题（比如布局错乱、链接失效等），回到你的Markdown文件或主题配置文件中进行修改。</li><li>修改后，保存文件，然后刷新浏览器页面，查看更改是否生效。</li><li>重复这个过程，直到你对博客的预览满意为止。</li></ul><h4 id="使用hexo的内置命令">5. <strong>使用Hexo的内置命令</strong></h4><ul><li>在调试过程中，你可能会频繁地生成静态文件和重启服务器。Hexo提供了一些方便的命令来简化这些操作：<ul><li><code>hexo clean</code>：删除生成的静态文件（在<code>public</code>文件夹中）。</li><li><code>hexo generate</code>（或简写为<code>hexo g</code>）：生成静态文件。</li><li><code>hexo server</code>（或简写为<code>hexo s</code>）：启动本地服务器。</li><li>你可以组合这些命令来简化工作流程，比如<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</code>。</li></ul></li></ul><h4 id="检查响应式设计">6. <strong>检查响应式设计</strong></h4><ul><li>如果你的博客主题支持响应式设计（即在不同设备上都能良好显示），请在不同的屏幕尺寸和浏览器上测试你的博客。</li><li>确保在移动设备上也能方便地浏览和导航。</li></ul><p>现在你已经知道如何在本地预览和调试你的Hexo博客了。</p><h2 id="第五步自定义博客主题和设置">第五步：自定义博客主题和设置</h2><h4 id="选择并安装主题">1. <strong>选择并安装主题</strong></h4><p>Hexo拥有丰富的第三方主题，你可以根据自己的喜好选择一个。以下是如何安装一个主题的步骤：</p><ol type="1"><li><strong>浏览Hexo主题</strong>：<ul><li>你可以访问Hexo的官方文档或GitHub上的Hexo主题仓库来浏览可用的主题。</li><li>选择一个你感兴趣的主题，并查看其文档以了解如何安装和配置。</li></ul></li><li><strong>下载或克隆主题</strong>：<ul><li>根据主题的文档，你可能需要下载主题的ZIP文件，或者通过Git克隆主题的仓库到你的本地计算机。</li></ul></li><li><strong>将主题放入Hexo项目</strong>：<ul><li>将下载或克隆的主题文件夹放入你的Hexo项目中的<code>themes/</code>文件夹内。</li></ul></li><li><strong>更新配置文件</strong>：<ul><li>打开你的Hexo项目中的<code>_config.yml</code>文件。</li><li>找到<code>theme</code>字段，并将其值设置为你刚刚安装的主题的文件夹名。</li></ul></li></ol><p>例如，如果你安装了一个名为<code>landscape</code>的主题，你的<code>_config.yml</code>文件中的<code>theme</code>字段应该像这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">landscape</span><br></code></pre></td></tr></table></figure><ol start="5" type="1"><li><strong>生成和预览</strong>：<ul><li>运行<code>hexo generate</code>（或简写为<code>hexo g</code>）来生成静态文件。</li><li>运行<code>hexo server</code>（或简写为<code>hexo s</code>）来启动本地服务器并预览你的博客。</li></ul></li></ol><h4 id="自定义主题设置">2. <strong>自定义主题设置</strong></h4><p>大多数Hexo主题都允许你通过修改主题的配置文件来自定义博客的外观和行为。以下是如何自定义主题设置的步骤：</p><ol type="1"><li><strong>找到主题配置文件</strong>：<ul><li>在你安装的主题文件夹内，通常会有一个名为<code>_config.yml</code>的文件（有时可能是其他名称，比如<code>config.yml</code>，具体取决于主题）。</li></ul></li><li><strong>编辑主题配置文件</strong>：<ul><li>使用文本编辑器打开主题配置文件。</li><li>根据文件中的注释和说明，修改你感兴趣的设置。</li></ul></li></ol><p>例如，你可能想要修改以下设置：</p><ul><li>网站标题和副标题</li><li>菜单项和导航栏</li><li>侧边栏和小工具</li><li>文章布局和样式</li><li>社交媒体链接和分享按钮</li></ul><ol start="3" type="1"><li><strong>生成和预览更改</strong>：<ul><li>每次修改主题配置文件后，都需要运行<code>hexo generate</code>来生成静态文件。</li><li>然后运行<code>hexo server</code>来预览更改。</li></ul></li><li><strong>高级自定义</strong>：<ul><li>如果你想要进行更高级的自定义（比如修改CSS样式或JavaScript脚本），你可能需要编辑主题文件夹中的其他文件。</li><li>在进行这些更改时，请务必备份原始文件，以便在需要时恢复。</li></ul></li></ol><h4 id="测试和调试">3. <strong>测试和调试</strong></h4><ul><li>在进行自定义时，不断测试你的博客以确保所有功能都按预期工作。</li><li>检查不同设备和浏览器上的显示效果。</li><li>如果遇到问题，请查阅主题的文档或寻求社区的帮助。</li></ul><p>现在你已经知道如何自定义Hexo博客的主题和设置了。</p><h2 id="第六步将博客部署到github-pages">第六步：将博客部署到GitHubPages</h2><h4 id="创建github仓库">1. <strong>创建GitHub仓库</strong></h4><ol type="1"><li><strong>登录GitHub</strong>：<ul><li>使用你的GitHub账户登录到GitHub网站。</li></ul></li><li><strong>创建新仓库</strong>：<ul><li>点击右上角的加号（+）图标，然后选择“Newrepository”（新建仓库）。</li><li>为你的仓库命名，通常使用<code>username.github.io</code>的格式，其中<code>username</code>是你的GitHub用户名。这样命名的仓库会自动启用GitHubPages。</li><li>设置仓库为“Public”（公开），因为GitHub Pages不支持私有仓库。</li><li>初始化仓库时可以选择添加一个README文件，但这对于Hexo部署不是必需的。</li><li>点击“Create repository”（创建仓库）按钮。</li></ul></li></ol><h4 id="配置hexo以部署到github-pages">2. <strong>配置Hexo以部署到GitHubPages</strong></h4><ol type="1"><li><strong>安装<code>hexo-deployer-git</code>插件</strong>：<ul><li>在你的Hexo项目文件夹中，运行以下命令来安装<code>hexo-deployer-git</code>插件，这个插件允许你将Hexo生成的静态文件部署到Git仓库中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save-dev<br></code></pre></td></tr></table></figure></li></ul></li><li><strong>配置部署设置</strong>：<ul><li>打开你的Hexo项目中的<code>_config.yml</code>文件。</li><li>在文件底部添加以下部署（deploy）配置： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">&lt;your-repository-url&gt;</span> <span class="hljs-comment"># 替换为你的GitHub仓库的HTTPS URL</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span> <span class="hljs-comment"># 或者你希望部署到的分支名，通常是main或gh-pages</span><br>  <span class="hljs-attr">message:</span> <span class="hljs-string">&quot;Site updated: <span class="hljs-template-variable">&#123;&#123; now(&#x27;YYYY-MM-DD HH:mm:ss&#x27;) &#125;&#125;</span>&quot;</span> <span class="hljs-comment"># 提交时的消息模板</span><br></code></pre></td></tr></table></figure></li><li>将<code>&lt;your-repository-url&gt;</code>替换为你的GitHub仓库的完整HTTPSURL，例如<code>https://github.com/username/username.github.io.git</code>。</li></ul></li></ol><h4 id="生成静态文件并部署">3. <strong>生成静态文件并部署</strong></h4><ol type="1"><li><strong>生成静态文件</strong>：<ul><li>在你的Hexo项目文件夹中，运行以下命令来生成静态文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br></code></pre></td></tr></table></figure></li><li>或者使用简写命令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g<br></code></pre></td></tr></table></figure></li></ul></li><li><strong>部署到GitHub Pages</strong>：<ul><li>运行以下命令来将生成的静态文件部署到你的GitHub仓库中。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo deploy<br></code></pre></td></tr></table></figure></li><li>首次部署时，你可能需要输入你的GitHub用户名和密码（或者使用GitHub提供的个人访问令牌）。</li></ul></li><li><strong>验证部署</strong>：<ul><li>打开你的浏览器，输入你的GitHubPages网址（通常是<code>https://username.github.io</code>，其中<code>username</code>是你的GitHub用户名）。</li><li>你应该能看到你的Hexo博客已经成功部署到GitHub Pages上了。</li></ul></li></ol><h4 id="更新博客">4. <strong>更新博客</strong></h4><ul><li>每次你更新博客内容时，只需重复生成静态文件和部署的步骤。</li><li>你可以将这两个步骤合并为一个命令，通过添加<code>--deploy</code>选项到<code>hexo generate</code>命令中来实现：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g --deploy<br></code></pre></td></tr></table></figure><ul><li>或者使用简写命令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo gd<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>现在你已经知道如何将Hexo博客部署到GitHub Pages上了。</p><h2 id="第七步维护和更新你的博客">第七步：维护和更新你的博客</h2><h4 id="定期更新内容">1. <strong>定期更新内容</strong></h4><ul><li><strong>撰写新文章</strong>：使用Markdown编写新的博客文章，并保存在Hexo项目的<code>source/_posts/</code>目录下。</li><li><strong>发布文章</strong>：每次撰写完新文章后，运行<code>hexo generate</code>（或<code>hexo g</code>）生成静态文件，然后运行<code>hexo deploy</code>将更新推送到GitHubPages。你也可以使用<code>hexo g --deploy</code>（或<code>hexo gd</code>）一次性完成这两个步骤。</li><li><strong>管理旧文章</strong>：定期回顾和更新你的旧文章，确保它们的信息是最新的，并且没有过时或错误的链接。</li></ul><h4 id="监控和分析">2. <strong>监控和分析</strong></h4><ul><li><strong>使用Google Analytics（谷歌分析）</strong>：在GoogleAnalytics中注册一个账户，并将提供的跟踪代码添加到你的Hexo博客的HTML模板中，以便监控博客的流量和访问者行为。</li><li><strong>检查错误和性能</strong>：定期检查你的博客是否有任何错误（如404页面、断开的链接等），并使用工具（如GooglePageSpeed Insights）来优化博客的性能。</li></ul><h4 id="备份和恢复">3. <strong>备份和恢复</strong></h4><ul><li><strong>定期备份</strong>：定期将你的Hexo项目文件夹和GitHub仓库的内容备份到安全的位置，以防数据丢失。</li><li><strong>恢复数据</strong>：如果出现问题，你可以使用备份的数据来恢复你的博客。</li></ul><h4 id="保持主题和插件更新">4. <strong>保持主题和插件更新</strong></h4><ul><li><strong>更新Hexo</strong>：定期检查Hexo的更新，并运行<code>npm update -g hexo</code>来更新到最新版本。</li><li><strong>更新主题和插件</strong>：同样地，定期检查你使用的主题和插件是否有更新，并按照它们的文档进行更新。</li></ul><h4 id="安全性">5. <strong>安全性</strong></h4><ul><li><strong>保护你的GitHub账户</strong>：确保你的GitHub账户使用了强密码，并启用了双重身份验证。</li><li><strong>避免敏感信息</strong>：不要在博客中发布任何敏感信息，如密码、密钥或私人电子邮件地址。</li></ul><h4 id="与读者互动">6. <strong>与读者互动</strong></h4><ul><li><strong>添加评论系统</strong>：考虑在你的博客中添加一个评论系统，如Disqus或Gitalk，以便与读者互动。</li><li><strong>回复评论和问题</strong>：定期查看并回复读者的评论和问题，以建立和维护与读者的关系。</li></ul><h4 id="优化seo">7. <strong>优化SEO</strong></h4><ul><li><strong>使用关键词</strong>：在撰写文章时，使用相关的关键词，并在标题、元描述和正文中适当地放置它们。</li><li><strong>创建内部链接</strong>：在你的文章之间创建内部链接，以便读者可以轻松地找到相关的内容。</li><li><strong>优化图片</strong>：为图片添加描述性的文件名和alt属性，并使用适当的压缩来优化它们的加载速度。</li></ul><p>现在你已经知道如何维护和更新你的Hexo博客了。</p><h2 id="安装gitalk">安装Gitalk</h2><ol type="1"><li><p><strong>注册Gitalk</strong></p><ul><li>访问<ahref="https://gitalk.github.io/">Gitalk官网</a>，点击“开始使用”按钮，跳转到Github页面。</li><li>在Github页面，点击“使用说明”中的“Click here toregister”进行注册。</li><li>填写相关信息，包括应用名称（Application name）、主页地址（HomepageURL，一般填写域名地址或名称.github.io）、项目描述（Applicationdescription，非必需）和认证回调地址（Authorization callbackURL，一般填写域名地址或名称.github.io）。</li><li>完成注册后，可以修改并更新信息，包括上传新头像和设置背景色。</li></ul></li><li><p><strong>创建Github Application</strong></p><ul><li>登录Github，点击右上角头像，依次进入“Settings”-&gt;“Developersettings”-&gt;“OAuth Apps”-&gt;“New OAuth App”进行基本配置。</li><li>填写应用名称、主页URL、回调URL等信息，并生成Client ID和ClientSecret。</li></ul></li><li><p><strong>配置Hexo博客</strong></p><ul><li>进入Hexo博客的主题配置文件（_config.yml），添加Gitalk配置。</li><li>配置项包括：<ul><li><code>enable</code>: 是否启用Gitalk，设置为true。</li><li><code>github_id</code>: Github仓库所有者。</li><li><code>repo</code>: 存储评论的仓库名称。</li><li><code>client_id</code>: Github Application的Client ID。</li><li><code>client_secret</code>: Github Application的Client Secret。</li><li><code>admin_user</code>:Github仓库所有者和协作者，只有他们可以初始化Github issues。</li><li><code>distraction_free_mode</code>:是否启用无干扰模式，类似于Facebook。</li><li><code>language</code>: 语言设置，如中文设置为zh-CN。</li></ul></li></ul></li></ol><h3 id="二使用gitalk">二、使用Gitalk</h3><ol type="1"><li><p><strong>在Hexo主题中添加Gitalk容器</strong></p><ul><li>进入主题目录的<code>layout</code>-&gt;<code>_partial</code>-&gt;<code>post</code>目录。</li><li>在当前目录下新建一个<code>gitalk.ejs</code>文件，并写入以下代码：</li></ul></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://unpkg.com/gitalk@latest/dist/gitalk.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://unpkg.com/gitalk@latest/dist/gitalk.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://priesttomb.github.io/js/md5.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Gitalk</span>(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">clientID</span>: <span class="hljs-string">&#x27;你的Client ID&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">clientSecret</span>: <span class="hljs-string">&#x27;你的Client Secret&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">repo</span>: <span class="hljs-string">&#x27;你的仓库名称&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">owner</span>: <span class="hljs-string">&#x27;你的Github用户名&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">admin</span>: [<span class="hljs-string">&#x27;你的Github用户名&#x27;</span>],</span><br><span class="language-javascript">  <span class="hljs-attr">id</span>: <span class="hljs-title function_">md5</span>(location.<span class="hljs-property">pathname</span>), <span class="hljs-comment">// 使用md5确保唯一性和长度限制</span></span><br><span class="language-javascript">  <span class="hljs-attr">distractionFreeMode</span>: <span class="hljs-literal">true</span></span><br><span class="language-javascript">&#125;).<span class="hljs-title function_">render</span>(<span class="hljs-string">&#x27;gitalk-container&#x27;</span>)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>注意替换代码中的<code>clientID</code>、<code>clientSecret</code>、<code>repo</code>、<code>owner</code>和<code>admin</code>为实际值。</li></ul><ol start="2" type="1"><li><p><strong>在文章模板中添加Gitalk容器引用</strong></p><ul><li>进入主题目录的<code>layout</code>-&gt;<code>_partial</code>目录，找到<code>article.ejs</code>文件。</li><li>在<code>article.ejs</code>文件的最后面加入以下代码：</li></ul></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;% if(theme.gitalk.enable)&#123; %&gt;<br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;gitalk-container&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  &lt;%- include post/gitalk.ejs %&gt;<br>&lt;% &#125; %&gt;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><p><strong>生成并部署Hexo博客</strong></p><ul><li>在Hexo博客的根目录下，运行<code>hexo generate</code>（或<code>hexo g</code>）生成静态文件。</li><li>运行<code>hexo deploy</code>将更新推送到Github Pages。</li></ul></li><li><p><strong>初始化评论</strong></p><ul><li>访问你的Hexo博客文章页面，登录Github后尝试发表评论。</li><li>评论将作为issues存储在指定的Github仓库中，并可以在仓库的issues页面进行管理。</li></ul></li></ol><p>通过以上步骤，你就可以在Hexo博客中成功安装和使用Gitalk评论系统了。记得定期检查和更新你的Gitalk配置和Github仓库，以确保评论系统的正常运行。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python入门学习笔记</title>
    <link href="/2024/10/25/2024-10-25-Python%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/10/25/2024-10-25-Python%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E7%AC%AC%E4%B8%89%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="第一部分-基础知识">第一部分 基础知识</h1><p><a href="https://zqten.github.io/">回到主頁</a></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># python更新指令<br>pip install --upgrade python<br># pip更新指令<br>python.exe -m pip install --upgrade pip<br># 国内镜像安装<br>pip install pandas -i https://pypi.tuna.tsinghua.edu.cn/simple some-package<br>pip install matplotlib -i https://pypi.tuna.tsinghua.edu.cn/simple some-package<br>pip install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple some-package<br># pip查看可更新包<br>pip list --outdated<br># 批量升级所有包,升级前先确认<br>pip-review --local --interactive<br># 一键升级所有包<br>pip-review --auto<br></code></pre></td></tr></table></figure><p>前面的安装环节网络上讲得比书上的要详细多了，官方文档也讲得很清楚，所以这里就不在这里说了，有兴趣可以去访问官方网站<ahref="https://www.python.org/"><sup>😺</sup></a>。</p><h2 id="第一章-变量和简单的数据类型">第一章 变量和简单的数据类型</h2><h3 id="变量">变量</h3><p>变量命名有一定的规则</p><ul><li>不能是数字开头，比如：<strong>1_message</strong></li><li>不能包含空格，比如：<strong>mess age</strong></li><li>不能是python里面的关键字，比如：print 或 def等，python里面有很多关键字一般你打出来会高亮显示</li><li>最好的变量名应该是既简短又有描述性，比如：name、student_name等等。</li></ul><p>这里message是变量名，'Hello PythonWorld!'是指向message变量的值。变量是可以重复赋值的，但它只会储存最后的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">message = <span class="hljs-string">&#x27;Hello Python World!&#x27;</span><br><span class="hljs-built_in">print</span>(message)<br>Hello Python World!<br><br>message = <span class="hljs-string">&#x27;你好!&#x27;</span><br><span class="hljs-built_in">print</span>(message)<br>你好!<br></code></pre></td></tr></table></figure><h3 id="字符串">字符串</h3><p>有双引号或单引号包裹的内容就称为字符串，有些编程语言只有双引号是字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;This is string.&quot;</span><br><span class="hljs-string">&#x27;This is string.&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>1.方法：title()、upper()、lower()</strong></p><p>方法(method)是python对数据执行的操作，name后面的点(.)是让python对name变量执行<strong>title()</strong>方法指定的操作，这个方法就是把单词的手写字幕改成大写。<strong>upper()</strong>方法是让所有字母变成大写、<strong>lower()</strong>方法是让所有字母变成小写。还有一个方法修改字符串中的指定单词。<strong>replace()</strong>这个方法我们在后面的练习中会用到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;zheng kai nan&quot;</span><br><span class="hljs-built_in">print</span>(name.title())<br>Zheng Kai Nan<br><br>name = <span class="hljs-string">&quot;Zheng Kai Nan&quot;</span><br><span class="hljs-built_in">print</span>(name.upper())<br>ZHENG KAI NAN<br><span class="hljs-built_in">print</span>(name.lower())<br>zheng kai nan<br><br>name = <span class="hljs-string">&quot;zheng kai nan&quot;</span><br>name_01 = name.replace(<span class="hljs-string">&quot;kai nan&quot;</span>, <span class="hljs-string">&quot;ji zhong&quot;</span>)<br><span class="hljs-built_in">print</span>(name)<br><span class="hljs-built_in">print</span>(name_01)<br>zheng kai nan<br>zheng ji zhong<br></code></pre></td></tr></table></figure><p><strong>2.在字符串中插入变量</strong></p><p>这个功能很常用，python的方式是在字符串的引号前面加一个<strong>f</strong> 字母：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">first_name = <span class="hljs-string">&quot;zheng&quot;</span><br>last_name = <span class="hljs-string">&quot;kai nan&quot;</span><br>full_name = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;first_name&#125;</span> <span class="hljs-subst">&#123;last_name&#125;</span>&quot;</span><br><span class="hljs-built_in">print</span>(full_name)<br>zheng kai nan<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Hello,<span class="hljs-subst">&#123;full_name.title()&#125;</span>!&quot;</span>)<br>Hello,Zheng Kai Nan!<br></code></pre></td></tr></table></figure><p>**3.制表符和换行符控制字符串 *</p><p>在字符串中添加<strong>、</strong>*可以缩进和换行，字符串引号前加<strong><code>r</code></strong>可以让取消里面所有转义符号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">message = <span class="hljs-string">&quot;你知道这几种编程语言吗？Python Swift C++ Go Java&quot;</span><br><span class="hljs-built_in">print</span>(message)<br>你知道这几种编程语言吗？Python Swift C++ Go Java<br><br>message = <span class="hljs-string">&quot;\t你知道这几种编程语言吗？Python Swift C++ Go Java&quot;</span><br><span class="hljs-built_in">print</span>(message)<br>     你知道这几种编程语言吗？Python Swift C++ Go Java<br><br>message = <span class="hljs-string">&quot;你知道这几种编程语言吗？\nPython Swift C++ Go Java&quot;</span><br><span class="hljs-built_in">print</span>(message)<br>你知道这几种编程语言吗？<br>Python Swift C++ Go Java<br><br><span class="hljs-comment"># 也可以同时使用</span><br>message = <span class="hljs-string">&quot;你知道这几种编程语言吗？\n\tPython \n\tSwift \n\tC++ \n\tGo \n\tJava&quot;</span><br><span class="hljs-built_in">print</span>(message)<br>你知道这几种编程语言吗？<br>Python <br>Swift <br>C++ <br>Go <br>Java<br><span class="hljs-comment"># 取消转义    </span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">r&quot;\nasd&quot;</span>) <br>\nasd<br></code></pre></td></tr></table></figure><p><strong>4.删除字符串里面的空白rstrip()、lstrip()、strip()</strong></p><p>有时候后输入字符串的时候会多输空格，在python里面多一个空格就意味着两个不同的字符串了。这里有3个方法：分别是<strong>rstrip()、lstrip()、strip()</strong>，<em>rstrip()</em>是删除字符串右边的空格，<em>lstrip()</em>是删除左边的空格，<em>strip()</em>是删除两边的空格。但是这种删除只是暂时的，要想永久删除就要重新赋值给变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">language = <span class="hljs-string">&#x27; python &#x27;</span><br><span class="hljs-built_in">print</span>(language.rstrip())<br><span class="hljs-string">&#x27; python&#x27;</span><br><span class="hljs-built_in">print</span>(language.lstrip())<br><span class="hljs-string">&#x27;python &#x27;</span><br><span class="hljs-built_in">print</span>(language.strip())<br><span class="hljs-string">&#x27;python&#x27;</span><br><span class="hljs-comment"># 重新赋值给变量</span><br>language = language.strip()<br><span class="hljs-built_in">print</span>(language)<br><span class="hljs-string">&#x27;python&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>5.删除前缀和后缀 removeprefix()、removesuffix()</strong></p><p>有些内容有统一的前缀，比如你有很多照片，前缀是某一个时间比如2023.7.25+名字或序号，你就只想要序号或名字就可以用到这个功能，还有就是URL里面的https://这个是网站前缀，就可以用<em>removeprefix()</em>括号里面填写你想删除的前缀，用引号括起来。这种方法的删除也是暂时的，要想永久删除需要重新赋值，和上面的删除空白一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 删除前缀</span><br>Travel_photo = <span class="hljs-string">&quot;2023.7.25-镇远旅游照片&quot;</span><br><span class="hljs-built_in">print</span>(Travel_photo.removeprefix(<span class="hljs-string">&#x27;2023.7.25-&#x27;</span>))<br>镇远旅游照片<br>url = <span class="hljs-string">&quot;https://www.baidu.com&quot;</span><br><span class="hljs-built_in">print</span>(url.removeprefix(<span class="hljs-string">&#x27;https://&#x27;</span>))<br>www.baidu.com<br><br><span class="hljs-comment">#删除后缀</span><br>file_name = <span class="hljs-string">&#x27;abc.jpg&#x27;</span><br><span class="hljs-built_in">print</span>(file_name.removesuffix(<span class="hljs-string">&#x27;.jpg&#x27;</span>))<br>abc<br></code></pre></td></tr></table></figure><h3 id="数">数</h3><p>可以理解为数学里面的数字，用来计算或可视化数据</p><p><strong>1.整数及其运算</strong></p><p>integer()或简写int()表示整数，**+、-、*、/<strong>这几个符号表示加减乘除，还有些复杂的后面会讲到，比如(</strong>)两个星号代表乘方运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2</span> + <span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-number">3</span> ** <span class="hljs-number">2</span><br><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>2.浮点数</strong></p><p>float()表示浮点数，就是带有小数点的数称为浮点数，数字同样都可以应用上面的计算符号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span><br><span class="hljs-number">0.3</span><br></code></pre></td></tr></table></figure><p><strong>3.数字中的下划线</strong></p><p>下划线用在数字中，并不会有其他的效果，只是方便我们更好观察。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">number = <span class="hljs-number">1000_000_000</span><br><span class="hljs-built_in">print</span>(number)<br><span class="hljs-number">10000000000</span><br></code></pre></td></tr></table></figure><p><strong>4.同时给多个变量赋值</strong></p><p>同时给多个变量赋值，需要用逗号将变量名分开，对于要赋给变量的值也需要做同样的事情</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">x,y,z = <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><br>x = <span class="hljs-number">1</span><br>y = <span class="hljs-number">2</span><br>z = <span class="hljs-number">3</span><br><br><span class="hljs-comment"># 错误演示</span><br>x,y,z = <span class="hljs-number">1</span>,<span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(x)<br>发生异常: ValueError x<br><span class="hljs-keyword">not</span> enough values to unpack (expected <span class="hljs-number">3</span>, got <span class="hljs-number">2</span>)<br>  File <span class="hljs-string">&quot;F:\第一章变量和简单数据类型\full_name.py&quot;</span>, line <span class="hljs-number">7</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    x, y, z = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>    ^^^^^^^<br>ValueError: <span class="hljs-keyword">not</span> enough values to unpack (expected <span class="hljs-number">3</span>, got <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p><strong>5.常量</strong></p><p>Python里面没有常量(就是整个程序的生命周期不改变值的“变量”)，一般是用全大写字母来共同与其他程序员形成约定，遇到全大写字母的变量时，视为常量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">NAME = <span class="hljs-string">&quot;太阳&quot;</span><br></code></pre></td></tr></table></figure><p><strong>6.注释</strong></p><p>注释的主要目的是阐述代码要做什么，以及是如何做的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打印出Hello World</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello World&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="小结">小结</h3><p>本章我们学习了如何使用变量，创建了描述性的变量名，学习了字符串是什么，以及如何使用全大写、全小写和首字母大写的方式显示字符串和制表符、换行符。还学习了如何删除字符串中多余的字符和空格，以及字符串中插入变量的方法。还学习了整数和浮点数，还有学习了写注释的目的。</p><h2 id="第二章-列表简介">第二章 列表简介</h2><h3 id="列表是什么">列表是什么</h3><p>列表(list)由一系列按<strong>特定顺序</strong>排列的元素组成，一般给列表命名以复数形式，比如：name就用names。在python中列表用“[]”表示，每个元素用逗号隔开。列表里面有两个东西要搞清楚，一个是索引，一个是元素的值。要访问列表时使用索引和元素值都可以，列表的索引是从0开始的，所以要访问的n个元素就使用n-1的索引值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 列表</span><br>bicycles = [<span class="hljs-string">&#x27;trek&#x27;</span>, <span class="hljs-string">&#x27;cannondale&#x27;</span>, <span class="hljs-string">&#x27;redline&#x27;</span>, <span class="hljs-string">&#x27;specialized&#x27;</span>]<br><span class="hljs-built_in">print</span>(bicycles)<br>[<span class="hljs-string">&#x27;trek&#x27;</span>, <span class="hljs-string">&#x27;cannondale&#x27;</span>, <span class="hljs-string">&#x27;redline&#x27;</span>, <span class="hljs-string">&#x27;specialized&#x27;</span>]<br><span class="hljs-comment"># 利用索引值访问列表元素</span><br><span class="hljs-built_in">print</span>(bicycles[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(bicycles[<span class="hljs-number">3</span>])<br>trek<br>specialized<br><span class="hljs-comment"># 访问列表的倒数第一个元素</span><br><span class="hljs-built_in">print</span>(bicycles[-<span class="hljs-number">1</span>])<br>specialized<br><span class="hljs-comment"># 使用列表里面的元素到其他场景</span><br>message = <span class="hljs-string">f&#x27;我喜欢<span class="hljs-subst">&#123;bicycles[<span class="hljs-number">0</span>]&#125;</span>品牌的摩托车。&#x27;</span><br><span class="hljs-built_in">print</span>(message)<br>我喜欢trek品牌的摩托车。<br></code></pre></td></tr></table></figure><h3 id="修改添加和删除列表元素">修改、添加和删除列表元素</h3><p>大多数列表将是动态的，意味着列表创建后，随着程序的运行将修改、增加、或删除其中的元素。这中间增加有<strong>append()</strong>方法在列表末尾添加元素，<strong>insert()</strong>在列表的指定位置插入元素。删除有<strong>del列表元素</strong>将删除列表元素并且无法在访问这个元素了。<strong>pop()</strong>默认删除列表最后一个元素，也可以指定删除列表中的其他元素，在括号里面填上该元素的索引值就可以了。这里说下，pop()删除的元素可以赋值给一个变量继续使用，不像del不能在赋值和访问了。<strong>remove()</strong>方法是删除一个指定的元素值，列表有多个同样的值的话这个方法只删除第一个，要想全部删除就要使用循环。值得一提的是这个方法和pop()一样删除了的元素可以赋值给一个变量继续使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 修改列表元素</span><br>motorcycles = [<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br><span class="hljs-built_in">print</span>(motorcycles)<br>[<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br>motorcycles[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;da yang&#x27;</span><br><span class="hljs-built_in">print</span>(motorcycles)<br>[<span class="hljs-string">&#x27;da yang&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br><br><span class="hljs-comment"># 添加列表元素</span><br><span class="hljs-comment">## 在列表末尾添加元素</span><br>motorcycles = [<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br><span class="hljs-built_in">print</span>(motorcycles)<br>[<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br>motorcycles.append(<span class="hljs-string">&#x27;da yang&#x27;</span>)<br><span class="hljs-built_in">print</span>(motorcycles)<br>[<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>, <span class="hljs-string">&#x27;da yang&#x27;</span>]<br><span class="hljs-comment">## 在列表的指定位置插入元素</span><br>motorcycles.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;li fan&#x27;</span>)<br><span class="hljs-built_in">print</span>(motorcycles)<br>[<span class="hljs-string">&#x27;li fan&#x27;</span>, <span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>, <span class="hljs-string">&#x27;da yang&#x27;</span>]<br><br><span class="hljs-comment"># 删除列表元素</span><br><span class="hljs-comment">## del方法删除</span><br>motorcycles = [<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br><span class="hljs-built_in">print</span>(motorcycles)<br>[<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br><span class="hljs-keyword">del</span> motorcycles[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(motorcycles)<br>[<span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br><span class="hljs-comment">## pop方法删除</span><br>motorcycles = [<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br><span class="hljs-built_in">print</span>(motorcycles)<br>[<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br>poped_motorcycles = motorcycles.pop()<br><span class="hljs-built_in">print</span>(motorcycles)<br>[<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>]<br><span class="hljs-built_in">print</span>(poped_motorcycles)<br>suzuki<br><span class="hljs-comment">### pop方法删除指定位置的元素</span><br>motorcycles = [<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br><span class="hljs-built_in">print</span>(motorcycles)<br>[<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br>last_motorcycles = motorcycles.pop(<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(motorcycles)<br>[<span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br><span class="hljs-built_in">print</span>(last_motorcycles)<br>honda<br><span class="hljs-comment">## remove()根据值删除元素</span><br>motorcycles = [<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br><span class="hljs-built_in">print</span>(motorcycles)<br>[<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;yamaha&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br>mid_motorcycles = <span class="hljs-string">&#x27;yamaha&#x27;</span><br>motorcycles.remove(mid_motorcycles)<br><span class="hljs-built_in">print</span>(motorcycles)<br>[<span class="hljs-string">&#x27;honda&#x27;</span>, <span class="hljs-string">&#x27;suzuki&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;mid_motorcycles.title()&#125;</span>&#x27;</span>)<br>Yamaha<br></code></pre></td></tr></table></figure><h3 id="列表管理">列表管理</h3><p><strong>1.sort()</strong>方法可以对列表<strong>永久排序</strong>，该方法是将列表按字母顺序或数字从小到大的顺序进行排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">cars = [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>]<br><span class="hljs-built_in">print</span>(cars)<br>[<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>]<br>cars.sort()<br><span class="hljs-built_in">print</span>(cars)<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>]<br><span class="hljs-comment"># 反向排序</span><br>cars.sort(reverse=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(cars)<br>[<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>]<br><span class="hljs-comment"># 反转列表,这是一种快捷方法</span><br>cars = cars[::-<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(cars)<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong>2.sorted()</strong>方法是对列表进行<strong>临时排序</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 临时反向排序</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sorted</span>(cars, reverse=<span class="hljs-literal">True</span>))<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>]<br><span class="hljs-built_in">print</span>(cars)<br>[<span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong>3.reverse()</strong>方法是<strong>永久反转排列</strong>列表里面的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">cars.reverse()<br><span class="hljs-built_in">print</span>(cars)<br>[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong>4.len()</strong>方法可以快速获取列表长度，其显示的是列表内有多少个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(cars))<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>5.enumerate()</strong>函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，<strong>同时列出数据和数据下标</strong>，一般用在for 循环当中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>seq = [<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i, element <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(seq):<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span> i, element<br>...<br><span class="hljs-number">0</span> one<br><span class="hljs-number">1</span> two<br><span class="hljs-number">2</span> three<br></code></pre></td></tr></table></figure><h3 id="小节">小节</h3><p>本章学习了什么是列表，以及如何使用列表内的元素。学习了定义列表，增删改列表内元素，以及如何对列表进行永久排序和临时排序，还学习了反转列表顺序和反向排序。</p><h2 id="第三章-操作列表">第三章 操作列表</h2><h3 id="遍历整个列表">遍历整个列表</h3><p>使用<strong>for</strong>循环可以很轻松的访问整个列表，以及对列表进行操作。这里值得一提的是for循环里面的变量名，在遍历列表是尽可能用列表的单数名，比如列表名为cars，那么for循环的变量尽量写成car。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">magicians = [<span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;david&#x27;</span>, <span class="hljs-string">&#x27;carolina&#x27;</span>]<br><span class="hljs-keyword">for</span> magician <span class="hljs-keyword">in</span> magicians:<br>    <span class="hljs-built_in">print</span>(magician)<br><br>alice<br>david<br>carolina<br><span class="hljs-comment"># 进行其他操作</span><br><span class="hljs-keyword">for</span> magician <span class="hljs-keyword">in</span> magicians:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;magician.title()&#125;</span>,你的表演很精彩！&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;谢谢你，<span class="hljs-subst">&#123;magician.title()&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;感谢你们每一个人的表演&#x27;</span>)<br>Alice,你的表演很精彩！<br>谢谢你，Alice<br>David,你的表演很精彩！<br>谢谢你，David<br>Carolina,你的表演很精彩！<br>谢谢你，Carolina<br>感谢你们每一个人的表演<br></code></pre></td></tr></table></figure><h3 id="创建数值列表">创建数值列表</h3><p><strong>range()</strong>函数可以生成一系列数，但它实际上不会打印最后一个数，这是编程语言中常见的<strong>差一</strong>行为结果，要想打印最后个数需要使用<strong>+1或者是使用比最后一个数大1的数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-comment"># 打印最后一位</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>+<span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><br></code></pre></td></tr></table></figure><p><strong>list()</strong>函数可以将range()的结果直接转换为列表，方法是将range()作为list()的参数，同时range（）还可以指定步长。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">number = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>))<br><span class="hljs-built_in">print</span>(number)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-comment"># 从2开始到11结束，指定步长为2</span><br>even_number = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">11</span>, <span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(even_number)<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]<br><span class="hljs-comment"># 用for循环创建数值列表</span><br>squares = []<br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>):<br>    square = value**<span class="hljs-number">2</span><br>    squares.append(square)<br><span class="hljs-built_in">print</span>(squares)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>, <span class="hljs-number">100</span>]<br></code></pre></td></tr></table></figure><p>使用这几个函数可以对数值列表进行统计<strong>列表作为其参数</strong>，min（）列表里面最小值，max（）列表里面最大值，sum（）列表所有数求和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 简单统计数值列表</span><br>values = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">min</span>(values))<br><span class="hljs-number">0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">max</span>(values))<br><span class="hljs-number">9</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>(values))<br><span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><p><strong>列表推导式</strong>是一种简化方法，这种方法首先指定一个列表名（变量名），然后等号右边用中括号开始，括号内的排列顺序是表达式------for循环，这种方法需要经常练习。比如创建上面数值列表可以写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">squares = [value**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)]<br><span class="hljs-built_in">print</span>(squares)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>, <span class="hljs-number">100</span>]<br><span class="hljs-comment"># 1到50的奇数之和游戏</span><br>jishu_num = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">50</span>, <span class="hljs-number">2</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>(jishu_num))<br><span class="hljs-number">625</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>([jishu <span class="hljs-keyword">for</span> jishu <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">50</span>, <span class="hljs-number">2</span>)]))<br><span class="hljs-number">625</span><br></code></pre></td></tr></table></figure><h3 id="使用列表的一部分">使用列表的一部分</h3><p><strong>切片</strong>，要使用列表的一部分，其实就是使用列表的索引。使用的方法是在调用列表时在列表名后面[0:1]，这代表列表的第一个和第二个值，就是在列表索引值0,1的值。这里面也要注意差一行为。在一个班级需要评出前三名或后三名或部分名单时，切片可以起到很好的作用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 切片</span><br>players = [<span class="hljs-string">&#x27;charles&#x27;</span>, <span class="hljs-string">&#x27;martina&#x27;</span>, <span class="hljs-string">&#x27;michael&#x27;</span>, <span class="hljs-string">&#x27;florence&#x27;</span>, <span class="hljs-string">&#x27;eli&#x27;</span>]<br><span class="hljs-comment"># 索引值1到3的元素因为差一行为，所以并不会打印索引值3的元素</span><br><span class="hljs-built_in">print</span>(players[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])<br>[<span class="hljs-string">&#x27;martina&#x27;</span>, <span class="hljs-string">&#x27;michael&#x27;</span>]<br><span class="hljs-comment"># 索引值0到3的元素</span><br><span class="hljs-built_in">print</span>(players[:<span class="hljs-number">3</span>])<br>[<span class="hljs-string">&#x27;charles&#x27;</span>, <span class="hljs-string">&#x27;martina&#x27;</span>, <span class="hljs-string">&#x27;michael&#x27;</span>]<br><span class="hljs-comment"># 索引值1到列表最后一个的元素</span><br><span class="hljs-built_in">print</span>(players[<span class="hljs-number">1</span>:])<br>[<span class="hljs-string">&#x27;martina&#x27;</span>, <span class="hljs-string">&#x27;michael&#x27;</span>, <span class="hljs-string">&#x27;florence&#x27;</span>, <span class="hljs-string">&#x27;eli&#x27;</span>]<br><span class="hljs-comment"># 索引值0到列表最后一个的元素</span><br><span class="hljs-built_in">print</span>(players[:])<br>[<span class="hljs-string">&#x27;charles&#x27;</span>, <span class="hljs-string">&#x27;martina&#x27;</span>, <span class="hljs-string">&#x27;michael&#x27;</span>, <span class="hljs-string">&#x27;florence&#x27;</span>, <span class="hljs-string">&#x27;eli&#x27;</span>]<br><span class="hljs-comment"># 索引值为列表最后3个的元素</span><br><span class="hljs-built_in">print</span>(players[-<span class="hljs-number">3</span>:])<br>[<span class="hljs-string">&#x27;michael&#x27;</span>, <span class="hljs-string">&#x27;florence&#x27;</span>, <span class="hljs-string">&#x27;eli&#x27;</span>]<br><span class="hljs-comment"># 遍历切片</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;下面是我们的前三名&#x27;</span>)<br><span class="hljs-keyword">for</span> player <span class="hljs-keyword">in</span> players[:<span class="hljs-number">3</span>]:<br>    <span class="hljs-built_in">print</span>(player.title())<br>下面是我们的前三名<br>Charles<br>Martina<br>Michael<br></code></pre></td></tr></table></figure><p><strong>复制列表或列表切片</strong></p><p>需要注意的是不能直接用列表赋值给新变量，这会使他们指向同一个列表，你操作列表，两个变量都会改变，要复制列表时尽量使用切片复制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">players = [<span class="hljs-string">&#x27;charles&#x27;</span>, <span class="hljs-string">&#x27;martina&#x27;</span>, <span class="hljs-string">&#x27;michael&#x27;</span>, <span class="hljs-string">&#x27;florence&#x27;</span>, <span class="hljs-string">&#x27;eli&#x27;</span>]<br><br>yuwen_win = players[:<span class="hljs-number">3</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;语文前三名是：&#x27;</span>)<br><span class="hljs-built_in">print</span>(yuwen_win)<br>语文前三名是：<br>[<span class="hljs-string">&#x27;charles&#x27;</span>, <span class="hljs-string">&#x27;martina&#x27;</span>, <span class="hljs-string">&#x27;michael&#x27;</span>]<br><br>shuxue_win = players[-<span class="hljs-number">3</span>:]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;数学前三名是：&#x27;</span>)<br><span class="hljs-built_in">print</span>(shuxue_win)<br>数学前三名是：<br>[<span class="hljs-string">&#x27;michael&#x27;</span>, <span class="hljs-string">&#x27;florence&#x27;</span>, <span class="hljs-string">&#x27;eli&#x27;</span>]<br><br><span class="hljs-comment"># 需要注意的是不能直接用列表赋值给新变量，这会使他们指向同一个列表，你操作列表，两个变量都会改变</span><br>new_players = players<br><span class="hljs-built_in">print</span>(new_players)<br>[<span class="hljs-string">&#x27;charles&#x27;</span>, <span class="hljs-string">&#x27;martina&#x27;</span>, <span class="hljs-string">&#x27;michael&#x27;</span>, <span class="hljs-string">&#x27;florence&#x27;</span>, <span class="hljs-string">&#x27;eli&#x27;</span>]<br>players.append(<span class="hljs-string">&#x27;AAABBB&#x27;</span>)<br><span class="hljs-built_in">print</span>(new_players)<br>[<span class="hljs-string">&#x27;charles&#x27;</span>, <span class="hljs-string">&#x27;martina&#x27;</span>, <span class="hljs-string">&#x27;michael&#x27;</span>, <span class="hljs-string">&#x27;florence&#x27;</span>, <span class="hljs-string">&#x27;eli&#x27;</span>, <span class="hljs-string">&#x27;AAABBB&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="元组">元组</h3><p>不可以改变值的列表，称为元组（tuple），元组和列表很像，但是列表是用方括号，而元组是用圆括号。虽然不可以修改元组里面的值，但是可以通过重新赋值改变该变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">dimensions = (<span class="hljs-number">200</span>, <span class="hljs-number">50</span>)<br><span class="hljs-built_in">print</span>(dimensions)<br>(<span class="hljs-number">200</span>, <span class="hljs-number">50</span>)<br><span class="hljs-comment"># 遍历</span><br>dimensions = (<span class="hljs-number">400</span>, <span class="hljs-number">50</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dimensions:<br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-number">400</span><br><span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><h3 id="设置代码格式">设置代码格式</h3><p>为什么要设置代码格式？</p><p>代码被阅读的次数远大于编写的次数。在编写完以后的多次阅读中，良好的代码格式可以让阅读花的时间很短。PEP 8是设置代码指南，它建议每级缩进4个空格。每个编辑器（IDE）都可以设置，通常（tab）使用是最多的。每行长度建议不超过79个字符，但这并不是不可逾越的红线，刚开始学的时候不必在意，不过养成这样的习惯后，会对以后和别人合作带来很多方便。空行建议：不同内容建议用一个空行隔开，不建议使用3、4或多个空行来区隔，主要是空行多了影响阅读。</p><h3 id="小结-1">小结</h3><p>本章学习了如何高效的处理列表中的元素，如何使用for循环遍历列表，如何创建简单的数值列表以及对数值列表执行的一些操作。还学习了如何使用切片对列表进行操作和复制，最后还学习了元组，以及设置代码格式。</p><h2 id="第四章-if语句">第四章 if语句</h2><p>编程时经常需要检查一系列的条件，并根据此决定采取什么措施。if语句让你能够检查程序的当前状态，并采取相应的措施。每条if语句的核心都是一个值为True或False的表达式。相应的符号有：==、!=、&lt;、&gt;、&lt;=、&gt;=。关键字有：if、elif、else。在检查多个条件时会用到与、或、非：他们的关键词是：and（两个都为真）、or（一个为真）、not（条件为假）。</p><p><strong>示例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 示例</span><br>cars = [<span class="hljs-string">&#x27;audi&#x27;</span>, <span class="hljs-string">&#x27;bmw&#x27;</span>, <span class="hljs-string">&#x27;subaru&#x27;</span>, <span class="hljs-string">&#x27;toyota&#x27;</span>]<br><span class="hljs-keyword">for</span> car <span class="hljs-keyword">in</span> cars:<br>    <span class="hljs-keyword">if</span> car == <span class="hljs-string">&#x27;bmw&#x27;</span>:<br>        <span class="hljs-built_in">print</span>(car.upper())<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(car.title())<br>Audi<br>BMW<br>Subaru<br>Toyota<br></code></pre></td></tr></table></figure><h3 id="条件测试">条件测试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>car = <span class="hljs-string">&#x27;bmw&#x27;</span><br><span class="hljs-comment"># ==是相等运算符，目的是比较等式两边的值是否相等，相等就是True否则就是False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car == <span class="hljs-string">&#x27;bmw&#x27;</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car == <span class="hljs-string">&#x27;toyota&#x27;</span><br><span class="hljs-literal">False</span><br><span class="hljs-comment"># 检查是忽略大小写可以用到字符串的方法upper（）或title（）等等</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>car.upper() == <span class="hljs-string">&#x27;BMW&#x27;</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>检查是否不等</strong>，这里用的符号是 != 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">requested_topping = <span class="hljs-string">&#x27;mushrooms&#x27;</span><br><span class="hljs-keyword">if</span> requested_topping != <span class="hljs-string">&#x27;anchovies&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hold the anhovies!&#x27;</span>)<br>Hold the anhovies!<br></code></pre></td></tr></table></figure><p><strong>数值比较</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-number">18</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age == <span class="hljs-number">19</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age == <span class="hljs-number">18</span>  <br><span class="hljs-literal">True</span><br><br>answer = <span class="hljs-number">17</span><br><span class="hljs-keyword">if</span> answer != <span class="hljs-number">42</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这个数值不是42，请再次更改变量值！&#x27;</span>)<br>这个数值不是<span class="hljs-number">42</span>，请再次更改变量值！<br></code></pre></td></tr></table></figure><p><strong>检查多个条件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>age_0 = <span class="hljs-number">21</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age_1 = <span class="hljs-number">18</span><br><span class="hljs-comment"># and</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age_0 &gt;=<span class="hljs-number">21</span> <span class="hljs-keyword">and</span> age_1 &gt;=<span class="hljs-number">21</span><br><span class="hljs-literal">False</span><br><span class="hljs-comment"># or</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age_0 &gt;=<span class="hljs-number">21</span> <span class="hljs-keyword">or</span> age_1 &gt;=<span class="hljs-number">21</span>  <br><span class="hljs-literal">True</span><br><br></code></pre></td></tr></table></figure><p><strong>检查某个特定的值是否在或不在列表中</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>number = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">5</span> <span class="hljs-keyword">in</span> number<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">9</span> <span class="hljs-keyword">in</span> number<br><span class="hljs-literal">False</span><br><br>number = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>number_0 = <span class="hljs-number">8</span><br><span class="hljs-keyword">if</span> number_0 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> number:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;number_0&#125;</span>不在我们的数字列表里面。我们把他加进来吧！&#x27;</span>)<br><span class="hljs-number">8</span>不在我们的数字列表里面。我们把他加进来吧！<br></code></pre></td></tr></table></figure><h3 id="if-语句">if 语句</h3><p>在了解了条件测试之后，就可以编写if语句了，具体使用哪一种取决于测试的条件数量。</p><p><strong>最简单的if 语句</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">18</span><br><span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">18</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;你已经成年了。&#x27;</span>)<br>你已经成年了。<br></code></pre></td></tr></table></figure><p><strong>if-else语句</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Python">age = <span class="hljs-number">17</span><br><span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">18</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;你已经成年了。&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;你还是未成年。&#x27;</span>)<br>你还是未成年。<br></code></pre></td></tr></table></figure><p><strong>if-elif-else语句</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-number">12</span><br><span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">4</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;你可以免费观看电影。&#x27;</span>)<br><span class="hljs-keyword">elif</span> age &lt; <span class="hljs-number">18</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;你可以半价购买电影票。&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;你需要购买全票。&#x27;</span>)<br>你可以半价购买电影票。<br><span class="hljs-comment"># 有些情况下是可以省略else这个代码块的</span><br><span class="hljs-keyword">if</span> age &lt; <span class="hljs-number">4</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;你可以免费观看电影。&#x27;</span>)<br><span class="hljs-keyword">elif</span> age &lt; <span class="hljs-number">18</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;你可以半价购买电影票。&#x27;</span>)<br><span class="hljs-keyword">elif</span> age &gt;= <span class="hljs-number">18</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;你需要购买全票。&#x27;</span>)<br>你可以半价购买电影票。<br></code></pre></td></tr></table></figure><h3 id="使用if-语句处理列表">使用if 语句处理列表</h3><p><strong>检查列表里面是否有相应的元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> numbers:<br>    <span class="hljs-keyword">if</span> number == <span class="hljs-number">3</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这个列表里3是中间数&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;这个列表里有<span class="hljs-subst">&#123;number&#125;</span>.&#x27;</span>)<br>这个列表里有<span class="hljs-number">1.</span><br>这个列表里有<span class="hljs-number">2.</span><br>这个列表里<span class="hljs-number">3</span>是中间数<br>这个列表里有<span class="hljs-number">4.</span><br>这个列表里有<span class="hljs-number">5.</span><br></code></pre></td></tr></table></figure><p><strong>确定列表是不是空列表</strong>，列表为空时都是返回False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">numbers = []<br><span class="hljs-keyword">if</span> numbers:<br>    <span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> numbers:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;adding <span class="hljs-subst">&#123;number&#125;</span>&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n所有数字添加了&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;好像这里面没有数字诶!&#x27;</span>)<br>好像这里面没有数字诶!<br></code></pre></td></tr></table></figure><p><strong>多个列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">numbers_0 = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>numbers_1 = [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>]<br><span class="hljs-built_in">print</span>(numbers_0)<br><span class="hljs-built_in">print</span>(numbers_1)<br><span class="hljs-keyword">for</span> number <span class="hljs-keyword">in</span> numbers_1:<br>    <span class="hljs-keyword">if</span> number <span class="hljs-keyword">in</span> numbers_0:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;这两个列表都有 <span class="hljs-subst">&#123;number&#125;</span>&#x27;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;第一个列表里面没有 <span class="hljs-subst">&#123;number&#125;</span> 这个数。&#x27;</span>)<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>[<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>]<br>第一个列表里面没有 <span class="hljs-number">6</span> 这个数。<br>第一个列表里面没有 <span class="hljs-number">7</span> 这个数。<br>第一个列表里面没有 <span class="hljs-number">8</span> 这个数。<br>第一个列表里面没有 <span class="hljs-number">9</span> 这个数。<br>这两个列表都有 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="小结-2">小结</h3><p>本章学习了if语句以及相关的关键词和符号，也使用for循环遍历列表时对某些元素做特出处理。</p><h2 id="第五章-字典">第五章 字典</h2><p>字典就是储存多个有两种相关信息的元素，比如姓名及其年龄，单词及其含义等，字典的信息量也不守限制。</p><h3 id="一个简单的字典">一个简单的字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">alien = &#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;bule&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">5</span>&#125;<br><span class="hljs-built_in">print</span>(alien[<span class="hljs-string">&#x27;color&#x27;</span>])<br><span class="hljs-built_in">print</span>(alien[<span class="hljs-string">&#x27;points&#x27;</span>])<br>bule<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="使用字典">使用字典</h3><p>字典（dictionary）是一系列的<strong>键值对</strong>，每个键都对应一个值，字典用放在花括号{}中的一系列键值对表示。</p><p><strong>访问字典中的值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">alien = &#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;bule&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">5</span>&#125;<br><span class="hljs-built_in">print</span>(alien[<span class="hljs-string">&#x27;color&#x27;</span>])<br>bule<br></code></pre></td></tr></table></figure><p><strong>添加键值对</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">alien[<span class="hljs-string">&#x27;x_position&#x27;</span>] = <span class="hljs-number">0</span><br>alien[<span class="hljs-string">&#x27;y_position&#x27;</span>] = <span class="hljs-number">25</span><br><span class="hljs-built_in">print</span>(alien）<br>&#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;bule&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;x_position&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;y_position&#x27;</span>: <span class="hljs-number">25</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>创建一个空字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">alien = &#123;&#125;<br>alien[<span class="hljs-string">&#x27;color&#x27;</span>] = <span class="hljs-string">&#x27;blue&#x27;</span><br>alien[<span class="hljs-string">&#x27;x_position&#x27;</span>] = <span class="hljs-number">0</span><br>alien[<span class="hljs-string">&#x27;y_position&#x27;</span>] = <span class="hljs-number">25</span><br><span class="hljs-built_in">print</span>(alien)<br>&#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;x_position&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;y_position&#x27;</span>: <span class="hljs-number">25</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>修改字典中的值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">alien[<span class="hljs-string">&#x27;x_position&#x27;</span>] = <span class="hljs-number">10</span><br><span class="hljs-built_in">print</span>(alien)<br>&#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;x_position&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;y_position&#x27;</span>: <span class="hljs-number">25</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>删除键值对</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">alien[<span class="hljs-string">&#x27;speed&#x27;</span>] = <span class="hljs-string">&#x27;medium&#x27;</span><br><span class="hljs-built_in">print</span>(alien)<br>&#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;x_position&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;y_position&#x27;</span>: <span class="hljs-number">25</span>, <span class="hljs-string">&#x27;speed&#x27;</span>: <span class="hljs-string">&#x27;medium&#x27;</span>&#125;<br><span class="hljs-comment"># 删除键值对</span><br><span class="hljs-keyword">del</span> alien[<span class="hljs-string">&#x27;speed&#x27;</span>]<br><span class="hljs-built_in">print</span>(alien)<br>&#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;x_position&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;y_position&#x27;</span>: <span class="hljs-number">25</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>由类似对象组成字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">favonlie_languages = &#123;<br>    <span class="hljs-string">&#x27;jen&#x27;</span>: <span class="hljs-string">&#x27;python&#x27;</span>,<br>    <span class="hljs-string">&#x27;sarah&#x27;</span>: <span class="hljs-string">&#x27;c&#x27;</span>,<br>    <span class="hljs-string">&#x27;edward&#x27;</span>: <span class="hljs-string">&#x27;swift&#x27;</span>,<br>    <span class="hljs-string">&#x27;phil&#x27;</span>: <span class="hljs-string">&#x27;python&#x27;</span>,<br>&#125;<br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> favonlie_languages.items():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;key.title()&#125;</span>喜欢使用<span class="hljs-subst">&#123;value.title()&#125;</span>语言编程！&#x27;</span>)<br>Jen喜欢使用Python语言编程！<br>Sarah喜欢使用C语言编程！<br>Edward喜欢使用Swift语言编程！<br>Phil喜欢使用Python语言编程！<br></code></pre></td></tr></table></figure><p><strong>使用get()方法来访问值</strong></p><p>如果你访问的值不存在字典里，你直接访问的话会出现错误，这时候可以使用get()方法来访问，这个方法可以让你在访问不存在的值的时候返回一个默认值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">alien = &#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;bule&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">5</span>&#125;<br><span class="hljs-built_in">print</span>(alien[<span class="hljs-string">&#x27;speed&#x27;</span>])<br><br>发生异常: KeyError<br><span class="hljs-string">&#x27;speed&#x27;</span><br>  File <span class="hljs-string">&quot;favonlie_languages.py&quot;</span>, line <span class="hljs-number">2</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>    <span class="hljs-built_in">print</span>(alien[<span class="hljs-string">&#x27;speed&#x27;</span>])<br>          ~~~~~^^^^^^^^^<br>KeyError: <span class="hljs-string">&#x27;speed&#x27;</span><br><br><span class="hljs-built_in">print</span>(alien.get(<span class="hljs-string">&#x27;speed&#x27;</span>, <span class="hljs-string">&#x27;不好意思，没有这个索引且没有对应的值&#x27;</span>))<br>不好意思，没有这个索引且没有对应的值<br>alien[<span class="hljs-string">&#x27;speed&#x27;</span>] = <span class="hljs-string">&#x27;medium&#x27;</span><br><span class="hljs-built_in">print</span>(alien.get(<span class="hljs-string">&#x27;speed&#x27;</span>, <span class="hljs-string">&#x27;不好意思，没有这个索引且没有对应的值&#x27;</span>))<br>medium<br></code></pre></td></tr></table></figure><h3 id="遍历字典">遍历字典</h3><p>遍历字典中的内容有3个基本的关键词，items()字典中的键和值，有这个方法需要两个临时变量用于遍历字典、keys()遍历字典中的键、values()遍历字典中的值。</p><p><strong>遍历所有键值对</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">like_number = &#123;<br>    <span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-string">&#x27;8&#x27;</span>,<br>    <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-string">&#x27;7&#x27;</span>,<br>    <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-string">&#x27;5&#x27;</span>,<br>    <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-string">&#x27;9&#x27;</span>,<br>&#125;<br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> like_number.items():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;key.title()&#125;</span> like number is <span class="hljs-subst">&#123;value&#125;</span>&#x27;</span>)<br>A like number <span class="hljs-keyword">is</span> <span class="hljs-number">8</span><br>B like number <span class="hljs-keyword">is</span> <span class="hljs-number">7</span><br>C like number <span class="hljs-keyword">is</span> <span class="hljs-number">5</span><br>D like number <span class="hljs-keyword">is</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p><strong>遍历所有键</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">favonlie_languages = &#123;<br>    <span class="hljs-string">&#x27;jen&#x27;</span>: <span class="hljs-string">&#x27;python&#x27;</span>,<br>    <span class="hljs-string">&#x27;sarah&#x27;</span>: <span class="hljs-string">&#x27;c#&#x27;</span>,<br>    <span class="hljs-string">&#x27;edward&#x27;</span>: <span class="hljs-string">&#x27;swift&#x27;</span>,<br>    <span class="hljs-string">&#x27;phil&#x27;</span>: <span class="hljs-string">&#x27;python&#x27;</span>,<br>&#125;<br><span class="hljs-comment"># 遍历所有键</span><br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> favonlie_languages.keys():<br>    <span class="hljs-built_in">print</span>(name.title())<br>Jen<br>Sarah<br>Edward<br>Phil<br><br><span class="hljs-comment"># 按特定顺序遍历字典中的所有键</span><br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(favonlie_languages.keys()):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Thank you <span class="hljs-subst">&#123;name.title()&#125;</span>,you are welcome!&#x27;</span>)<br>Thank you Edward,you are welcome!<br>Thank you Jen,you are welcome!<br>Thank you Phil,you are welcome!<br>Thank you Sarah,you are welcome!<br><br><span class="hljs-comment"># 遍历字典中的所有值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;编程语言&#x27;</span>)<br><span class="hljs-keyword">for</span> language <span class="hljs-keyword">in</span> favonlie_languages.values():<br>    <span class="hljs-built_in">print</span>(language)<br>编程语言<br>python<br>c<span class="hljs-comment">#</span><br>swift<br>python<br></code></pre></td></tr></table></figure><p><strong>set()</strong>方法用于提取列表或集合中的不同元素，如果有相同的只会提取一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;编程语言&#x27;</span>)<br><span class="hljs-keyword">for</span> language <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span>(favonlie_languages.values()):<br>    <span class="hljs-built_in">print</span>(language.title())<br>编程语言<br>swift<br>c<span class="hljs-comment">#</span><br>python<br><br><span class="hljs-comment"># 集合表现形式，一般用花括号，但里面是没有键值对的，里面的元素表现跟列表一样</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>number = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>number<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="嵌套">嵌套</h3><p>有些时候需要将多个字典储存在列表中或将列表作为值储存在字典中，这中行为就成为嵌套。</p><p><strong>字典列表</strong>就是在列表中储存字典可以应用于用户信息等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python">alien_0 = &#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">5</span>&#125;<br>alien_1 = &#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">10</span>&#125;<br>alien_2 = &#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">15</span>&#125;<br>aliens = [alien_0, alien_1, alien_2]<br><span class="hljs-keyword">for</span> alien <span class="hljs-keyword">in</span> aliens:<br>    <span class="hljs-built_in">print</span>(alien)<br>&#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">5</span>&#125;<br>&#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">10</span>&#125;<br>&#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">15</span>&#125;<br><br><span class="hljs-comment"># 创建一个用于储存外星人的空列表</span><br>aliens = []<br><span class="hljs-comment"># 用for循环创建30个绿色的外星人</span><br><span class="hljs-keyword">for</span> alien_number <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>):<br>    new_alien = &#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;speed&#x27;</span>: <span class="hljs-string">&#x27;slow&#x27;</span>&#125;<br>    aliens.append(new_alien)<br><span class="hljs-comment"># 打印前5个外星人</span><br><span class="hljs-keyword">for</span> alien <span class="hljs-keyword">in</span> aliens[:<span class="hljs-number">5</span>]:<br>    <span class="hljs-built_in">print</span>(alien)<br>&#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;speed&#x27;</span>: <span class="hljs-string">&#x27;slow&#x27;</span>&#125;<br>&#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;speed&#x27;</span>: <span class="hljs-string">&#x27;slow&#x27;</span>&#125;<br>&#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;speed&#x27;</span>: <span class="hljs-string">&#x27;slow&#x27;</span>&#125;<br>&#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;speed&#x27;</span>: <span class="hljs-string">&#x27;slow&#x27;</span>&#125;<br>&#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;speed&#x27;</span>: <span class="hljs-string">&#x27;slow&#x27;</span>&#125;<br><span class="hljs-comment"># 显示创建了多少个外星人</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;创建了多少个外星人:<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(aliens)&#125;</span>&#x27;</span>)<br>创建了多少个外星人:<span class="hljs-number">30</span><br><span class="hljs-comment"># 修改前三个</span><br><span class="hljs-keyword">for</span> alien <span class="hljs-keyword">in</span> aliens[:<span class="hljs-number">3</span>]:<br>    <span class="hljs-keyword">if</span> alien[<span class="hljs-string">&#x27;color&#x27;</span>] == <span class="hljs-string">&#x27;green&#x27;</span>:<br>        alien[<span class="hljs-string">&#x27;color&#x27;</span>] = <span class="hljs-string">&#x27;yellow&#x27;</span><br>        alien[<span class="hljs-string">&#x27;points&#x27;</span>] = <span class="hljs-number">10</span><br>        alien[<span class="hljs-string">&#x27;speed&#x27;</span>] = <span class="hljs-string">&#x27;medium&#x27;</span><br><span class="hljs-keyword">for</span> alien <span class="hljs-keyword">in</span> aliens[:<span class="hljs-number">5</span>]:<br>    <span class="hljs-built_in">print</span>(alien)<br>&#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;speed&#x27;</span>: <span class="hljs-string">&#x27;medium&#x27;</span>&#125;<br>&#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;speed&#x27;</span>: <span class="hljs-string">&#x27;medium&#x27;</span>&#125;<br>&#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&#x27;speed&#x27;</span>: <span class="hljs-string">&#x27;medium&#x27;</span>&#125;<br>&#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;speed&#x27;</span>: <span class="hljs-string">&#x27;slow&#x27;</span>&#125;<br>&#123;<span class="hljs-string">&#x27;color&#x27;</span>: <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;points&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;speed&#x27;</span>: <span class="hljs-string">&#x27;slow&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>在字典中储存列表</strong>可以用于食品配方等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">pizza = &#123;<br>    <span class="hljs-string">&#x27;crust&#x27;</span>: <span class="hljs-string">&#x27;think&#x27;</span>,<br>    <span class="hljs-string">&#x27;toppings&#x27;</span>: [<span class="hljs-string">&#x27;mushrooms&#x27;</span>, <span class="hljs-string">&#x27;extra cheese&#x27;</span>]<br>&#125;<br><span class="hljs-built_in">print</span>(<br>    <span class="hljs-string">f&#x27;You ordered a <span class="hljs-subst">&#123;pizza[<span class="hljs-string">&quot;crust&quot;</span>]&#125;</span>-crust pizza &#x27;</span><span class="hljs-string">&quot;with the following toppings:&quot;</span>)<br><span class="hljs-keyword">for</span> topping <span class="hljs-keyword">in</span> pizza[<span class="hljs-string">&#x27;toppings&#x27;</span>]:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\t<span class="hljs-subst">&#123;topping&#125;</span>&#x27;</span>)<br>You ordered a think-crust pizza <span class="hljs-keyword">with</span> the following toppings:<br>mushrooms<br>extra cheese<br></code></pre></td></tr></table></figure><p><strong>在字典中储存字典</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python">user = &#123;<br>    <span class="hljs-string">&#x27;aeinstein&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;first&#x27;</span>: <span class="hljs-string">&#x27;albert&#x27;</span>,<br>        <span class="hljs-string">&#x27;last&#x27;</span>: <span class="hljs-string">&#x27;einstein&#x27;</span>,<br>        <span class="hljs-string">&#x27;location&#x27;</span>: <span class="hljs-string">&#x27;princeton&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-string">&#x27;mcurie&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;first&#x27;</span>: <span class="hljs-string">&#x27;marie&#x27;</span>,<br>        <span class="hljs-string">&#x27;last&#x27;</span>: <span class="hljs-string">&#x27;curie&#x27;</span>,<br>        <span class="hljs-string">&#x27;location&#x27;</span>: <span class="hljs-string">&#x27;paris&#x27;</span>,<br>    &#125;<br>&#125;<br><span class="hljs-keyword">for</span> username, user_info <span class="hljs-keyword">in</span> user.items():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\nUsername: <span class="hljs-subst">&#123;username&#125;</span>&#x27;</span>)<br>    full_name = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;user_info[<span class="hljs-string">&#x27;first&#x27;</span>]&#125;</span> <span class="hljs-subst">&#123;user_info[<span class="hljs-string">&#x27;last&#x27;</span>]&#125;</span>&quot;</span><br>    location = user_info[<span class="hljs-string">&#x27;location&#x27;</span>]<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\tFullname: <span class="hljs-subst">&#123;full_name.title()&#125;</span>&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\tLocation: <span class="hljs-subst">&#123;location.title()&#125;</span>&#x27;</span>)<br><br>Username: aeinstein<br>Fullname: Albert Einstein<br>Location: Princeton<br><br>Username: mcurie<br>Fullname: Marie Curie<br>Location: Paris<br></code></pre></td></tr></table></figure><h3 id="小结-3">小结</h3><p>本章我们学习了如何定义字典，以及如何使用储存在字典中的信息。然后学习了如何访问和修改字典中的元素，以及如何遍历字典中的信息。还学习了如何遍历字典中的所有键值对、所有的键和所有的值。学习了如何在列表中嵌套字典，在字典中如何嵌套列表，在字典中嵌套字典。</p><h2 id="第六章-用户输入和while循环">第六章 用户输入和while循环</h2><h3 id="input函数的工作原理">input()函数的工作原理</h3><p>input()函数让程序暂停运行，等待用户输入一些文本。获取用户输入后，Python将其赋给一个变量，以便使用。input()函数接受一个参数，即要向用户显示的提示(prompt)。用户输入的内容Python默认为字符串，要想用户输入其他内容需要再input()前面制定类型，比如：要想用户输入的是数值int(input("How old are you"))。<strong>注意：</strong>有些文本编辑器不能运行提示用户输入的程序，要运行他们需要从终端运行。在cmd终端里面直接运行python文件就可以了，<strong>格式是</strong>：路径&gt;py文件名和文件后缀。有些python版本需要使用：路径&gt;python文件名和文件后缀。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>message = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;tell me something, and I will repeat it back to you:&quot;</span>)<br>tell me something, <span class="hljs-keyword">and</span> I will repeat it back to you: hello world<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(message)<br> hello world<br><span class="hljs-meta">&gt;&gt;&gt; </span>  <br></code></pre></td></tr></table></figure><p><strong>使用int()来获取数值输入</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 控制用户输入的内容为数字</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;How old are you: &quot;</span>))<br>How old are you: <span class="hljs-number">36</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>age&gt;<span class="hljs-number">20</span><br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p><strong>求模运算</strong>是个很有用的工具，它将两个数相除并返回余数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">number = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个数，我可以判断是奇数还是偶数：&quot;</span>))<br><span class="hljs-keyword">if</span> number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这个数是偶数！&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这个数是奇数！&quot;</span>)<br>请输入一个数，我可以判断是奇数还是偶数：<span class="hljs-number">50</span><br>这个数是偶数！<br></code></pre></td></tr></table></figure><h3 id="while-循环简介">while 循环简介</h3><p>for 循环用于针对集合中的每个元素执行一个代码块，而 while循环这不断地运行，只到指定的条件不再满足为止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">number = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> number &lt;= <span class="hljs-number">5</span>:<br>    <span class="hljs-built_in">print</span>(number, end=<span class="hljs-string">&quot; &quot;</span>)<br>    number += <span class="hljs-number">1</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>让用户选择何时退出</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 只要用户输入的不是‘quit’和‘exit’该循环就继续运行。</span><br>prompt = <span class="hljs-string">&quot;我们来玩个游戏，看看你知不知道怎么退出这个游戏: &quot;</span><br>message = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">while</span> message != <span class="hljs-string">&quot;quit&quot;</span> <span class="hljs-keyword">or</span> message != <span class="hljs-string">&quot;exit&quot;</span>:<br>    <span class="hljs-comment"># 这里添加了一个lower方法目的是让用户输入的内容都变成小写和下面的if进行判断。</span><br>    message = <span class="hljs-built_in">input</span>(prompt).lower()<br>    <span class="hljs-keyword">if</span> message == <span class="hljs-string">&quot;quit&quot;</span> <span class="hljs-keyword">or</span> message == <span class="hljs-string">&quot;exit&quot;</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;恭喜你！&quot;</span>)<br>        <span class="hljs-keyword">break</span><br>我们来玩个游戏，看看你知不知道怎么退出这个游戏: <span class="hljs-number">2</span><br>我们来玩个游戏，看看你知不知道怎么退出这个游戏: <span class="hljs-number">3</span><br>我们来玩个游戏，看看你知不知道怎么退出这个游戏: ExiT<br>恭喜你！<br><br><span class="hljs-comment"># 使用标志让用户选择何时退出</span><br>prompt = <span class="hljs-string">&quot;我们来玩个游戏，看看你知不知道怎么退出这个游戏: &quot;</span><br>active = <span class="hljs-literal">True</span><br><span class="hljs-keyword">while</span> active:<br>    message = <span class="hljs-built_in">input</span>(prompt).lower()<br>    <span class="hljs-keyword">if</span> message == <span class="hljs-string">&quot;quit&quot;</span> <span class="hljs-keyword">or</span> message == <span class="hljs-string">&quot;exit&quot;</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;恭喜你！&quot;</span>)<br>        active = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;再想想退出的英文是什么？&quot;</span>)<br>我们来玩个游戏，看看你知不知道怎么退出这个游戏: qwe<br>再想想退出的英文是什么？<br>我们来玩个游戏，看看你知不知道怎么退出这个游戏: QUIT<br>恭喜你！<br></code></pre></td></tr></table></figure><p><strong>break 退出循环</strong>，不管条件满不满足，想立即退出 while循环，不再运行后面的代码，可以使用 break语句。上面的例子已经使用过一次了。我们再使用一个特别的例子。break还可以用来退出遍历列表或字典的 for 循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    message = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请你说说你喜欢哪个城市: &quot;</span>).lower()<br>    <span class="hljs-keyword">if</span> message == <span class="hljs-string">&quot;quit&quot;</span> <span class="hljs-keyword">or</span> message == <span class="hljs-string">&quot;exit&quot;</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;再见！&quot;</span>)<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;除了<span class="hljs-subst">&#123;message.title()&#125;</span>还有其他的城市么？&quot;</span>)<br>请你说说你喜欢哪个城市: shang hai<br>除了Shang Hai 还有其他的城市么？<br>请你说说你喜欢哪个城市: QUIT<br>再见！<br></code></pre></td></tr></table></figure><p><strong>在循环中使用 continue</strong></p><p>要返回循环的开头，并根据条件测试的结果决定是否继续执行循环，可以使用continue 语句，他不像 break 那样不执行余下的代码并退出整个循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">number = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> number &lt; <span class="hljs-number">10</span>:<br>    number += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">continue</span><br>    <span class="hljs-built_in">print</span>(number, end=<span class="hljs-string">&quot; &quot;</span>)<br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">9</span> <br></code></pre></td></tr></table></figure><p><strong>避免无线循环</strong></p><p>while 循环一定要设置退出条件，如果没有退出条件，while循环就会无止境的一直执行代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">number = <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> number &lt; <span class="hljs-number">5</span>:<br>    <span class="hljs-built_in">print</span>(number)<br></code></pre></td></tr></table></figure><h3 id="使用-while-循环处理列表和字典">使用 while循环处理列表和字典</h3><p>for 循环是一种遍历列表的有效方式，但不应该在 for循环中修改列表，否则将导致Python难以跟踪其中的元素。要在遍历列表的同时修改它，可使用while 循环。通过将 while循环与列表和字典结合起来使用，可收集、存储并组织大量的输入，供以后查看和使用。<strong>注意</strong>，这里有个有意思的事情，就是列表里面是空的时候它的布尔值是False ，列表里面有元素的时候，它的布尔值是 True 。</p><p><strong>在列表之间移动元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 首先创建一个待验证的用户列表</span><br><span class="hljs-comment"># 和一个用户储存已验证用户的空列表</span><br>unconfirmed_users = [<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;zqten&#x27;</span>, <span class="hljs-string">&#x27;candace&#x27;</span>]<br>confirmed_users = []<br><span class="hljs-comment"># 验证每个用户，直到没有未验证的用户为止</span><br><span class="hljs-comment"># 将每个经过验证的用户添加到已验证用户列表中</span><br><span class="hljs-keyword">while</span> unconfirmed_users:<br>    current_user = unconfirmed_users.pop()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Verifying user: <span class="hljs-subst">&#123;current_user.title()&#125;</span>&#x27;</span>)<br>    confirmed_users.append(current_user)<br><span class="hljs-comment"># 显示所有的已验证的用户</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\nThe following users have been confirmed:&#x27;</span>)<br><span class="hljs-keyword">for</span> confirmed_user <span class="hljs-keyword">in</span> confirmed_users:<br>    <span class="hljs-built_in">print</span>(confirmed_user.title())<br>    <br>Verifying user: Candace<br>Verifying user: Zqten<br>Verifying user: Admin<br><br>The following users have been confirmed:<br>Candace<br>Zqten<br>Admin<br></code></pre></td></tr></table></figure><p><strong>删除为特定值的所有列表元素</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 删除为特定值的所有列表元素</span><br>pets = [<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;goldfish&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;rabbit&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>]<br><span class="hljs-built_in">print</span>(pets)<br><span class="hljs-keyword">while</span> <span class="hljs-string">&#x27;cat&#x27;</span> <span class="hljs-keyword">in</span> pets:<br>    pets.remove(<span class="hljs-string">&#x27;cat&#x27;</span>)<br><span class="hljs-built_in">print</span>(pets)<br>[<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;goldfish&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;rabbit&#x27;</span>, <span class="hljs-string">&#x27;cat&#x27;</span>]<br>[<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-string">&#x27;goldfish&#x27;</span>, <span class="hljs-string">&#x27;rabbit&#x27;</span>]<br></code></pre></td></tr></table></figure><p><strong>使用用户输入填充字典</strong></p><p>可以使用 while 循环提示用户输入任意多的信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用用户输入填充字典</span><br>responses = &#123;&#125;<br><span class="hljs-comment"># 设置一个标志，指出调查是否继续</span><br>polling_active = <span class="hljs-literal">True</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这是调查每个人的爱好，请根据提示输入。&#x27;</span>)<br><span class="hljs-keyword">while</span> polling_active:<br>    <span class="hljs-comment"># 提示输入被调查者的名字和回答</span><br>    name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入被调查者的名字：&quot;</span>)<br>    response = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入被调查者的回答：&quot;</span>)<br>    <span class="hljs-comment"># 将输入的数据储存在字典中</span><br>    responses[name] = response<br>    <span class="hljs-comment"># 询问用户是否继续调查</span><br>    repeat = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;是否有人继续参与调查？（yes/no）&quot;</span>)<br>    <span class="hljs-keyword">if</span> repeat == <span class="hljs-string">&#x27;no&#x27;</span>:<br>        polling_active = <span class="hljs-literal">False</span><br>    <span class="hljs-comment"># 下面这段代码的目的是让用户输入yes和no，输入其他的会提示错误，如果是只判断退出循环条件的话，可以省略下面。</span><br>    <span class="hljs-keyword">elif</span> repeat == <span class="hljs-string">&#x27;yes&#x27;</span>:<br>        <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">while</span> repeat != <span class="hljs-string">&#x27;yes&#x27;</span> <span class="hljs-keyword">or</span> repeat != <span class="hljs-string">&#x27;no&#x27;</span>:<br>            <span class="hljs-keyword">if</span> repeat == <span class="hljs-string">&#x27;no&#x27;</span>:<br>                polling_active = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">elif</span> repeat == <span class="hljs-string">&#x27;yes&#x27;</span>:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;输入错误，请重新输入&quot;</span>)<br>                repeat = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;是否有人继续参与调查？（yes/no）&quot;</span>)<br>        <span class="hljs-keyword">if</span> repeat == <span class="hljs-string">&#x27;no&#x27;</span>:<br>            polling_active = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 输出调查结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n---调查结果---&#x27;</span>)<br><span class="hljs-keyword">for</span> name, response <span class="hljs-keyword">in</span> responses.items():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span>的爱好是: <span class="hljs-subst">&#123;response&#125;</span>。&quot;</span>)<br><br>这是调查每个人的爱好，请根据提示输入。<br>请输入被调查者的名字：刘翔<br>请输入被调查者的回答：跨栏<br>是否有人继续参与调查？（yes/no）不知道<br>输入错误，请重新输入<br>是否有人继续参与调查？（yes/no）yes<br>请输入被调查者的名字：姚明<br>请输入被调查者的回答：篮球<br>是否有人继续参与调查？（yes/no）不知道<br>输入错误，请重新输入<br>是否有人继续参与调查？（yes/no）no<br><br>---调查结果---<br>刘翔的爱好是: 跨栏。<br>姚明的爱好是: 篮球。<br></code></pre></td></tr></table></figure><h3 id="小结-4">小结</h3><p>本章学习了如何在程序中使用 input()来让用户提供信息，如何处理文本和数的输入，以及如何使用 while循环让程序按用户的要求不断地运行。然后见识了多种控制 while循环流程的方式：设置活动标志，使用 break 语句，以及使用 continue语句。还学习了如何使用 while循环在列表之间移动元素，以及如何从列表中删除所有包含特定值的元素。最后，学习了如何结合使用while 循环和字典。</p><h2 id="第七章-函数">第七章 函数</h2><p>函数是带名字的代码块，用于完成具体的工作。要执行函数定义的特定任务，可调用（call）该函数。当需要再程序中多次执行同一项任务时，无须反复编写完成该任务的代码，只需要调用执行该任务的函数，让Python运行其中的代码即可。</p><h3 id="定义函数">定义函数</h3><p>定义函数的关键字是 def。后面是函数名和括号，没有参数时可以是空括号，然后和 for 、while一样也需要冒号，表示定义完成，换行后缩进表示要执行的代码块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">greet_user</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;显示简单的问候语&#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br><br>greet_user()<br>Hello World!<br></code></pre></td></tr></table></figure><p><strong>向函数传递信息</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">greet_user</span>(<span class="hljs-params">uesrname</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;显示简单的问候语&#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Hello,<span class="hljs-subst">&#123;uesrname&#125;</span>!&quot;</span>)<br><br><br>greet_user(<span class="hljs-string">&#x27;zqten&#x27;</span>)<br>Hello,zqten!<br></code></pre></td></tr></table></figure><p><strong>实参和形参</strong></p><p>在上面的例子中，uesrname是一个形参，即函数完成工作所需要的信息。 而'zqten' 则是实参，即在调用函数时传递给函数的信息。</p><h3 id="传递实参">传递实参</h3><p>传递实参有两种方式，一种是按照位置顺序传递，另一种是按照关键字传递。按照关键字传递实参不用考虑顺序，但要记得关键字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">describe_pet</span>(<span class="hljs-params">animal_type, pet_name: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;显示宠物信息&#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\nI have a <span class="hljs-subst">&#123;animal_type&#125;</span>.&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;My <span class="hljs-subst">&#123;animal_type&#125;</span>&#x27;s name is <span class="hljs-subst">&#123;pet_name.title()&#125;</span>.&quot;</span>)<br>    <br><span class="hljs-comment"># 按位置顺序传递实参</span><br>describe_pet(<span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-string">&#x27;duoduo&#x27;</span>)<br>I have a cat.<br>My cat<span class="hljs-string">&#x27;s name is Duoduo.</span><br><span class="hljs-string"></span><br><span class="hljs-string"># 按关键字传递实参</span><br><span class="hljs-string">describe_pet(pet_name=&#x27;</span>nai cha<span class="hljs-string">&#x27;, animal_type=&#x27;</span>dog<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">I have a dog.</span><br><span class="hljs-string">My dog&#x27;</span>s name <span class="hljs-keyword">is</span> Nai Cha.<br></code></pre></td></tr></table></figure><p><strong>默认值</strong></p><p>有些时候你想改变某个参数，但有些时候你想让这个参数先有一个默认值，后面调用的时候看情况是否修改。这种情况可以为参数设置一个默认值。如果没有设置默认值，在调用的时候也没有传递参数Python 就会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">describe_pet</span>(<span class="hljs-params">animal_type=<span class="hljs-string">&#x27;cat&#x27;</span>, pet_name=<span class="hljs-string">&#x27;duo duo&#x27;</span></span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;显示宠物信息&#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\nI have a <span class="hljs-subst">&#123;animal_type&#125;</span>.&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;My <span class="hljs-subst">&#123;animal_type&#125;</span>&#x27;s name is <span class="hljs-subst">&#123;pet_name.title()&#125;</span>.&quot;</span>)<br><span class="hljs-comment"># 有默认值的情况下，可以不用传递参数，也可以看需要传递</span><br>describe_pet()<br>I have a cat.<br>My cat<span class="hljs-string">&#x27;s name is Duo Duo.</span><br><span class="hljs-string"></span><br><span class="hljs-string">describe_pet(&#x27;</span>dog<span class="hljs-string">&#x27;, &#x27;</span>nai cha<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">I have a dog.</span><br><span class="hljs-string">My dog&#x27;</span>s name <span class="hljs-keyword">is</span> Nai Cha.<br></code></pre></td></tr></table></figure><h3 id="返回值">返回值</h3><p>函数并非总是直接显示输出，它还可以处理一些数据，并返回一个或一组值，函数返回的值称为返回值。在函数中<strong>return</strong>语句将值返回到调用函数的那行代码，返回值能让你将程序的大部分繁重工作移到函数中，从而简化程序。</p><p><strong>返回简单的值</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_formatted_name</span>(<span class="hljs-params">first_name, last_name</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;返回标准格式的姓名&#x27;&#x27;&#x27;</span><br>    full_name = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;first_name&#125;</span> <span class="hljs-subst">&#123;last_name&#125;</span>&#x27;</span><br>    <span class="hljs-keyword">return</span> full_name.title()<br><br>musician = get_formatted_name(<span class="hljs-string">&#x27;jimi&#x27;</span>, <span class="hljs-string">&#x27;hendrix&#x27;</span>)<br><span class="hljs-built_in">print</span>(musician)<br>Jimi Hendrix <br></code></pre></td></tr></table></figure><p><strong>让实参变成可选</strong></p><p>就是先设置参数的默认值，但这个默认值是一个空值。不需要的时候就不会出现，需要的时候只需要在调用的时候传递一个参数就可以。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_formatted_name</span>(<span class="hljs-params">first_name, last_name, middle_name=<span class="hljs-string">&#x27;&#x27;</span></span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;返回标准格式的姓名&#x27;&#x27;&#x27;</span><br>    full_name = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;first_name&#125;</span> <span class="hljs-subst">&#123;last_name&#125;</span> <span class="hljs-subst">&#123;middle_name&#125;</span>&#x27;</span><br>    <span class="hljs-keyword">return</span> full_name.title()<br><br>musician = get_formatted_name(<span class="hljs-string">&#x27;jimi&#x27;</span>, <span class="hljs-string">&#x27;hendrix&#x27;</span>)<br><span class="hljs-built_in">print</span>(musician)<br>Jimi Hendrix <br><br>musician = get_formatted_name(<span class="hljs-string">&#x27;jimi&#x27;</span>, <span class="hljs-string">&#x27;hendrix&#x27;</span>, <span class="hljs-string">&#x27;YYY&#x27;</span>)<br><span class="hljs-built_in">print</span>(musician)<br>Jimi Hendrix Yyy<br></code></pre></td></tr></table></figure><p><strong>返回字典</strong></p><p>这里有个小小的细节，就是 age=None 是一个布尔值并且是 False。意思就是这个参数并没有值返回 False。如果为这个参数传递了一个值，它就返回 True 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_person</span>(<span class="hljs-params">first_name, last_name, age=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;返回一个字典，其中包含一个人的信息&#x27;&#x27;&#x27;</span><br>    person = &#123;<span class="hljs-string">&#x27;first&#x27;</span>: first_name, <span class="hljs-string">&#x27;last&#x27;</span>: last_name&#125;<br>    <span class="hljs-keyword">if</span> age:<br>        person[<span class="hljs-string">&#x27;age&#x27;</span>] = age<br>    <span class="hljs-keyword">return</span> person<br><br>musician = build_person(<span class="hljs-string">&#x27;jimi&#x27;</span>, <span class="hljs-string">&#x27;hendeix&#x27;</span>)<br><span class="hljs-built_in">print</span>(musician)<br>&#123;<span class="hljs-string">&#x27;first&#x27;</span>: <span class="hljs-string">&#x27;jimi&#x27;</span>, <span class="hljs-string">&#x27;last&#x27;</span>: <span class="hljs-string">&#x27;hendeix&#x27;</span>&#125;<br><br>musician = build_person(<span class="hljs-string">&#x27;jimi&#x27;</span>, <span class="hljs-string">&#x27;hendeix&#x27;</span>, age=<span class="hljs-number">36</span>)<br><span class="hljs-built_in">print</span>(musician)<br>&#123;<span class="hljs-string">&#x27;first&#x27;</span>: <span class="hljs-string">&#x27;jimi&#x27;</span>, <span class="hljs-string">&#x27;last&#x27;</span>: <span class="hljs-string">&#x27;hendeix&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">36</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>结合使用函数和 while 循环</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_formatted_name</span>(<span class="hljs-params">first_name, last_name, middle_name=<span class="hljs-string">&#x27;&#x27;</span></span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;返回标准格式的姓名&#x27;&#x27;&#x27;</span><br>    full_name = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;first_name&#125;</span> <span class="hljs-subst">&#123;last_name&#125;</span> <span class="hljs-subst">&#123;middle_name&#125;</span>&#x27;</span><br>    <span class="hljs-keyword">return</span> full_name.title()<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\nPleasr tell me your name:&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;(enter &#x27;q&#x27; at any time to quit.)&quot;</span>)<br><br>    f_name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;你姓什么：&quot;</span>)<br>    <span class="hljs-keyword">if</span> f_name == <span class="hljs-string">&#x27;q&#x27;</span>:<br>        <span class="hljs-keyword">break</span><br>    l_name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;你的名字是什么：&quot;</span>)<br>    <span class="hljs-keyword">if</span> l_name == <span class="hljs-string">&#x27;q&#x27;</span>:<br>        <span class="hljs-keyword">break</span><br><br>    full_name = get_formatted_name(f_name, l_name)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;你好, <span class="hljs-subst">&#123;full_name&#125;</span>&quot;</span>)<br><br>Pleasr tell me your name:<br>(enter <span class="hljs-string">&#x27;q&#x27;</span> at <span class="hljs-built_in">any</span> time to quit.)<br>你姓什么：yao<br>你的名字是什么：ming<br>你好, Yao Ming <br><br>Pleasr tell me your name:<br>(enter <span class="hljs-string">&#x27;q&#x27;</span> at <span class="hljs-built_in">any</span> time to quit.)<br>你姓什么：q<br></code></pre></td></tr></table></figure><h3 id="传递列表">传递列表</h3><p>将列表传递给函数后，函数就能直接访问其内容，进行修改等等操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">greet_users</span>(<span class="hljs-params">names</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;向列表中的每个用户发出简单的问候&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello, %s!&#x27;</span> % name)<br><br>username = [<span class="hljs-string">&#x27;zqten&#x27;</span>, <span class="hljs-string">&#x27;zhengjizhong&#x27;</span>, <span class="hljs-string">&#x27;zhengkainan&#x27;</span>, <span class="hljs-string">&#x27;zhouhuarong&#x27;</span>]<br>greet_users(username)<br><br>Hello, zqten!<br>Hello, zhengjizhong!<br>Hello, zhengkainan!<br>Hello, zhouhuarong!<br></code></pre></td></tr></table></figure><p><strong>在函数中修改列表</strong>这个程序演示了一个概念：每个函数都应只负责一项具体工作。这有助于将复杂的任务分解成一系列简单的步骤。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python">unprinted_designs = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br>completed_models = []<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_models</span>(<span class="hljs-params">unprinted_designs, completed_models</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    模拟打印每个数字，直到没有未打印的数字为止</span><br><span class="hljs-string">    打印每个数字后，都将其移到列表completed_models中</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">while</span> unprinted_designs:<br>        current_design = unprinted_designs.pop(<span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Printing model: %s&#x27;</span> % current_design)<br>        completed_models.append(current_design)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_completed_models</span>(<span class="hljs-params">completed_models</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;显示打印好的所有数字&#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\nThe following models have been printed:&#x27;</span>)<br>    <span class="hljs-keyword">for</span> completed_model <span class="hljs-keyword">in</span> completed_models:<br>        <span class="hljs-built_in">print</span>(completed_model, end=<span class="hljs-string">&#x27; &#x27;</span>)<br><br>print_models(unprinted_designs, completed_models)<br>show_completed_models(completed_models)<br><span class="hljs-built_in">print</span>(unprinted_designs)<br><br>Printing model: <span class="hljs-number">1</span><br>Printing model: <span class="hljs-number">2</span><br>Printing model: <span class="hljs-number">3</span><br>Printing model: <span class="hljs-number">4</span><br>Printing model: <span class="hljs-number">5</span><br>Printing model: <span class="hljs-number">6</span><br>Printing model: <span class="hljs-number">7</span><br>Printing model: <span class="hljs-number">8</span><br>Printing model: <span class="hljs-number">9</span><br>Printing model: <span class="hljs-number">10</span><br><br>The following models have been printed:<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> []<br><span class="hljs-comment"># 如果不希望传递后列表为空，可以使用副本传递参数 [:] 切片传递</span><br>print_models(unprinted_designs[:], completed_models)<br>show_completed_models(completed_models)<br><span class="hljs-built_in">print</span>(unprinted_designs)<br><br>Printing model: <span class="hljs-number">1</span><br>Printing model: <span class="hljs-number">2</span><br>Printing model: <span class="hljs-number">3</span><br>Printing model: <span class="hljs-number">4</span><br>Printing model: <span class="hljs-number">5</span><br>Printing model: <span class="hljs-number">6</span><br>Printing model: <span class="hljs-number">7</span><br>Printing model: <span class="hljs-number">8</span><br>Printing model: <span class="hljs-number">9</span><br>Printing model: <span class="hljs-number">10</span><br><br>The following models have been printed:<br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><h3 id="传递任意数量的参数">传递任意数量的参数</h3><p>“ * ”带形参名中的星号让Python创建一个名为形参名的元组，该元组包含函数收到的所有值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_pizza</span>(<span class="hljs-params">*toppings</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;比如概述要制作的披萨&#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\nMaking a pizza with the following toppings:&#x27;</span>)<br>    <span class="hljs-keyword">for</span> topping <span class="hljs-keyword">in</span> toppings:<br>        <span class="hljs-built_in">print</span>(topping)<br><br>make_pizza(<span class="hljs-string">&#x27;aaa&#x27;</span>)<br>make_pizza(<span class="hljs-string">&#x27;mushrooms&#x27;</span>, <span class="hljs-string">&#x27;extra cheese&#x27;</span>)<br><br>Making a pizza <span class="hljs-keyword">with</span> the following toppings:<br>aaa<br><br>Making a pizza <span class="hljs-keyword">with</span> the following toppings:<br>mushrooms<br>extra cheese<br></code></pre></td></tr></table></figure><p><strong>结合使用位置实参和任意数量的实参</strong></p><p>如果要让函数接受不同类型的实参，必须在函数定义中将接纳任意数量实参的形参放在最后。Python先匹配位置和关键字实参，再将余下的实参都收集到最后一个形参中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_pizza</span>(<span class="hljs-params">size, *toppings</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;比如概述要制作的披萨&#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\nMaking a <span class="hljs-subst">&#123;size&#125;</span>-inch pizza with the following toppings:&#x27;</span>)<br>    <span class="hljs-keyword">for</span> topping <span class="hljs-keyword">in</span> toppings:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;- <span class="hljs-subst">&#123;topping&#125;</span>&#x27;</span>)<br><br>make_pizza(<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>)<br>make_pizza(<span class="hljs-number">19</span>, <span class="hljs-string">&#x27;mushrooms&#x27;</span>, <span class="hljs-string">&#x27;extra cheese&#x27;</span>)<br><br>Making a <span class="hljs-number">16</span>-inch pizza <span class="hljs-keyword">with</span> the following toppings:<br>- aaa<br><br>Making a <span class="hljs-number">19</span>-inch pizza <span class="hljs-keyword">with</span> the following toppings:<br>- mushrooms<br>- extra cheese<br></code></pre></td></tr></table></figure><p><strong>使用任意数量的关键字实参</strong></p><p>“ ** ”带形参名中的两个星号让Python创建一个名为形参名的字典，该字典包含函数收到的所有的键值对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">build_profile</span>(<span class="hljs-params">first, last, **user_info</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;创建一个字典，其中包含我们知道的有关用户的一切&#x27;&#x27;&#x27;</span><br>    user_info[<span class="hljs-string">&#x27;first_name&#x27;</span>] = first<br>    user_info[<span class="hljs-string">&#x27;last_name&#x27;</span>] = last<br>    <span class="hljs-keyword">return</span> user_info<br><br>user_profile = build_profile(<br>    <span class="hljs-string">&#x27;zheng&#x27;</span>, <span class="hljs-string">&#x27;ji zhong&#x27;</span>, age=<span class="hljs-number">11</span>, height=<span class="hljs-string">&#x27;147cm&#x27;</span>, weight=<span class="hljs-string">&#x27;48kg&#x27;</span>)<br><span class="hljs-built_in">print</span>(user_profile)<br>&#123;<span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">11</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-string">&#x27;147cm&#x27;</span>, <span class="hljs-string">&#x27;weight&#x27;</span>: <span class="hljs-string">&#x27;48kg&#x27;</span>, <span class="hljs-string">&#x27;first_name&#x27;</span>: <span class="hljs-string">&#x27;zheng&#x27;</span>, <span class="hljs-string">&#x27;last_name&#x27;</span>: <span class="hljs-string">&#x27;ji zhong&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="将函数存储在模块中">将函数存储在模块中</h3><p>将函数存储在称为模块的独立文件中，再将模块导入（import）主程序。可以让代码看起来容易理解。</p><p><strong>导入整个模块</strong></p><p>要让函数是可导入的，得先创建模块。模块是扩展名为 .py 的文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pizza<br>pizza.make_pizza(<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;zhu rou&#x27;</span>)<br>pizza.make_pizza(<span class="hljs-number">17</span>, <span class="hljs-string">&#x27;niu rou&#x27;</span>, <span class="hljs-string">&#x27;bai cai&#x27;</span>)<br><br>Making a <span class="hljs-number">12</span>-inch pizza <span class="hljs-keyword">with</span> the following toppings:<br>- zhu rou<br><br>Making a <span class="hljs-number">17</span>-inch pizza <span class="hljs-keyword">with</span> the following toppings:<br>- niu rou<br>- bai cai<br></code></pre></td></tr></table></figure><p><strong>导入特定的函数</strong></p><p>只想导入模块中的特定函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pizza <span class="hljs-keyword">import</span> make_pizza<br><br>make_pizza(<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;zhu rou&#x27;</span>)<br>make_pizza(<span class="hljs-number">16</span>,<span class="hljs-string">&#x27;niu rou&#x27;</span>, <span class="hljs-string">&#x27;bai cai&#x27;</span>)<br><br>Making a <span class="hljs-number">12</span>-inch pizza <span class="hljs-keyword">with</span> the following toppings:<br>- zhu rou<br><br>Making a <span class="hljs-number">16</span>-inch pizza <span class="hljs-keyword">with</span> the following toppings:<br>- niu rou<br>- bai cai<br></code></pre></td></tr></table></figure><p><strong>使用 as 给函数指定别名</strong></p><p>如果要导入的函数的名称太长或者可能与程序中的其他名称有冲突，可指定简短而独一无二的别名。这个方法也可以应用到给模块指定别名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pizza <span class="hljs-keyword">import</span> make_pizza <span class="hljs-keyword">as</span> mp<br><br>mp(<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;zhu rou&#x27;</span>)<br>mp(<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;niu rou&#x27;</span>, <span class="hljs-string">&#x27;bai cai&#x27;</span>, <span class="hljs-string">&#x27;fanqie&#x27;</span>)<br><br>Making a <span class="hljs-number">12</span>-inch pizza <span class="hljs-keyword">with</span> the following toppings:<br>- zhu rou<br><br>Making a <span class="hljs-number">16</span>-inch pizza <span class="hljs-keyword">with</span> the following toppings:<br>- niu rou<br>- bai cai<br>- fanqie<br><br><span class="hljs-comment"># 也可以给模块指定别名</span><br><span class="hljs-keyword">import</span> pizza <span class="hljs-keyword">as</span> p<br><br>p.make_pizza(<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;zhu rou&#x27;</span>)<br>p.make_pizza(<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;niu rou&#x27;</span>, <span class="hljs-string">&#x27;bai cai&#x27;</span>, <span class="hljs-string">&#x27;fanqie&#x27;</span>)<br><br>Making a <span class="hljs-number">12</span>-inch pizza <span class="hljs-keyword">with</span> the following toppings:<br>- zhu rou<br><br>Making a <span class="hljs-number">16</span>-inch pizza <span class="hljs-keyword">with</span> the following toppings:<br>- niu rou<br>- bai cai<br>- fanqie<br><br></code></pre></td></tr></table></figure><p><strong>导入模块中的所有函数</strong></p><p>这种方法一般慎用，因为如果模块中有函数的名称与当前项目中的名称相同，可能导致意想不到的结果。<strong>最好的做法是要么只导入需要使用的函数，要么导入整个模块并使用点号调用</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pizza <span class="hljs-keyword">import</span> *<br><br>make_pizza(<span class="hljs-number">12</span>, <span class="hljs-string">&#x27;zhu rou&#x27;</span>)<br>make_pizza(<span class="hljs-number">16</span>, <span class="hljs-string">&#x27;niu rou&#x27;</span>, <span class="hljs-string">&#x27;bai cai&#x27;</span>, <span class="hljs-string">&#x27;fanqie&#x27;</span>)<br><br>Making a <span class="hljs-number">12</span>-inch pizza <span class="hljs-keyword">with</span> the following toppings:<br>- zhu rou<br><br>Making a <span class="hljs-number">16</span>-inch pizza <span class="hljs-keyword">with</span> the following toppings:<br>- niu rou<br>- bai cai<br>- fanqie<br><br><span class="hljs-comment"># 导入其他文件夹的模块</span><br><span class="hljs-keyword">from</span> 文件夹名称 <span class="hljs-keyword">import</span> 模块<br><span class="hljs-keyword">from</span> 文件夹名称.模块 <span class="hljs-keyword">import</span> 函数<br></code></pre></td></tr></table></figure><h3 id="函数编写指南">函数编写指南</h3><p>在编写函数时需要牢记几个细节。</p><ul><li>应给函数指定描述性的名称，且只使用小写字母和下划线。</li><li>每个函数都应包含简要阐述其功能的注释。意思就是每个函数都需要编写使用说明的注释。</li><li>形参指定默认值时，等号两边不要有空格。</li><li>如果程序或模块包含多个函数，可以使用两个空行将函数隔开。</li><li>所有的 import语句都应该放在文件开头。唯一的例外是，你要在文件开头编写整个程序的注释。</li><li>导入自己边学的模块时，尽量把模块和程序放在一个文件夹。</li></ul><h3 id="小结-5">小结</h3><p>本章学习了如何编写函数，以及如何传递实参，让函数能够访问完成工作所需的信息。然后学习了如何使用位置实参和关键字实参，以及如何接受任意数量的实参，学习了显示输出的函数和返回值的函数，知道了如何将函数与列表、字典、if、语句和while循环结合起来使用，以及如何将函数存储在称为模块的独立文件中，让程序文件更简单、更易于理解。最后，了解了函数编写指南，遵循这些指南可让程序始终保持良好的结构。程序员的目标之一是编写简单的代码来完成任务，而函数有助于实现这样的目标。</p><h2 id="第八章-类">第八章 类</h2><p>面向对象编程（object-oriented-programming,OOP）是最有效的软件编写方法之一。在基于类创建对象时，每个对象都自动具备类定义的通用行为。然后，你可根据需要赋予每个对象独特的个性。根据类来创建对象称为<strong>实例化</strong>，这让你能够使用类的实例。</p><p>面相对象变成有助于你像程序员那样看世界，并且真正明白自己编写的代码：不仅是各行代码的作用，还有代码背后更宏大的概念。了解类背后的概念可培养逻辑思维能力，让你能够通过编写程序来解决遇到的几乎任何问题。</p><h3 id="创建和使用类">创建和使用类</h3><p><strong>创建Dog类</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建Dog类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;模拟小狗的简单尝试&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;初始化属性name和age&#x27;&#x27;&#x27;</span><br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sit</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;模拟小狗坐下&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> is now sitting.&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">roll_over</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;模拟小狗打滚&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> rolled over.&quot;</span>)<br></code></pre></td></tr></table></figure><p>“<strong>init</strong>()”方法是类的初始化方法，类中的函数称为方法。这个方法的开头和结尾各有两个下划线，这是一种约定，旨在避免Python默认方法与普通方法发生名称冲突。这个方法定义成包含三个形参：self 、name、age。这个方法中self是必不可少，而且必须位于其他形参的前面。self就是类的自身，当我们实例化这个类时，我们传递的参数会通过self 传递给类自身。self.name = name 里面 self前缀的变量可供类中的所有方法使用。</p><p><strong>根据类创建实例</strong></p><p>可以将类视为有关如何创建实例的说明。:yum:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建实例</span><br>my_dog = Dog(<span class="hljs-string">&#x27;duoduo&#x27;</span>, <span class="hljs-number">7</span>)<br><span class="hljs-comment"># my_dog.name 就是访问实例的属性</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;My dog&#x27;s name is <span class="hljs-subst">&#123;my_dog.name&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;My dog&#x27;s age is <span class="hljs-subst">&#123;my_dog.age&#125;</span>&quot;</span>)<br><br>My dog<span class="hljs-string">&#x27;s name is duoduo</span><br><span class="hljs-string">My dog&#x27;</span>s age <span class="hljs-keyword">is</span> <span class="hljs-number">7</span><br><span class="hljs-comment"># 调用方法</span><br>my_dog.sit()<br>my_dog.roll_over()<br><br>duoduo <span class="hljs-keyword">is</span> now sitting.<br>duoduo rolled over.<br><span class="hljs-comment"># 创建多个实例</span><br>your_dog = Dog(<span class="hljs-string">&#x27;Lucy&#x27;</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Your dog&#x27;s name is <span class="hljs-subst">&#123;your_dog.name&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Your dog&#x27;s age is <span class="hljs-subst">&#123;your_dog.age&#125;</span>&quot;</span>)<br>your_dog.sit()<br><br>Your dog<span class="hljs-string">&#x27;s name is Lucy</span><br><span class="hljs-string">Your dog&#x27;</span>s age <span class="hljs-keyword">is</span> <span class="hljs-number">4</span><br>Lucy <span class="hljs-keyword">is</span> now sitting.<br></code></pre></td></tr></table></figure><h3 id="使用类和实例">使用类和实例</h3><p><strong>Car 类</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Car类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;模拟汽车的简单尝试&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, make, model, year</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;初始化描述汽车属性&#x27;&#x27;&#x27;</span><br>        <span class="hljs-variable language_">self</span>.make = make<br>        <span class="hljs-variable language_">self</span>.model = model<br>        <span class="hljs-variable language_">self</span>.year = year<br><span class="hljs-comment"># 给属性默认值</span><br>        <span class="hljs-variable language_">self</span>.odometer = <span class="hljs-number">0</span><br>        <span class="hljs-variable language_">self</span>.oli = <span class="hljs-number">240</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_descriptive_name</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;返回格式规范的描述性信息&#x27;&#x27;&#x27;</span><br>        long_name = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.year&#125;</span>年 <span class="hljs-subst">&#123;self.make&#125;</span>生产<span class="hljs-subst">&#123;self.model&#125;</span>&quot;</span><br>        <span class="hljs-keyword">return</span> long_name.title()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_odometer</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;返回汽车里程数&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;这两车已经行驶了<span class="hljs-subst">&#123;self.odometer&#125;</span>公里了。&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.odometer<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_odometer</span>(<span class="hljs-params">self, mileage</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;设置汽车里程数&#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">if</span> mileage &gt;= <span class="hljs-variable language_">self</span>.odometer:<br>            <span class="hljs-variable language_">self</span>.odometer = mileage<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;这辆车已经行驶了<span class="hljs-subst">&#123;self.odometer&#125;</span>公里了。&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你不能往回设置公里数&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">increment_odometer</span>(<span class="hljs-params">self, mileage</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;增加汽车里程数&#x27;&#x27;&#x27;</span><br>        <span class="hljs-variable language_">self</span>.odometer += mileage<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;这辆车已经行驶了<span class="hljs-subst">&#123;self.odometer&#125;</span>公里了。&quot;</span>)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">car_oli_v</span>(<span class="hljs-params">self, oli</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;描述车辆油箱的容积&#x27;&#x27;&#x27;</span><br>        <span class="hljs-variable language_">self</span>.oli = oli<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;这辆车的油箱容积是<span class="hljs-subst">&#123;self.oli&#125;</span>L.&#x27;</span>)<br><br>my_new_car = Car(<span class="hljs-string">&#x27;奥迪汽车公司&#x27;</span>, <span class="hljs-string">&#x27;奥迪A4&#x27;</span>, <span class="hljs-string">&#x27;2003&#x27;</span>)<br><span class="hljs-built_in">print</span>(my_new_car.get_descriptive_name())<br><span class="hljs-comment"># 修改属性值</span><br>my_new_car.odometer = <span class="hljs-number">1</span><br>my_new_car.read_odometer()<br><span class="hljs-comment"># 通过方法修改属性值</span><br>my_new_car.update_odometer(<span class="hljs-number">34</span>)<br>my_new_car.increment_odometer(<span class="hljs-number">12</span>)<br>my_new_car.update_odometer(<span class="hljs-number">12</span>)<br><br><span class="hljs-number">2003</span>年奥迪汽车公司生产奥迪A4<br>这两车已经行驶了<span class="hljs-number">1</span>公里了。<br>这两车已经行驶了<span class="hljs-number">34</span>公里了。<br>这辆车已经行驶了<span class="hljs-number">46</span>公里了。<br>你不能往回设置公里数<br></code></pre></td></tr></table></figure><h3 id="继承">继承</h3><p>编写类的时候并非总是要从头开始，如果要编写的类是一个已经存在的类的特殊版本，可以使用<strong>继承</strong>。当一个类继承另一个类时，将自动获得后者的素有属性和方法。原有类称为<strong>父类</strong>，而新的类称为<strong>子类</strong>。子类不仅继承了父类的所有属性和方法，还可以定义自己的属性和方法。</p><p><strong>子类初始化方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ElectricCar</span>(<span class="hljs-title class_ inherited__">Car</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;模拟电动汽车&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, make, model, year</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;初始化父类属性,在初始化电动汽车特有的属性&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">super</span>().__init__(make, model, year)<br><br><br>my_leaf = ElectricCar(<span class="hljs-string">&#x27;nissan&#x27;</span>, <span class="hljs-string">&#x27;leaf&#x27;</span>, <span class="hljs-string">&#x27;2024&#x27;</span>)<br><span class="hljs-built_in">print</span>(my_leaf.get_descriptive_name())<br><br><span class="hljs-number">2024</span>年Nissan生产Leaf<br></code></pre></td></tr></table></figure><p><strong>给子类定义属性和方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ElectricCar</span>(<span class="hljs-title class_ inherited__">Car</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;模拟电动汽车&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, make, model, year</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;初始化父类属性,在初始化电动汽车特有的属性&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">super</span>().__init__(make, model, year)<br>        <span class="hljs-variable language_">self</span>.battery_size = <span class="hljs-number">40</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">describe_battery</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;打印一条描述电池容量的消息&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;This car has a <span class="hljs-subst">&#123;self.battery_size&#125;</span>-KWh battery.&#x27;</span>)<br><br><br>my_leaf = ElectricCar(<span class="hljs-string">&#x27;nissan&#x27;</span>, <span class="hljs-string">&#x27;leaf&#x27;</span>, <span class="hljs-string">&#x27;2024&#x27;</span>)<br><span class="hljs-built_in">print</span>(my_leaf.get_descriptive_name())<br>my_leaf.describe_battery()<br><br><span class="hljs-number">2024</span>年Nissan生产Leaf<br>This car has a <span class="hljs-number">40</span>-KWh battery.<br></code></pre></td></tr></table></figure><p><strong>重写父类中的方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ElectricCar</span>(<span class="hljs-title class_ inherited__">Car</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;模拟电动汽车&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, make, model, year</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;初始化父类属性,在初始化电动汽车特有的属性&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">super</span>().__init__(make, model, year)<br>        <span class="hljs-variable language_">self</span>.battery_size = <span class="hljs-number">40</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">describe_battery</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;打印一条描述电池容量的消息&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;This car has a <span class="hljs-subst">&#123;self.battery_size&#125;</span>-KWh battery.&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">car_oli_v</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;电动汽车没有油箱&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;电动汽车没有油箱&quot;</span>)<br><br><br>my_leaf = ElectricCar(<span class="hljs-string">&#x27;nissan&#x27;</span>, <span class="hljs-string">&#x27;leaf&#x27;</span>, <span class="hljs-string">&#x27;2024&#x27;</span>)<br><span class="hljs-built_in">print</span>(my_leaf.get_descriptive_name())<br>my_leaf.describe_battery()<br>my_leaf.car_oli_v()<br><br><span class="hljs-number">2024</span>年Nissan生产Leaf<br>This car has a <span class="hljs-number">40</span>-KWh battery.<br>电动汽车没有油箱<br></code></pre></td></tr></table></figure><p><strong>将实例用作属性</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ElectricCar</span>(<span class="hljs-title class_ inherited__">Car</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;模拟电动汽车&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, make, model, year</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;初始化父类属性,在初始化电动汽车特有的属性&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">super</span>().__init__(make, model, year)<br>        <span class="hljs-variable language_">self</span>.battery = Battery()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">car_oli_v</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;电动汽车没有油箱&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;电动汽车没有油箱&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Battery</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, battery_size=<span class="hljs-number">40</span></span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;初始化电池的属性&#x27;&#x27;&#x27;</span><br>        <span class="hljs-variable language_">self</span>.battery_size = battery_size<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">describe_battery</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;打印一条描述电池容量的消息&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;This car has a <span class="hljs-subst">&#123;self.battery_size&#125;</span>-KWh battery.&#x27;</span>)<br><br><br>my_leaf = ElectricCar(<span class="hljs-string">&#x27;nissan&#x27;</span>, <span class="hljs-string">&#x27;leaf&#x27;</span>, <span class="hljs-string">&#x27;2024&#x27;</span>)<br><span class="hljs-built_in">print</span>(my_leaf.get_descriptive_name())<br>my_leaf.battery.describe_battery()<br><br><span class="hljs-number">2024</span>年Nissan生产Leaf<br>This car has a <span class="hljs-number">40</span>-KWh battery.<br></code></pre></td></tr></table></figure><h3 id="导入类">导入类</h3><p>主要目的是让文件整洁，我们可以将类存储在模块中，然后在主程序导入所需的模块。我们需要整理一下代码，把上面我们学的三个类都复制到一个文件，命名为car.py 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Car类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;模拟汽车的简单尝试&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, make, model, year</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;初始化描述汽车属性&#x27;&#x27;&#x27;</span><br>        <span class="hljs-variable language_">self</span>.make = make<br>        <span class="hljs-variable language_">self</span>.model = model<br>        <span class="hljs-variable language_">self</span>.year = year<br>        <span class="hljs-variable language_">self</span>.odometer = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_descriptive_name</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;返回格式规范的描述性信息&#x27;&#x27;&#x27;</span><br>        long_name = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.year&#125;</span>年<span class="hljs-subst">&#123;self.make&#125;</span>生产<span class="hljs-subst">&#123;self.model&#125;</span>&quot;</span><br>        <span class="hljs-keyword">return</span> long_name.title()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_odometer</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;返回汽车里程数&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;这辆车已经行驶了<span class="hljs-subst">&#123;self.odometer&#125;</span>公里了。&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.odometer<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_odometer</span>(<span class="hljs-params">self, mileage</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;设置汽车里程数&#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">if</span> mileage &gt;= <span class="hljs-variable language_">self</span>.odometer:<br>            <span class="hljs-variable language_">self</span>.odometer = mileage<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;这辆车已经行驶了<span class="hljs-subst">&#123;self.odometer&#125;</span>公里了。&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你不能往回设置公里数&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">increment_odometer</span>(<span class="hljs-params">self, mileage</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;增加汽车里程数&#x27;&#x27;&#x27;</span><br>        <span class="hljs-variable language_">self</span>.odometer += mileage<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;这辆车已经行驶了<span class="hljs-subst">&#123;self.odometer&#125;</span>公里了。&quot;</span>)<br>        <br><span class="hljs-comment"># 电池模组</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Battery</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, battery_size=<span class="hljs-number">40</span>, car_model_isoli=<span class="hljs-literal">False</span></span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;初始化电池的属性&#x27;&#x27;&#x27;</span><br>        <span class="hljs-variable language_">self</span>.battery_size = battery_size<br>        <span class="hljs-string">&#x27;&#x27;&#x27;默认是电动汽车,如果是汽油车可以设置会Ture.&#x27;&#x27;&#x27;</span><br>        <span class="hljs-variable language_">self</span>.car_model_isoli = car_model_isoli<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">describe_battery</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;打印一条描述电池容量的消息&#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.car_model_isoli <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;这是一辆油车，没有电池.&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;This car has a <span class="hljs-subst">&#123;self.battery_size&#125;</span>-KWh battery.&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update_battery</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;升级电池容量&#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.battery_size != <span class="hljs-number">65</span>:<br>            <span class="hljs-variable language_">self</span>.battery_size = <span class="hljs-number">65</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_range</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;打印一条消息，指出汽车的续航里程&#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.battery_size == <span class="hljs-number">40</span>:<br>            <span class="hljs-built_in">range</span> = <span class="hljs-number">150</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-variable language_">self</span>.battery_size == <span class="hljs-number">65</span>:<br>            <span class="hljs-built_in">range</span> = <span class="hljs-number">225</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;这辆车的续航里程为<span class="hljs-subst">&#123;<span class="hljs-built_in">range</span>&#125;</span>公里.&#x27;</span>)<br><br><span class="hljs-comment"># 电动车</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ElectricCar</span>(<span class="hljs-title class_ inherited__">Car</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;模拟电动汽车&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, make, model, year</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;初始化父类属性,在初始化电动汽车特有的属性&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">super</span>().__init__(make, model, year)<br>        <span class="hljs-variable language_">self</span>.battery = Battery()<br></code></pre></td></tr></table></figure><p><strong>导入单个类</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> car <span class="hljs-keyword">import</span> Car<br></code></pre></td></tr></table></figure><p><strong>导入多个类</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> car <span class="hljs-keyword">import</span> Car, ElectricCar<br></code></pre></td></tr></table></figure><p><strong>导入整个模块</strong></p><p>这里我把上面的代码分成了两个文件，Car类单独储存成 car.py，电池模组和电动车储存为 electric_car.py 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> car<br><span class="hljs-comment"># 用法就是用点引用该模块的类</span><br>my_car = car.Car(<span class="hljs-string">&quot;柳州五菱&quot;</span>, <span class="hljs-string">&quot;五菱之光&quot;</span>, <span class="hljs-number">2008</span>)<br><br><span class="hljs-comment"># 还有下面这种方法，但是不推荐用，因为可能会引起很多难以诊断的错误，比如出现同名的类</span><br><span class="hljs-comment"># 这种方法是导入模块的所有类</span><br><span class="hljs-keyword">from</span> car <span class="hljs-keyword">import</span> *<br></code></pre></td></tr></table></figure><p><strong>使用别名</strong></p><p>就是给导入的模块或类更改使用名，这并不会影响该模块和类的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 给模块使用别名</span><br><span class="hljs-keyword">import</span> electric_car <span class="hljs-keyword">as</span> ec<br><span class="hljs-comment"># 给类使用别名</span><br><span class="hljs-keyword">from</span> electric_car <span class="hljs-keyword">import</span> ElectricCar <span class="hljs-keyword">as</span> EC<br></code></pre></td></tr></table></figure><h3 id="合适的工作流程">合适的工作流程</h3><p>首先尝试在一个文件中完成所有工作，确定一切都能正确运行后，在将类移到独立的模块中。</p><p>这里讲一下 <strong>VMC</strong> 模式：</p><ul><li>V： 就是视窗，用户界面等可视化的代码。</li><li>M：就是模块或类等等的代码。</li><li>C：就是整个程序的运行逻辑，流程控制等等的代码。</li></ul><p>这个模式可以简单的理解为建立三个文件夹，分别存放这三种类型的文件。这样可以让自己的代码更加简洁高效，别人理解也更容易。</p><h3 id="python标准库">Python标准库</h3><p>Python标准库是一组模块，在安装Python时已经包含在内了。我们可以使用标准可中的任何函数和类。查看Python标准库，可以在命令行输入<strong>help("modules")</strong> 命令。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 随机数模组，返回两个数之间的随机一个数。</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint<br><span class="hljs-meta">&gt;&gt;&gt; </span>randint(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>)<br><span class="hljs-number">4</span>   <br><span class="hljs-comment"># 返回一个列表里随机一个元素</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choice <br><span class="hljs-meta">&gt;&gt;&gt; </span>players = [<span class="hljs-string">&#x27;aaa&#x27;</span>,<span class="hljs-string">&#x27;bbb&#x27;</span>,<span class="hljs-string">&#x27;ccc&#x27;</span>,<span class="hljs-string">&#x27;ddd&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>choice(players)<br><span class="hljs-string">&#x27;ccc&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="类的编程风格">类的编程风格</h3><p>编写复杂程序时采用以下几项：</p><ul><li>类名：驼峰命名法。例：MyNewCar 。类名不使用下划线。</li><li>模块名和实例名都采用全小写格式，并在单词之间采用下划线。</li><li>每个类都要在定义后面和函数一样需要描述类功能的文档字符串。</li><li>当需要导入标准库中的模块和自己编写的模块时，优先导入标准库中的模块，在导入自己编写的模块。</li></ul><h3 id="小结-6">小结</h3><p>本章我们学习了如何编写类，如何使用属性在类中存储的信息，以及如何编写方法让类具备所需的行为。然后学习了init初始化方法。了解了如何修改实例的属性，包括直接修改以及通过方法修改。还了解到使用继承可简化相关类的创建工作，将一个类的实例用作另一个类的属性能让类更简洁。明白了，通过将类存储在模块（文件）中，并在需要使用这些类的文件中导入它们，可让项目变的更简洁。开始了解python标准库，还看了一个random模块，最后学习了编写类时应遵循的Python约定。</p><h2 id="第九章-文件和异常">第九章 文件和异常</h2><p>处理文件，让程序能够快速地分析大量数据；错误处理，避免程序在面对意外情况时崩溃；异常是Python创建特殊对象，用于管理程序运行时出现的错误；还将学习使用json 模块保存用户数据，以免这些数据在程序结束运行后丢失。</p><h3 id="读取文件">读取文件</h3><p>读取文件对数据分析应用程序很有用。要使用文本文件中的信息，首先需要将信息读取到内存中。既可以一次性读取文件的全部内容，也可以逐行读取。</p><p><strong>读取文件的全部内容</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-params">#</span> 这是一个txt文件<br>3.1415926535<br>  8979323846<br>  2643383279<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取文件</span><br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-comment"># 这里值得注意的是VScode里面用的斜杠是反的</span><br>path = Path(<span class="hljs-string">&quot;E:/text_files/pi_digits.txt&quot;</span>)<br>contents = path.read_text()<br><span class="hljs-comment"># 删除文档中的空格</span><br><span class="hljs-comment"># contents = contents.strip()</span><br><span class="hljs-built_in">print</span>(contents)<br><br><span class="hljs-number">3.1415926535</span><br>  <span class="hljs-number">8979323846</span><br>  <span class="hljs-number">2643383279</span><br></code></pre></td></tr></table></figure><p><strong>相对文件路径和绝对文件路径</strong></p><p><strong>相对文件路径</strong>让 Python到相对于当前运行的程序所在目录的指定位置去查找。比如上面的文件可以这样读取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br>path = Path(<span class="hljs-string">&quot;text_files/pi_digits.txt&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>绝对文件路径</strong>可以读取系统中任何地方的文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br>path = Path(<span class="hljs-string">&quot;E:/text_files/pi_digits.txt&quot;</span>)<br></code></pre></td></tr></table></figure><p>现在最简单的做法是，要么将数据文件存储在程序文件所在的目录中，要么将其存储在存续文件所在目录下的一个文件夹中。</p><p><strong>注意</strong>：在显示文件路径时，windows 系统使用反斜杠（ ）而不是斜杠（ / ）但是你在代码中应该始终使用斜杠（ /），即便在windows系统中也是如此。在与你或其他用户的系统交互时，pathlib库会自动使用正确的路径表示方法。</p><p><strong>访问文件中的各行</strong></p><p>使用 <strong>splitlines()</strong>方法可以将字符串转换为一系列行，在使用 for循环遍历文件中的每一行，splitlines()方法返回一个列表，其中包含文件中所有的行。可以把这个列表赋值给变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br>path = Path(<span class="hljs-string">&quot;E:/text_files/pi_digits.txt&quot;</span>)<br>contents = path.read_text()<br>lines = contents.splitlines()<br><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>    <span class="hljs-built_in">print</span>(line)<br><br><span class="hljs-number">3.1415926535</span><br>  <span class="hljs-number">8979323846</span><br>  <span class="hljs-number">2643383279</span><br></code></pre></td></tr></table></figure><p><strong>使用文件的内容</strong></p><p>读取文件后才能使用这些数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br>path = Path(<span class="hljs-string">&quot;E:/text_files/pi_digits.txt&quot;</span>)<br>contents = path.read_text()<br>pi_string = <span class="hljs-string">&#x27;&#x27;</span><br>lines = contents.splitlines()<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>    pi_string += line<br><br><span class="hljs-built_in">print</span>(pi_string)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(pi_string))<br><span class="hljs-number">3.1415926535</span>  <span class="hljs-number">8979323846</span>  <span class="hljs-number">2643383279</span><br><span class="hljs-number">36</span><br><br><span class="hljs-comment"># 删除左边空格</span><br>--snip--<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>    pi_string += line.lstrip()<br><br><span class="hljs-built_in">print</span>(pi_string)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(pi_string))<br><span class="hljs-number">3.141592653589793238462643383279</span><br><span class="hljs-number">32</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：读取文本文件时，python将其中的所有文本都解释为字符串。如果读取的是数，并且要将其作为数字使用，就必须使用int() 函数将其转换为整数，或者使用 float() 函数将其转为浮点数。</p><p><strong>大型文件</strong>可以做切片等列表的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">--snip--<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>    pi_string += line.lstrip()<br><br><span class="hljs-built_in">print</span>(pi_string[:<span class="hljs-number">10</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(pi_string))<br><span class="hljs-number">3.14159265</span><br><span class="hljs-number">32</span><br></code></pre></td></tr></table></figure><p><strong>趣味小练习</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 圆周率中包含你的生日吗</span><br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br>path = Path(<span class="hljs-string">&quot;pi_million_digits.txt&quot;</span>)<br>contents = path.read_text()<br><br>pi_string = <span class="hljs-string">&#x27;&#x27;</span><br>lines = contents.splitlines()<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:<br>    pi_string += line.strip()<br><br>birthday = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;你的生日如(20200506):&quot;</span>)<br><span class="hljs-keyword">if</span> birthday <span class="hljs-keyword">in</span> pi_string:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;圆周率包含了你的生日&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;圆周率没有你的生日哦...&quot;</span>)<br>    <br>你的生日如(<span class="hljs-number">20200506</span>):<span class="hljs-number">20200506</span><br>圆周率没有你的生日哦...<br></code></pre></td></tr></table></figure><h3 id="写入文件">写入文件</h3><p>保存数据的最简单的方式之一是将其写入文件。</p><p><strong>写入一行</strong></p><p><strong>注意</strong>：在python调用 <strong>write_text()</strong>方法时，如果指定文件已存在，这个方法会将其内容<strong>替换</strong>为你要写入的内容。<strong>replace()</strong>方法可以将字符串中的特定单词替换为另一个单词。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 写入一行文字</span><br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br>path = Path(<span class="hljs-string">&#x27;programming.txt&#x27;</span>)<br>path.write_text(<span class="hljs-string">&quot;hello world&quot;</span>)<br><br>programming.txt<br>hello world<br><span class="hljs-comment"># 替换字符串 replace()</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-string">&#x27;How are you?&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a.replace(<span class="hljs-string">&#x27;you&#x27;</span>,<span class="hljs-string">&#x27;me&#x27;</span>)<br><span class="hljs-string">&#x27;How are me?&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：Python只能将字符串写入文本，如果要将数值数据存储到文本文件中，须使用 str()函数将其转换为字符串格式。</p><p><strong>写入多行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br>path = Path(<span class="hljs-string">&#x27;programming.txt&#x27;</span>)<br>contents = <span class="hljs-string">&quot;nihao&quot;</span><br>contents += <span class="hljs-string">&quot;\nwohao&quot;</span><br>contents += <span class="hljs-string">&quot;\ndajiahao&quot;</span><br>path.write_text(contents)<br><br>programming.txt<br>nihao<br>wohao<br>dajiahao<br></code></pre></td></tr></table></figure><p><strong>趣味小练习</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 重复写入多个词语</span><br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br>path = Path(<span class="hljs-string">&quot;guest.txt&quot;</span>)<br>n = <span class="hljs-number">0</span><br>c = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">while</span> n != <span class="hljs-number">5</span>:<br>    b = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入内容：&quot;</span>)<br>    c += <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;b&#125;</span>\n&quot;</span><br>    n += <span class="hljs-number">1</span><br>    path.write_text(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;c&#125;</span>&quot;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="异常">异常</h3><p>异常是使用 try-except代码块处理的。也就是说你运行一段代码，如过出错了会根据你编写的代码执行，如果没有对异常进行处理，程序出错了就会停止。<strong>如果你运行一段代码出错，编辑器会提示你是什么错误，你可以针对这个错误给出处理方法，就像下面的0 不能作为除数的错误是：ZeroDivisionError</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-number">5</span>/<span class="hljs-number">0</span>)<br>ZeroDivisionError: division by zero<br></code></pre></td></tr></table></figure><p><strong>使用 try-except 代码块</strong></p><p>当你认为可能会发生错误的时候，可以使用这个代码块来处理可能引发的错误。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-number">5</span>/<span class="hljs-number">0</span>)<br><span class="hljs-keyword">except</span> ZeroDivisionError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;0不能作为除数。&quot;</span>)<br>    <br><span class="hljs-number">0</span>不能作为除数。<br></code></pre></td></tr></table></figure><p><strong>处理 FileNotFoundError 异常</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br>path = Path(<span class="hljs-string">&quot;alice.txt&quot;</span>)<br><span class="hljs-keyword">try</span>:<br>    contents = path.read_text(encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><span class="hljs-keyword">except</span> FileNotFoundError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没有找到这个文件。&quot;</span>)<br><br>没有找到这个文件。<br></code></pre></td></tr></table></figure><p><strong>分析文本</strong></p><p>split() 方法是把一个很长的字符串转换成很多单词的列表的一个方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br>path = Path(<span class="hljs-string">&quot;alice.txt&quot;</span>)<br><span class="hljs-keyword">try</span>:<br>    contents = path.read_text(encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><span class="hljs-keyword">except</span> FileNotFoundError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没有找到这个文件。&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-comment"># 计算文件大概包含多少个单词</span><br>    words = contents.split()<br>    num_words = <span class="hljs-built_in">len</span>(words)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;The file <span class="hljs-subst">&#123;path&#125;</span> has about <span class="hljs-subst">&#123;num_words&#125;</span> words&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>读取多个文件</strong></p><p>利用函数我们可以读取多个文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">count_words</span>(<span class="hljs-params">path</span>):<br>    <span class="hljs-keyword">try</span>:<br>        contents = path.read_text(encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-keyword">except</span> FileNotFoundError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;没有找到<span class="hljs-subst">&#123;path&#125;</span>这个文件。&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 计算文件大概包含多少个单词</span><br>        words = contents.split()<br>        num_words = <span class="hljs-built_in">len</span>(words)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;The file <span class="hljs-subst">&#123;path&#125;</span> has about <span class="hljs-subst">&#123;num_words&#125;</span> words&quot;</span>)<br><br><br>filenames = [<span class="hljs-string">&#x27;alice.txt&#x27;</span>, <span class="hljs-string">&#x27;little_women.txt&#x27;</span>, <span class="hljs-string">&#x27;moby_dick.txt&#x27;</span>, <span class="hljs-string">&#x27;kkk.txt&#x27;</span>]<br><span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> filenames:<br>    path = Path(filename)<br>    count_words(path)<br>   <br>The file alice.txt has about <span class="hljs-number">29594</span> words<br>The file little_women.txt has about <span class="hljs-number">189142</span> words<br>The file moby_dick.txt has about <span class="hljs-number">215864</span> words<br>没有找到kkk.txt这个文件。<br></code></pre></td></tr></table></figure><p><strong>静默失败</strong></p><p>并非每次错误都需要告诉用户，有时候有错误什么也不做，但是就是让程序继续运行可以使用pass 语句。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">count_words</span>(<span class="hljs-params">path</span>):<br>    <span class="hljs-keyword">try</span>:<br>        contents = path.read_text(encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-keyword">except</span> FileNotFoundError:<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 计算文件大概包含多少个单词</span><br>        words = contents.split()<br>        num_words = <span class="hljs-built_in">len</span>(words)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;The file <span class="hljs-subst">&#123;path&#125;</span> has about <span class="hljs-subst">&#123;num_words&#125;</span> words&quot;</span>)<br><br>filenames = [<span class="hljs-string">&#x27;alice.txt&#x27;</span>, <span class="hljs-string">&#x27;little_women.txt&#x27;</span>, <span class="hljs-string">&#x27;moby_dick.txt&#x27;</span>, <span class="hljs-string">&#x27;kkk.txt&#x27;</span>]<br><span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> filenames:<br>    path = Path(filename)<br>    count_words(path)<br><br>The file alice.txt has about <span class="hljs-number">29594</span> words<br>The file little_women.txt has about <span class="hljs-number">189142</span> words<br>The file moby_dick.txt has about <span class="hljs-number">215864</span> words<br></code></pre></td></tr></table></figure><h3 id="存储数据">存储数据</h3><p>json模块能够将简单的Python数据结构转换为JSON格式的字符串，并在程序再次运行时从文件中加载数据。</p><p><strong>注意：</strong>JSON格式最初是为 JavaScript开发的，但后来成为了一种通用格式，被众多语言采用。</p><p><strong>json.dumps() 和 json.loads()</strong></p><p>json.dumps()接受一个参数，即要转换为JSON格式的数据。这个函数返回一个字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 存储数据 json.dumps()</span><br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">import</span> json<br><br>number = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><br>path = Path(<span class="hljs-string">&#x27;number.json&#x27;</span>) <span class="hljs-comment"># 文件路径，如果没有就会自动创建这个文件</span><br>contents = json.dumps(number) <span class="hljs-comment"># 数据通过json.dumps()转化文JSON格式，存储在变量contents中</span><br>path.write_text(contents) <span class="hljs-comment"># 把contents中的数据写入number.json这个文件中</span><br><span class="hljs-comment"># number.json文件内容</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><br><span class="hljs-comment"># 读取数据 json.loads()</span><br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">import</span> json<br><br>path = Path(<span class="hljs-string">&#x27;number.json&#x27;</span>) <span class="hljs-comment"># 文件路径，如果没有就会自动创建这个文件</span><br>contents = path.read_text() <span class="hljs-comment"># 把读取的数据存储在变量contents中</span><br>number = json.loads(contents)<span class="hljs-comment"># contents中的数据通过json.loads()转化文JSON格式，并存储在变量number中</span><br><span class="hljs-built_in">print</span>(number)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p><strong>保存和读取用户生成的数据</strong></p><p>保存数据很有必要，因为如果不以某种方式进行存储，用户的信息就会在程序停止运行时丢失。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 保存用户数据</span><br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">import</span> json<br><br>username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你的名字：&quot;</span>)<br>path = Path(<span class="hljs-string">&#x27;username.json&#x27;</span>)<br>contents = json.dumps(username)<br>path.write_text(contents, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我们将储存你的名字。&quot;</span>)<br>请输入你的名字：zqten<br>我们将储存你的名字。<br><span class="hljs-comment"># username.json文件</span><br><span class="hljs-string">&quot;zqten&quot;</span><br><br><span class="hljs-comment"># 读取用户生成的数据</span><br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">import</span> json<br>path = Path(<span class="hljs-string">&quot;username.json&quot;</span>)<br>contents = path.read_text()<br>username = json.loads(contents)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Welcome back <span class="hljs-subst">&#123;username&#125;</span>&quot;</span>)<br>Welcome back zqten<br></code></pre></td></tr></table></figure><p>Path类提供了很多有用的方法。如果指定的文件或文件夹存在，<strong>exists()</strong>方法返回 True ，否则返回 False 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">import</span> json<br><br>path = Path(<span class="hljs-string">&#x27;username.json&#x27;</span>)<br><span class="hljs-keyword">if</span> path.exists():<br>    contents = path.read_text()<br>    username = json.loads(contents)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Welcome back <span class="hljs-subst">&#123;username&#125;</span>&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你的名字：&quot;</span>)<br>    contents = json.dumps(username)<br>    path.write_text(contents, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;我们将储存你的名字。<span class="hljs-subst">&#123;username&#125;</span>&quot;</span>)<br>Welcome back zqten<br></code></pre></td></tr></table></figure><p><strong>重构</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 保存用户数据</span><br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_stored_username</span>(<span class="hljs-params">path</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;如果用户存储了用户名，我们就获取他&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">if</span> path.exists():<br>        contents = path.read_text()<br>        username = json.loads(contents)<br>        <span class="hljs-keyword">return</span> username<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_new_username</span>(<span class="hljs-params">path</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;提示用户输入用户名&#x27;&#x27;&#x27;</span><br>    username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你的名字：&quot;</span>)<br>    contents = json.dumps(username)<br>    path.write_text(contents, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>    <span class="hljs-keyword">return</span> username<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">greet_user</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;问候用户，并指出其名字&#x27;&#x27;&#x27;</span><br>    path = Path(<span class="hljs-string">&#x27;username.json&#x27;</span>)<br>    username = get_stored_username(path)<br>    <span class="hljs-keyword">if</span> username:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Welcome back <span class="hljs-subst">&#123;username&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        username = get_new_username(path)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;我们将储存你的名字，<span class="hljs-subst">&#123;username&#125;</span>&quot;</span>)<br><br>greet_user()<br>请输入你的名字：zqten<br>我们将储存你的名字，zqten<br><span class="hljs-comment"># 在运行一次</span><br>greet_user()<br>Welcome back zqten<br></code></pre></td></tr></table></figure><h3 id="小结-7">小结</h3><p>本章学习了如何使用文件，包括如何读取整个文件，如何读取文件中的各行，以及如何根据需要将任意数量的文本写入文件。然后学习了异常，以及如何处理程序可能引发的异常。最后学习了如何存储Python数据结构，以保存用户提供的信息，避免让用户在每次运行程序时都重新提供。</p><h2 id="第十章-测试代码">第十章 测试代码</h2><p>本章使用的是pip安装的pytest库来进行测试代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在控制台安装</span><br>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pytest<br></code></pre></td></tr></table></figure><h3 id="测试函数">测试函数</h3><p>测试基本分为下面几种：</p><ul><li>单元测试，用于核实函数的某个方面没有问题。</li><li>测试用例，是一组单元测试，核实函数在各种情况下的行为都符合要求。</li><li>全覆盖，测试一整套单元测试，涵盖了各种可能的函数使用方式。</li></ul><p>测试函数，需要新建一个文件，导入需要测试的函数，然后定义一个测试函数（这个函数的命名规范是：必须以test加下划线打头）。在测试过程中，<strong>pytest</strong>会找出并运行所有以test加下划线打头的函数。运行测试，需要在终端进入到要测试的程序的文件夹，输入pytest就会出现下面的测试内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># name_function.py 文件</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_formatted_name</span>(<span class="hljs-params">frist, last, middle=<span class="hljs-string">&#x27;&#x27;</span></span>):<br>    <span class="hljs-keyword">if</span> middle:<br>        full_name = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;frist&#125;</span> <span class="hljs-subst">&#123;middle&#125;</span> <span class="hljs-subst">&#123;last&#125;</span>&quot;</span><br>    <span class="hljs-keyword">else</span>:<br>        full_name = <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;frist&#125;</span> <span class="hljs-subst">&#123;last&#125;</span>&quot;</span><br>    <span class="hljs-keyword">return</span> full_name.title()<br><br><span class="hljs-comment"># test_name_function.py 测试文件</span><br><span class="hljs-keyword">from</span> name_function <span class="hljs-keyword">import</span> get_formatted_name<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_frist_last_name</span>():<br>    formatted_name = get_formatted_name(<span class="hljs-string">&#x27;janis&#x27;</span>, <span class="hljs-string">&#x27;joplin&#x27;</span>)<br>    <span class="hljs-keyword">assert</span> formatted_name == <span class="hljs-string">&#x27;Janis Joplin&#x27;</span><br>    <br><span class="hljs-comment"># 运行测试，需要在终端进入到要测试的程序的文件夹，输入pytest就会出现下面的测试内容。</span><br>======================== test session starts ========================<br>platform win32 -- Python <span class="hljs-number">3.11</span><span class="hljs-number">.3</span>, pytest-<span class="hljs-number">7.4</span><span class="hljs-number">.0</span>, pluggy-<span class="hljs-number">1.3</span><span class="hljs-number">.0</span><br>rootdir: E:Python\第十章测试代码<br>collected <span class="hljs-number">1</span> item<br><br>test_name_function.py .                                     [<span class="hljs-number">100</span>%]<br><br>======================== <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.01</span>s ==========================<br><br><br><span class="hljs-comment"># 未通过测试示例</span><br>===================== test session starts ============================<br>platform win32 -- Python <span class="hljs-number">3.11</span><span class="hljs-number">.3</span>, pytest-<span class="hljs-number">7.4</span><span class="hljs-number">.0</span>, pluggy-<span class="hljs-number">1.3</span><span class="hljs-number">.0</span><br>rootdir: E:Python\第十章测试代码<br>collected <span class="hljs-number">1</span> item<br><br>test_name_function.py F                                         [<span class="hljs-number">100</span>%]<br><br>====================== FAILURES ====================================== <br>__________________ test_frist_last_name_______________________________ <br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_frist_last_name</span>():<br>        formatted_name = get_formatted_name(<span class="hljs-string">&#x27;janis&#x27;</span>, <span class="hljs-string">&#x27;joplin&#x27;</span>)<br>&gt;       <span class="hljs-keyword">assert</span> formatted_name == <span class="hljs-string">&#x27;Janis Joplil&#x27;</span><br>E       AssertionError: <span class="hljs-keyword">assert</span> <span class="hljs-string">&#x27;Janis Joplin&#x27;</span> == <span class="hljs-string">&#x27;Janis Joplil&#x27;</span><br>E         - Janis Joplil<br>E         ?            ^<br>E         + Janis Joplin<br>E         ?            ^<br><br>test_name_function.py:<span class="hljs-number">6</span>: AssertionError<br>============= short test summary info =========================================== <br>FAILED test_name_function.py:<br>:test_frist_last_name - AssertionError: <span class="hljs-keyword">assert</span> <span class="hljs-string">&#x27;Janis Joplin&#x27;</span> == <span class="hljs-string">&#x27;Janis Joplil&#x27;</span><br>============= <span class="hljs-number">1</span> failed <span class="hljs-keyword">in</span> <span class="hljs-number">0.05</span>s ================================================= <br></code></pre></td></tr></table></figure><h3 id="测试类">测试类</h3><p>上面是测试了函数，现在我们针对类进行测试。</p><p><strong>各种断言：</strong></p><ul><li>assert a == b 断言两个值相等</li><li>assert a != b 断言两个值不等</li></ul><p>这里只列出了两个，测试能包含任意可用条件语句表示的断言，比如 not、in等等。</p><p><strong>要测试的类</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试类 survey.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnonymousSurvey</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;收集匿名调查问卷&#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, question</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;存储一个问题，并为存储答案做准备&#x27;&#x27;&#x27;</span><br>        <span class="hljs-variable language_">self</span>.question = question<br>        <span class="hljs-variable language_">self</span>.responses = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show_question</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;显示调查问卷&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-variable language_">self</span>.question)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">store_response</span>(<span class="hljs-params">self, new_response</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;存储单个调查答卷&#x27;&#x27;&#x27;</span><br>        <span class="hljs-variable language_">self</span>.responses.append(new_response)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show_results</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;显示收集到的所有答案&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;所有问卷结果:&quot;</span>)<br>        <span class="hljs-keyword">for</span> response <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.responses:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;- <span class="hljs-subst">&#123;response&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 实例化 language_survey.py</span><br><span class="hljs-comment"># survey类的实例</span><br><span class="hljs-keyword">from</span> survey <span class="hljs-keyword">import</span> AnonymousSurvey<br><br><span class="hljs-comment"># 定义个问题，并创建一个表示调查的 AnonymousSurvey 对象</span><br>question = <span class="hljs-string">&quot;你学习了几种语言？&quot;</span><br>language_survey = AnonymousSurvey(question)<br><br><span class="hljs-comment"># 显示问题并存储答案</span><br>language_survey.show_question()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;按&#x27;q&#x27;退出。\n&quot;</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    response = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;输入你学习的语言: &quot;</span>)<br>    <span class="hljs-keyword">if</span> response == <span class="hljs-string">&quot;q&quot;</span>:<br>        <span class="hljs-keyword">break</span><br>    language_survey.store_response(response)<br><br><span class="hljs-comment"># 显示答案</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n你学习的语言有&quot;</span>)<br>language_survey.show_results()<br><br>你学习了几种语言？<br>按<span class="hljs-string">&#x27;q&#x27;</span>退出。       <br><br>输入你学习的语言: 汉语<br>输入你学习的语言: 英语<br>输入你学习的语言: 日语<br>输入你学习的语言: 德语<br>输入你学习的语言: q<br><br>你学习的语言有<br>所有问卷结果: <br>- 汉语        <br>- 英语        <br>- 日语        <br>- 德语  <br></code></pre></td></tr></table></figure><p><strong>测试AnonymousSurvey类</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试AnonymousSurvey类 test_survey.py</span><br><span class="hljs-keyword">from</span> survey <span class="hljs-keyword">import</span> AnonymousSurvey<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_store_single_response</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;测试单个答案会被妥善地存储&#x27;&#x27;&#x27;</span><br>    question = <span class="hljs-string">&quot;What language did you first learn to speak?&quot;</span><br>    language_survey = AnonymousSurvey(question)<br>    language_survey.store_response(<span class="hljs-string">&#x27;English&#x27;</span>)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&#x27;English&#x27;</span> <span class="hljs-keyword">in</span> language_survey.responses<br>    <br>==================== test session starts ============================== <br>platform win32 -- Python <span class="hljs-number">3.11</span><span class="hljs-number">.3</span>, pytest-<span class="hljs-number">7.4</span><span class="hljs-number">.0</span>, pluggy-<span class="hljs-number">1.3</span><span class="hljs-number">.0</span><br>rootdir: E:Python\第十章测试代码<br>collected <span class="hljs-number">1</span> items                                                                                                                       <br><br>test_survey.py .                               [<span class="hljs-number">100</span>%] <br><br>===================== <span class="hljs-number">1</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.02</span>s ===============================     <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_store_three_response</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;测试多个答案会被妥善地存储&#x27;&#x27;&#x27;</span><br>    question = <span class="hljs-string">&quot;What language did you first learn to speak?&quot;</span><br>    language_survey = AnonymousSurvey(question)<br>    responses = [<span class="hljs-string">&#x27;English&#x27;</span>, <span class="hljs-string">&#x27;Spanish&#x27;</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>]<br>    <span class="hljs-keyword">for</span> response <span class="hljs-keyword">in</span> responses:<br>        language_survey.store_response(response)<br><br>    <span class="hljs-keyword">for</span> response <span class="hljs-keyword">in</span> responses:<br>        <span class="hljs-keyword">assert</span> response <span class="hljs-keyword">in</span> language_survey.responses<br><br>========================= test session starts ===============================<br>platform win32 -- Python <span class="hljs-number">3.11</span><span class="hljs-number">.3</span>, pytest-<span class="hljs-number">7.4</span><span class="hljs-number">.0</span>, pluggy-<span class="hljs-number">1.3</span><span class="hljs-number">.0</span><br>rootdir: E:Python\第十章测试代码<br>collected <span class="hljs-number">2</span> items                                                                                                                       <br><br>test_survey.py ..                   [<span class="hljs-number">100</span>%] <br><br>========================= <span class="hljs-number">2</span> passed <span class="hljs-keyword">in</span> <span class="hljs-number">0.02</span>s =================================<br></code></pre></td></tr></table></figure><p><strong>使用夹具</strong></p><p>夹具（<span class="citation"data-cites="pytest.fixture">@pytest.fixture</span>）可帮助我们搭建测试环境，用于测试多个项目。这个需要导入（importpytest）。夹具使用方法是放在函数定义前面的指令。要使用夹具时，可编写一个函数来生成供多个测试函数使用的资源再对这个函数应用装饰器@pytest.fixture，并让使用该资源的每个测试函数都接受一个与该函数同名的形参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">from</span> survey <span class="hljs-keyword">import</span> AnonymousSurvey<br><span class="hljs-comment"># 测试AnonymousSurvey类</span><br><br><br><span class="hljs-meta">@pytest.fixture</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">language_survey</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;一个可供所有测试函数使用的AnonymousSurvey实例&#x27;&#x27;&#x27;</span><br>    question = <span class="hljs-string">&quot;What language did you first learn to speak?&quot;</span><br>    language_survey = AnonymousSurvey(question)<br>    <span class="hljs-keyword">return</span> language_survey<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_store_single_response</span>(<span class="hljs-params">language_survey</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;测试单个答案会被妥善地存储&#x27;&#x27;&#x27;</span><br>    language_survey.store_response(<span class="hljs-string">&#x27;English&#x27;</span>)<br>    <span class="hljs-keyword">assert</span> <span class="hljs-string">&#x27;English&#x27;</span> <span class="hljs-keyword">in</span> language_survey.responses<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_store_three_response</span>(<span class="hljs-params">language_survey</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;测试多个答案会被妥善地存储&#x27;&#x27;&#x27;</span><br>    responses = [<span class="hljs-string">&#x27;English&#x27;</span>, <span class="hljs-string">&#x27;Spanish&#x27;</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>]<br>    <span class="hljs-keyword">for</span> response <span class="hljs-keyword">in</span> responses:<br>        language_survey.store_response(response)<br><br>    <span class="hljs-keyword">for</span> response <span class="hljs-keyword">in</span> responses:<br>        <span class="hljs-keyword">assert</span> response <span class="hljs-keyword">in</span> language_survey.responses<br></code></pre></td></tr></table></figure><h3 id="小结-8">小结</h3><p>本章学习了如何使用 pytest模块中的工具来为函数和类编写测试。不仅学习了如何编写测试函数，以核实函数和类的行为符合预期，而且学习了如何使用夹具来高效地创建可在测试文件中的多个测试函数中使用的资源。</p><h1 id="第二部分-项目">第二部分 项目</h1><h2 id="第十二章-武装飞船">第十二章 武装飞船</h2><h3 id="外星人入侵项目规划">外星人入侵项目规划</h3><ul><li>玩家控制着一艘武装飞船出现在屏幕底部中央，玩家可以使用方向键左右移动飞船，使用空格键进行射击。</li><li>当游戏开始时，一个外形舰队出现在天空中，并向屏幕下方移动。</li><li>玩家的任务是消灭这些外星人。</li><li>玩家将万星人消灭干净后，将出现一个新的外形舰队，其移动速度更快。</li><li>只要有万星人撞到玩家的飞船或到达屏幕下边缘，玩家就损失一艘飞船。玩家损失三艘飞船游戏结束。</li></ul><p><strong>安装Pygame</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install pygame<br></code></pre></td></tr></table></figure><h3 id="开始游戏项目">开始游戏项目</h3><p><strong>创建 Pygame 窗口及响应用户输入</strong></p><p>这里有及个新方法：</p><ul><li>pygame.display.set_mode((1200,800)) 设置显示画面的大小</li><li>pygame.display.set_caption("Alien Invasion") 设置标题和logo</li><li>pygame.display.flip() 让渲染的可见</li><li>pygame.time.Clock() 设置游戏帧率</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> pygame<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlienInvasion</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;管理游戏资源和行为的类&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化游戏并创建游戏资源&quot;&quot;&quot;</span><br>        pygame.init()<br><br>        <span class="hljs-variable language_">self</span>.screen = pygame.display.set_mode((<span class="hljs-number">1200</span>,<span class="hljs-number">800</span>))<br>        pygame.display.set_caption(<span class="hljs-string">&quot;Alien Invasion&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;开始游戏主循环&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 监听键盘和鼠标事件</span><br>            <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>                <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>                    sys.exit()<br>            <span class="hljs-comment"># 让最近绘制的屏幕可见</span><br>            pygame.display.flip()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 创建游戏实例并运行游戏</span><br>    ai = AlienInvasion()<br>    ai.run_game()<br></code></pre></td></tr></table></figure><p><strong>控制帧率</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlienInvasion</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;管理游戏资源和行为的类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化游戏并创建游戏资源&quot;&quot;&quot;</span><br>        pygame.init()<br>        <span class="hljs-comment"># 创建游戏时钟，保证在其他系统都是相同的速度（帧率）运行</span><br>        <span class="hljs-variable language_">self</span>.clock = pygame.time.Clock()<br>        --snip--<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;开始游戏主循环&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            --snip--<br>            <span class="hljs-comment"># 让最近绘制的屏幕可见</span><br>            pygame.display.flip()    <br>            <span class="hljs-variable language_">self</span>.clock.tick(<span class="hljs-number">60</span>)<br></code></pre></td></tr></table></figure><p><strong>设置背景颜色</strong></p><p>fill() 方法是填充背景颜色，该方法只接受一个表示颜色的实参。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>   --snip--<br>       pygame.display.set_caption(<span class="hljs-string">&quot;Alien Invasion&quot;</span>)<br>       <span class="hljs-comment"># 设置背景颜色</span><br>       <span class="hljs-variable language_">self</span>.bg_color = (<span class="hljs-number">230</span>,<span class="hljs-number">230</span>,<span class="hljs-number">230</span>)<br>   <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>(<span class="hljs-params">self</span>):<br>       <span class="hljs-string">&quot;&quot;&quot;开始游戏主循环&quot;&quot;&quot;</span><br>       --snip--<br>       <span class="hljs-comment"># 每次循环时都重绘制屏幕</span><br>           <span class="hljs-variable language_">self</span>.screen.fill(<span class="hljs-variable language_">self</span>.bg_color)<br>       <span class="hljs-comment"># 让最近绘制的屏幕可见</span><br>           pygame.display.flip()<br></code></pre></td></tr></table></figure><p><strong>创建 Settings 类</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Settings</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;存储游戏《外星人入侵》中所有设置的类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化游戏的设置&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 屏幕设置</span><br>        <span class="hljs-variable language_">self</span>.screen_width = <span class="hljs-number">1200</span><br>        <span class="hljs-variable language_">self</span>.screen_height = <span class="hljs-number">800</span><br>        <span class="hljs-variable language_">self</span>.screen_color = (<span class="hljs-number">230</span>, <span class="hljs-number">230</span>, <span class="hljs-number">230</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlienInvasion</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;管理游戏资源和行为的类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化游戏并创建游戏资源&quot;&quot;&quot;</span>        <br>        --snip--<br>        <span class="hljs-variable language_">self</span>.screen = pygame.display.set_mode((<span class="hljs-variable language_">self</span>.settings.screen_width, <span class="hljs-variable language_">self</span>.settings.screen_height))<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;开始游戏主循环&quot;&quot;&quot;</span><br>        --snip--<br>            <span class="hljs-variable language_">self</span>.screen.fill(<span class="hljs-variable language_">self</span>.settings.screen_color)<br></code></pre></td></tr></table></figure><h3 id="添加飞船图像">添加飞船图像</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;管理飞船类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, ai_game</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化飞船并设置其初始位置&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.screen = ai_game.screen<br>        <span class="hljs-variable language_">self</span>.screen_rect = ai_game.screen.get_rect()<br><br>        <span class="hljs-comment"># 加载飞船图像并获取其外接矩形</span><br>        <span class="hljs-variable language_">self</span>.image = pygame.image.load(<span class="hljs-string">&#x27;images/ship.bmp&#x27;</span>)<br>        <span class="hljs-variable language_">self</span>.rect = <span class="hljs-variable language_">self</span>.image.get_rect()<br><br>        <span class="hljs-comment"># 每艘新飞船都放在屏幕底部的中央</span><br>        <span class="hljs-variable language_">self</span>.rect.midbottom = <span class="hljs-variable language_">self</span>.screen_rect.midbottom<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">blitme</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;在指定位置绘制飞船&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.screen.blit(<span class="hljs-variable language_">self</span>.image, <span class="hljs-variable language_">self</span>.rect)<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>在 pygame中，原点（0,0）位于屏幕左上角，当一个点向右下方移动时，它的坐标值将增大，在1200X800的屏幕上，原点位于左上角，右下角的坐标为（1200,800）。这些坐标对应的是游戏窗口，而不是物理屏幕。</p><p><strong>在屏幕上绘制飞船</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ship <span class="hljs-keyword">import</span> Ship<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlienInvasion</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;管理游戏资源和行为的类&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;初始化游戏并创建游戏资源&quot;&quot;&quot;</span><br>    --snip--<br>    pygame.display.set_caption(<span class="hljs-string">&quot;Alien Invasion&quot;</span>)<br>    <span class="hljs-variable language_">self</span>.ship = Ship(<span class="hljs-variable language_">self</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;开始游戏主循环&quot;&quot;&quot;</span><br>    --snip--<br>            <span class="hljs-variable language_">self</span>.screen.fill(<span class="hljs-variable language_">self</span>.settings.screen_color)<br>            <span class="hljs-variable language_">self</span>.ship.blitme()<br></code></pre></td></tr></table></figure><h3id="重构_check_events-方法和-_update_screen-方法">重构：_check_events()方法和 _update_screen() 方法</h3><p>在Python中辅助方法的名称以单下划线打头</p><p>_ <em>check_events() 方法和</em> _update_screen()方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;开始游戏主循环&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 监听键盘和鼠标事件</span><br>        <span class="hljs-variable language_">self</span>._check_events()<br>        <span class="hljs-variable language_">self</span>._update_screen()<br>        <span class="hljs-comment"># 每秒60帧</span><br>        <span class="hljs-variable language_">self</span>.clock.tick(<span class="hljs-number">60</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_events</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 监听键盘和鼠标事件</span><br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>            sys.exit()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_update_screen</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 每次循环时都重绘制屏幕</span><br>    <span class="hljs-variable language_">self</span>.screen.fill(<span class="hljs-variable language_">self</span>.settings.screen_color)<br>    <span class="hljs-variable language_">self</span>.ship.blitme()<br>    <span class="hljs-comment"># 让最近绘制的屏幕可见</span><br>    pygame.display.flip()<br></code></pre></td></tr></table></figure><h3 id="驾驶飞船">驾驶飞船</h3><p><strong>响应按键</strong></p><p>pygame中，事件都是通过 pygame.event.get() 方法获取的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">--snip--<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_events</span>(<span class="hljs-params">self</span>):<br>            <span class="hljs-comment"># 监听键盘和鼠标事件</span><br>            <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>                <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>                    sys.exit()<br>                <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == pygame.KEYDOWN:<br>                    <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>                        <span class="hljs-comment"># 飞船向右移动</span><br>                        <span class="hljs-variable language_">self</span>.ship.rect.x += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>持续移动</strong></p><p>pygame.KEYDOWN 和 pygame.KEYUP 两个事件是，按下键盘，和释放键盘。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python">    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>(<span class="hljs-params">self</span>):<br>            <span class="hljs-string">&quot;&quot;&quot;开始游戏主循环&quot;&quot;&quot;</span><br>            <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                <span class="hljs-comment"># 监听键盘和鼠标事件</span><br>                <span class="hljs-variable language_">self</span>._check_events()<br>                <span class="hljs-comment"># 调用飞船位置更新函数</span><br>                <span class="hljs-variable language_">self</span>.ship.update()<br>                <span class="hljs-comment"># 更新画面</span><br>                <span class="hljs-variable language_">self</span>._update_screen()<br>                <span class="hljs-comment"># 每秒60帧</span><br>                <span class="hljs-variable language_">self</span>.clock.tick(<span class="hljs-number">60</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_events</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 监听键盘和鼠标事件</span><br>        <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>            <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>                sys.exit()<br>            <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == pygame.KEYDOWN:<br>                <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>                    <span class="hljs-comment"># 飞船向右移动</span><br>                    <span class="hljs-variable language_">self</span>.ship.moving_right = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == pygame.KEYUP:<br>                <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>                    <span class="hljs-variable language_">self</span>.ship.moving_right = <span class="hljs-literal">False</span><br>                    <br><span class="hljs-comment"># ship.py</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;管理飞船类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, ai_game</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化飞船并设置其初始位置&quot;&quot;&quot;</span><br>        --snip--<br>        <span class="hljs-comment"># 移动标志（飞船一开始不移动）</span><br>        <span class="hljs-variable language_">self</span>.moving_right = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;根据移动标志调整飞船的位置&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.moving_right:<br>            <span class="hljs-variable language_">self</span>.rect.x += <span class="hljs-number">1</span><br>        --snip--<br></code></pre></td></tr></table></figure><p><strong>左右移动</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;管理飞船类&quot;&quot;&quot;</span><br>--snip--<br>        <span class="hljs-comment"># 移动标志（飞船一开始不移动）</span><br>        <span class="hljs-variable language_">self</span>.moving_right = <span class="hljs-literal">False</span><br>        <span class="hljs-variable language_">self</span>.moving_left = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;根据移动标志调整飞船的位置&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.moving_right:<br>            <span class="hljs-variable language_">self</span>.rect.x += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.moving_left:<br>            <span class="hljs-variable language_">self</span>.rect.x -= <span class="hljs-number">1</span><br>        --snip--<br>        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlienInvasion</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;管理游戏资源和行为的类&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_events</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 监听键盘和鼠标事件</span><br>        <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>            <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>                sys.exit()<br>                <span class="hljs-comment"># 飞船移动</span><br>            <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == pygame.KEYDOWN:<br>                <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>                    <span class="hljs-variable language_">self</span>.ship.moving_right = <span class="hljs-literal">True</span><br>                <span class="hljs-keyword">if</span> event.key == pygame.K_LEFT:<br>                    <span class="hljs-variable language_">self</span>.ship.moving_left = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == pygame.KEYUP:<br>                <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>                    <span class="hljs-variable language_">self</span>.ship.moving_right = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">if</span> event.key == pygame.K_LEFT:<br>                    <span class="hljs-variable language_">self</span>.ship.moving_left = <span class="hljs-literal">False</span>    <br></code></pre></td></tr></table></figure><p><strong>调整飞船的速度</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Settings</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;存储游戏《外星人入侵》中所有设置的类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化游戏的设置&quot;&quot;&quot;</span><br>        --snip--<br>        <span class="hljs-comment"># 飞船的设置</span><br>        <span class="hljs-variable language_">self</span>.ship_speed = <span class="hljs-number">1.5</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;管理飞船类&quot;&quot;&quot;</span> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, ai_game</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化飞船并设置其初始位置&quot;&quot;&quot;</span>    <br>        --snip--<br>        <span class="hljs-comment"># 在飞创的属性X中存储一个浮点数</span><br>        <span class="hljs-variable language_">self</span>.x = <span class="hljs-built_in">float</span>(<span class="hljs-variable language_">self</span>.rect.x)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;根据移动标志调整飞船的位置&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 更新飞船的属性 x 的值，而不是其外接矩形的属性 x 的值</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.moving_right:<br>            <span class="hljs-variable language_">self</span>.x += <span class="hljs-variable language_">self</span>.settings.ship_speed<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.moving_left:<br>            <span class="hljs-variable language_">self</span>.x -= <span class="hljs-variable language_">self</span>.settings.ship_speed<br><br>        <span class="hljs-comment"># 根据self.x更新self.rect.x</span><br>        <span class="hljs-variable language_">self</span>.rect.x = <span class="hljs-variable language_">self</span>.x        <br></code></pre></td></tr></table></figure><p><strong>限制飞船的活动范围</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;管理飞船类&quot;&quot;&quot;</span> <br>        --snip--    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;根据移动标志调整飞船的位置&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 更新飞船的属性 x 的值，而不是其外接矩形的属性 x 的值</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.moving_right <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.rect.right &lt; <span class="hljs-variable language_">self</span>.screen_rect.right:<br>            <span class="hljs-variable language_">self</span>.x += <span class="hljs-variable language_">self</span>.settings.ship_speed<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.moving_left <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.rect.left &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.x -= <span class="hljs-variable language_">self</span>.settings.ship_speed        <br></code></pre></td></tr></table></figure><p>**重构：_check_events() 方法**</p><p>检查事件方法越来越长，我们将其部分代码放在两个方法中，一个处理键盘按下(KEYDOWN)，一个处理键盘释放(KEYUP)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_events</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-comment"># 监听键盘和鼠标事件</span><br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>        <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>            sys.exit()<br>            <span class="hljs-comment"># 飞船移动</span><br>        <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == pygame.KEYDOWN:<br>            <span class="hljs-variable language_">self</span>._check_keydown_events(event)<br>        <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == pygame.KEYUP:<br>            <span class="hljs-variable language_">self</span>._check_keyup_events(event)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_keydown_events</span>(<span class="hljs-params">self, event</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;响应按下键盘&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>        <span class="hljs-variable language_">self</span>.ship.moving_right = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">elif</span> event.key == pygame.K_LEFT:<br>        <span class="hljs-variable language_">self</span>.ship.moving_left = <span class="hljs-literal">True</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_keyup_events</span>(<span class="hljs-params">self, event</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;响应释放键盘&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>        <span class="hljs-variable language_">self</span>.ship.moving_right = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">if</span> event.key == pygame.K_LEFT:<br>        <span class="hljs-variable language_">self</span>.ship.moving_left = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p><strong>按 Q 退出</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_keydown_events</span>(<span class="hljs-params">self, event</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;响应按下键盘&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>        <span class="hljs-variable language_">self</span>.ship.moving_right = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">elif</span> event.key == pygame.K_LEFT:<br>        <span class="hljs-variable language_">self</span>.ship.moving_left = <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">elif</span> event.key == pygame.K_q:<br>        sys.exit()<br></code></pre></td></tr></table></figure><p><strong>在全屏模式下运行游戏</strong></p><p>在创建屏幕时，传入(0, 0), pygame.FULLSCREEN，这让pygame生成一个覆盖整个显示器的屏幕。由于无法知道屏幕的宽度和高度，所有后面接着要更新屏幕的rect 的属性宽和高来更新对象 settings。pygame不提供全屏模式下退出游戏的默认方式，所以运行前，确保可以使用 'q'退出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlienInvasion</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;管理游戏资源和行为的类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化游戏并创建游戏资源&quot;&quot;&quot;</span><br>        --snip--<br>        <span class="hljs-variable language_">self</span>.screen = pygame.display.set_mode((<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), pygame.FULLSCREEN)<br>        <span class="hljs-variable language_">self</span>.settings.screen_width = <span class="hljs-variable language_">self</span>.screen.get_rect().width<br>        <span class="hljs-variable language_">self</span>.settings.screen_height = <span class="hljs-variable language_">self</span>.screen.get_rect().height        <br></code></pre></td></tr></table></figure><h3 id="简单回顾">简单回顾</h3><p>下面将添加射击功能，所以需要新增一个名为 bullet.py的文件，并修改一些原有的文件，在添加其他功能前，先回顾一下这些文件，以便对这个项目的组织结构有清楚的认识。</p><ul><li><p>alien_invasion.py 这个文件包含 AlienInvasion类，这个类创建在游戏的很多地方会用到的一系列属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> pygame<br><br><span class="hljs-keyword">from</span> settings <span class="hljs-keyword">import</span> Settings<br><span class="hljs-keyword">from</span> ship <span class="hljs-keyword">import</span> Ship<br><span class="hljs-keyword">from</span> bullet <span class="hljs-keyword">import</span> Bullet<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlienInvasion</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;管理游戏资源和行为的类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化游戏并创建游戏资源&quot;&quot;&quot;</span><br>        pygame.init()<br>        <span class="hljs-comment"># 创建游戏时钟，保证在其他系统都是相同的速度（帧率）运行</span><br>        <span class="hljs-variable language_">self</span>.clock = pygame.time.Clock()<br>        <span class="hljs-comment"># 设置背景颜色和窗口大小</span><br>        <span class="hljs-variable language_">self</span>.settings = Settings()<br>        <span class="hljs-comment"># 独立窗口运行程序</span><br>        <span class="hljs-variable language_">self</span>.screen = pygame.display.set_mode((<span class="hljs-variable language_">self</span>.settings.screen_width, <span class="hljs-variable language_">self</span>.settings.screen_height))<br>        <span class="hljs-comment"># 全屏模式游戏 &#x27;q&#x27; 退出</span><br>        <span class="hljs-comment"># self.screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)</span><br>        <span class="hljs-comment"># self.settings.screen_width = self.screen.get_rect().width</span><br>        <span class="hljs-comment"># self.settings.screen_height = self.screen.get_rect().height</span><br>        pygame.display.set_caption(<span class="hljs-string">&quot;Alien Invasion&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.ship = Ship(<span class="hljs-variable language_">self</span>)<br>        <span class="hljs-variable language_">self</span>.bullets = pygame.sprite.Group()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run_game</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;开始游戏主循环&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-comment"># 监听键盘和鼠标事件</span><br>            <span class="hljs-variable language_">self</span>._check_events()<br>            <span class="hljs-comment"># 调用飞船位置更新函数</span><br>            <span class="hljs-variable language_">self</span>.ship.update()<br>            <span class="hljs-comment"># 更新子弹的位置并删除已消失的子弹</span><br>            <span class="hljs-variable language_">self</span>._update_bullets()<br>            <span class="hljs-comment"># 更新画面</span><br>            <span class="hljs-variable language_">self</span>._update_screen()<br>            <span class="hljs-comment"># 每秒60帧</span><br>            <span class="hljs-variable language_">self</span>.clock.tick(<span class="hljs-number">60</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_events</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 监听键盘和鼠标事件</span><br>        <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.get():<br>            <span class="hljs-keyword">if</span> event.<span class="hljs-built_in">type</span> == pygame.QUIT:<br>                sys.exit()<br>                <span class="hljs-comment"># 飞船移动</span><br>            <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == pygame.KEYDOWN:<br>                <span class="hljs-variable language_">self</span>._check_keydown_events(event)<br>            <span class="hljs-keyword">elif</span> event.<span class="hljs-built_in">type</span> == pygame.KEYUP:<br>                <span class="hljs-variable language_">self</span>._check_keyup_events(event)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_keydown_events</span>(<span class="hljs-params">self, event</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;响应按下键盘&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>            <span class="hljs-variable language_">self</span>.ship.moving_right = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">elif</span> event.key == pygame.K_LEFT:<br>            <span class="hljs-variable language_">self</span>.ship.moving_left = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">elif</span> event.key == pygame.K_q:<br>            sys.exit()<br>        <span class="hljs-keyword">elif</span> event.key == pygame.K_SPACE:<br>            <span class="hljs-variable language_">self</span>._fire_bullet()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_check_keyup_events</span>(<span class="hljs-params">self, event</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;响应释放键盘&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> event.key == pygame.K_RIGHT:<br>            <span class="hljs-variable language_">self</span>.ship.moving_right = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">if</span> event.key == pygame.K_LEFT:<br>            <span class="hljs-variable language_">self</span>.ship.moving_left = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_fire_bullet</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;创建一颗子弹，并将其加入编著bullets &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.bullets) &lt; <span class="hljs-variable language_">self</span>.settings.bullet_allowed:<br>            new_bullet = Bullet(<span class="hljs-variable language_">self</span>)<br>            <span class="hljs-variable language_">self</span>.bullets.add(new_bullet)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_update_bullets</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;更新子弹的位置并删除已消失的子弹&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 更新子弹位置</span><br>        <span class="hljs-variable language_">self</span>.bullets.update()<br>        <span class="hljs-comment"># 删除已消失的子弹</span><br>        <span class="hljs-keyword">for</span> bullet <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.bullets.copy():<br>            <span class="hljs-keyword">if</span> bullet.rect.bottom &lt;= <span class="hljs-number">0</span>:<br>                <span class="hljs-variable language_">self</span>.bullets.remove(bullet)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_update_screen</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 每次循环时都重绘制屏幕</span><br>        <span class="hljs-variable language_">self</span>.screen.fill(<span class="hljs-variable language_">self</span>.settings.screen_color)<br>        <span class="hljs-comment"># 子弹绘制        </span><br>        <span class="hljs-keyword">for</span> bullet <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.bullets.sprites():<br>            bullet.draw_bullet()<br>        <span class="hljs-variable language_">self</span>.ship.blitme()<br>        <span class="hljs-comment"># 让最近绘制的屏幕可见</span><br>        pygame.display.flip()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 创建游戏实例并运行游戏</span><br>    ai = AlienInvasion()<br>    ai.run_game()<br></code></pre></td></tr></table></figure></li><li><p>settings.py 这个文件包含 Settings类，这个类只有一个方法，这个文件主要用于初始化控制游戏外观和飞船速度的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Settings</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;存储游戏《外星人入侵》中所有设置的类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化游戏的设置&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 屏幕设置</span><br>        <span class="hljs-variable language_">self</span>.screen_width = <span class="hljs-number">1200</span><br>        <span class="hljs-variable language_">self</span>.screen_height = <span class="hljs-number">800</span><br>        <span class="hljs-variable language_">self</span>.screen_color = (<span class="hljs-number">230</span>, <span class="hljs-number">230</span>, <span class="hljs-number">230</span>)<br><br>        <span class="hljs-comment"># 飞船的设置</span><br>        <span class="hljs-variable language_">self</span>.ship_speed = <span class="hljs-number">1.5</span><br><br>        <span class="hljs-comment"># 子弹设置</span><br>        <span class="hljs-variable language_">self</span>.bullet_speed = <span class="hljs-number">2.0</span><br>        <span class="hljs-variable language_">self</span>.bullet_width = <span class="hljs-number">3</span><br>        <span class="hljs-variable language_">self</span>.bullet_height = <span class="hljs-number">15</span><br>        <span class="hljs-variable language_">self</span>.bullet_color = (<span class="hljs-number">60</span>, <span class="hljs-number">60</span>, <span class="hljs-number">60</span>)<br>        <span class="hljs-comment"># 屏幕上最多出现的子弹数量</span><br>        <span class="hljs-variable language_">self</span>.bullet_allowed = <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></li><li><p>ship.py 这个文件包含 Ship 类，这个类主要用于在屏幕上绘制飞船</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;管理飞船类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, ai_game</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;初始化飞船并设置其初始位置&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.screen = ai_game.screen<br>        <span class="hljs-variable language_">self</span>.settings = ai_game.settings<br>        <span class="hljs-variable language_">self</span>.screen_rect = ai_game.screen.get_rect()<br><br>        <span class="hljs-comment"># 加载飞船图像并获取其外接矩形</span><br>        <span class="hljs-variable language_">self</span>.image = pygame.image.load(<span class="hljs-string">&#x27;images/ship.bmp&#x27;</span>)<br>        <span class="hljs-variable language_">self</span>.rect = <span class="hljs-variable language_">self</span>.image.get_rect()<br><br>        <span class="hljs-comment"># 每艘新飞船都放在屏幕底部的中央</span><br>        <span class="hljs-variable language_">self</span>.rect.midbottom = <span class="hljs-variable language_">self</span>.screen_rect.midbottom<br><br>        <span class="hljs-comment"># 在飞船的属性X中存储一个浮点数</span><br>        <span class="hljs-variable language_">self</span>.x = <span class="hljs-built_in">float</span>(<span class="hljs-variable language_">self</span>.rect.x)<br><br>        <span class="hljs-comment"># 移动标志（飞船一开始不移动）</span><br>        <span class="hljs-variable language_">self</span>.moving_right = <span class="hljs-literal">False</span><br>        <span class="hljs-variable language_">self</span>.moving_left = <span class="hljs-literal">False</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;根据移动标志调整飞船的位置&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 更新飞船的属性 x 的值，而不是其外接矩形的属性 x 的值</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.moving_right <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.rect.right &lt; <span class="hljs-variable language_">self</span>.screen_rect.right:<br>            <span class="hljs-variable language_">self</span>.x += <span class="hljs-variable language_">self</span>.settings.ship_speed<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.moving_left <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.rect.left &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.x -= <span class="hljs-variable language_">self</span>.settings.ship_speed<br><br>        <span class="hljs-comment"># 根据self.x更新self.rect.x</span><br>        <span class="hljs-variable language_">self</span>.rect.x = <span class="hljs-variable language_">self</span>.x<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">blitme</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;在指定位置绘制飞船&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.screen.blit(<span class="hljs-variable language_">self</span>.image, <span class="hljs-variable language_">self</span>.rect)<br></code></pre></td></tr></table></figure></li></ul><h3 id="射击">射击</h3><ul><li>bullett.py <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame<br><span class="hljs-keyword">from</span> pygame.sprite <span class="hljs-keyword">import</span> Sprite<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bullet</span>(<span class="hljs-title class_ inherited__">Sprite</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;管理飞船所发射子弹的类&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, ai_game</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;在飞船的当前位置创建一个子弹对象&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.screen = ai_game.screen<br>        <span class="hljs-variable language_">self</span>.settings = ai_game.settings<br>        <span class="hljs-variable language_">self</span>.color = <span class="hljs-variable language_">self</span>.settings.bullet_color<br><br>        <span class="hljs-comment"># 在（0,0）处创建一个表示子弹的矩形，再设置正确的位置</span><br>        <span class="hljs-variable language_">self</span>.rect = pygame.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-variable language_">self</span>.settings.bullet_width, <span class="hljs-variable language_">self</span>.settings.bullet_height)<br>        <span class="hljs-variable language_">self</span>.rect.midtop = ai_game.ship.rect.midtop<br><br>        <span class="hljs-comment"># 存储用浮点数表示的子弹位置</span><br>        <span class="hljs-variable language_">self</span>.y = <span class="hljs-built_in">float</span>(<span class="hljs-variable language_">self</span>.rect.y)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;向上移动子弹&quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 更新子弹的准确位置</span><br>        <span class="hljs-variable language_">self</span>.y -= <span class="hljs-variable language_">self</span>.settings.bullet_speed<br>        <span class="hljs-comment"># 更新表示子弹的 rect 的位置</span><br>        <span class="hljs-variable language_">self</span>.rect.y = <span class="hljs-variable language_">self</span>.y<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_bullet</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;在屏幕上绘制子弹&quot;&quot;&quot;</span><br>        pygame.draw.rect(<span class="hljs-variable language_">self</span>.screen, <span class="hljs-variable language_">self</span>.color, <span class="hljs-variable language_">self</span>.rect)<br></code></pre></td></tr></table></figure></li></ul><h3 id="小结-9">小结</h3><p>本章学习了游戏开发计划的指定以及使用Pygame编写的游戏的基本结构。接着学习了如何设置背景色，以及如何将设置存储在独立的类中。然后学习了如何在屏幕上绘制图像，以及如何让玩家控制游戏元素的移动。不仅创建了能自动移动的元素，还删除了不再需要的对象。最后学习了经常性重构是如何为项目的后续开发提供便利的。</p><h2 id="第十三章-外星人">第十三章 外星人</h2><h3 id="项目回顾">项目回顾</h3><p>本章将完成下列开发：</p><ul class="task-list"><li><label><inputtype="checkbox" />在屏幕左上角添加一个外星人，并指定合适的边距。</label></li><li><label><inputtype="checkbox" />沿屏幕上边缘添加一行万星人，再不断地添加成行的外星人，直到填满屏幕的上半部分。</label></li><li><label><inputtype="checkbox" />让外星人向两侧和向下移动，直到外星舰队被全部击落、有外星人撞到飞船或有外星人抵达屏幕的下边缘。如果外星舰队都被击落，将再创建一个外星舰队；如果有外星人撞到飞船或抵达屏幕下边缘，就销毁飞船并再创建一个外星舰队。<strong>注意</strong>：pygame里面的精灵碰撞和对象碰撞是两个方法</label><ul><li>pygame.sprite.groupcollide(精灵1，精灵2，1是否参与碰撞，2是否参与碰撞)。<strong>这个是直接赋值给变量就可以了。和input 差不多</strong></li><li>pygame.sprite.spritecollideany(对象，精灵)。<strong>这个是返回一个bool值</strong></li></ul></li><li><label><inputtype="checkbox" />限制玩家可用的飞船数量，分配的飞船被用完后，游戏将结束。</label></li></ul><h3 id="创建第一个外星人">创建第一个外星人</h3><h3 id="小结-10">小结</h3><p>本章通过创建外星舰队学习了如何在游戏中添加大量相同的元素，如何使用嵌套循环来创建成行成列的整齐元素，以及如何通过调用每个元素的<code>update()</code>方法移动大量的元素。接着学习了如何控制对象在屏幕上的移动方向，以及如何响应特定的情形，如有外星人到达屏幕边缘。然后学习了如何检测并相应子弹和外星人的碰撞以及外星人和飞创的碰撞。最后学习了如何在游戏中跟踪统计信息，以及如何使用标志<code>game_active</code>来判断游戏是否结束。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电脑小技巧（持续更新）</title>
    <link href="/2024/10/25/2024-10-25-%E7%94%B5%E8%84%91%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <url>/2024/10/25/2024-10-25-%E7%94%B5%E8%84%91%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="win系统睡眠问题">WIN系统睡眠问题</h2><p><a href="https://zqten.github.io/">回到主頁</a></p><p>运行WIN+R，powershell 回车</p><p>进入命令行输入： powercfg /devicequery wake_armed查看哪些设备可以唤醒计算机。</p><p>输入：powercfg /lastwake 可以查看最近一次唤醒计算机的硬件是什么。</p><p><ahref="https://learn.microsoft.com/zh-cn/windows-hardware/design/device-experiences/powercfg-command-line-options">Powercfg命令行选项 | Microsoft Learn</a></p><table><caption>zap:<strong>还有可能是服务问题，禁用除Microsoft以外的所有服务</strong></caption><thead><tr><th>/?, -help</th><th>显示有关命令行参数的信息。</th></tr></thead><tbody><tr><td>/list, /L</td><td>列出所有电源方案。</td></tr><tr><td>/query, /Q</td><td>显示电源方案的内容。</td></tr><tr><td>/change, /X</td><td>修改当前电源方案中的设置值。</td></tr><tr><td>/changename</td><td>修改电源方案的名称和描述。</td></tr><tr><td>/duplicatescheme</td><td>复制电源方案。</td></tr><tr><td>/delete, /D</td><td>删除电源方案。</td></tr><tr><td>/deletesetting</td><td>删除电源设置。</td></tr><tr><td>/setactive, /S</td><td>使电源方案在系统上处于活动状态。</td></tr><tr><td>/getactivescheme</td><td>检索当前活动电源方案。</td></tr><tr><td>/setacvalueindex</td><td>设置系统由交流电源供电时与电源设置关联的值。</td></tr><tr><td>/setdcvalueindex</td><td>设置系统由 DC 电源供电时与电源设置关联的值。</td></tr><tr><td>/import</td><td>从文件导入所有电源设置。</td></tr><tr><td>/export</td><td>将电源方案导出到文件。</td></tr><tr><td>/aliases</td><td>显示所有别名及其对应的 GUID。</td></tr><tr><td>/getsecuritydescriptor</td><td>获取与指定电源设置、电源方案或操作关联的安全描述符。</td></tr><tr><td>/setsecuritydescriptor</td><td>设置与电源设置、电源方案或操作关联的安全描述符。</td></tr><tr><td>/hibernate, /H</td><td>启用和禁用休眠功能。</td></tr><tr><td>/availablesleepstates, /A</td><td>报告系统上可用的睡眠状态。</td></tr><tr><td>/devicequery</td><td>返回满足指定条件的设备列表。</td></tr><tr><td>/deviceenableawake</td><td>使设备能够将系统从睡眠状态唤醒。</td></tr><tr><td>/devicedisablewake</td><td>禁止设备将系统从睡眠状态唤醒。</td></tr><tr><td>/lastwake</td><td>报告有关系统从上次睡眠转换中唤醒的信息。</td></tr><tr><td>/waketimers</td><td>枚举活动唤醒计时器。</td></tr><tr><td>/requests</td><td>枚举应用程序和驱动程序电源请求。</td></tr><tr><td>/requestsoverride</td><td>设置特定进程、服务或驱动程序的 Power Request 替代。</td></tr><tr><td>/energy</td><td>分析系统常见的能效和电池寿命问题。</td></tr><tr><td>/batteryreport</td><td>生成电池使用情况报告。</td></tr><tr><td>/sleepstudy</td><td>生成诊断系统电源转换报告。</td></tr><tr><td>/srumutil</td><td>从系统资源使用情况监视器 （SRUM） 转储能量估算数据。</td></tr><tr><td>/systemsleepdiagnostics</td><td>生成系统睡眠转换的诊断报告。</td></tr><tr><td>/systempowerreport</td><td>生成诊断系统电源转换报告。</td></tr></tbody></table><h2 id="激活windows1011">激活windows10/11</h2><p>管理员运行PowerShell</p><p>站点：massgrave.dev 激活命令：irm https://massgrave.dev/get | iex</p><h2 id="极品垃圾电脑配置表">极品垃圾电脑配置表</h2><p>处理器 E5 2690V3 淘宝 53元 显卡 华擎580 8G 矿卡 夕夕 221元 散热器冰蝶4热管 夕夕35元 主板 精粤X99MH-D4 淘宝221元 硬盘 杂牌256G M2 夕夕60元电源 EVGA 450W铜牌 闲鱼65元 机箱 主板盒</p><h2 id="python安装下载地址">Python安装（下载地址）</h2><p><a href="https://www.python.org/downloads/windows/">Python Releasesfor Windows | Python.org</a></p><h2 id="python-pip">Python-pip</h2><p>安装pip命令</p><p>https://bootstrap.pypa.io/get-pip.py先将这个文件保存到电脑，再用cmd命令到该文件的目录下，执行下面的命令。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">python get-pip.py<br></code></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 或者是这个<br>python -m ensurepip --upgrade<br></code></pre></td></tr></table></figure><p>更新pip</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">python -m pip install --upgrade pip<br></code></pre></td></tr></table></figure><p>pip安装python库</p><p>临时使用</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple &#x27;库名称&#x27;<br></code></pre></td></tr></table></figure><p>设为默认python安装库的网址</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">pip config <span class="hljs-built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple<br></code></pre></td></tr></table></figure><h2 id="pycharm下载地址">PyCharm下载地址</h2><p>分为专业版和社区版，专业版需要付费。</p><p><ahref="https://www.jetbrains.com.cn/en-us/pycharm/download/?section=windows">DownloadPyCharm: Python IDE</a></p><p><ahref="https://pan.baidu.com/s/1swyNqTFg-kuAFn0l7P3_KA">激活工具</a>提取码：cCn4</p><h2id="vscode里面python要读取相同目录的文件">vscode里面python要读取相同目录的文件</h2><p>需要再launch.json里面添加一行代码：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">&quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,<br></code></pre></td></tr></table></figure><h2 id="项目结构">项目结构</h2><p><strong>Web App</strong></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs 1c">awesome<span class="hljs-punctuation">-</span>python3<span class="hljs-punctuation">-</span>webapp/  &lt;<span class="hljs-punctuation">-</span><span class="hljs-punctuation">-</span> 根目录<br><span class="hljs-string">|</span><br><span class="hljs-punctuation">+</span><span class="hljs-punctuation">-</span> backup/               &lt;<span class="hljs-punctuation">-</span><span class="hljs-punctuation">-</span> 备份目录<br><span class="hljs-string">|</span><br><span class="hljs-punctuation">+</span><span class="hljs-punctuation">-</span> conf/                 &lt;<span class="hljs-punctuation">-</span><span class="hljs-punctuation">-</span> 配置文件<br><span class="hljs-string">|</span><br><span class="hljs-punctuation">+</span><span class="hljs-punctuation">-</span> dist/                 &lt;<span class="hljs-punctuation">-</span><span class="hljs-punctuation">-</span> 打包目录<br><span class="hljs-string">|</span><br><span class="hljs-punctuation">+</span><span class="hljs-punctuation">-</span> www/                  &lt;<span class="hljs-punctuation">-</span><span class="hljs-punctuation">-</span> Web目录，存放.py文件<br><span class="hljs-string">|  |</span><br><span class="hljs-string">|  +- static/            &lt;-- 存放静态文件</span><br><span class="hljs-string">|  |</span><br><span class="hljs-string">|  +- templates/         &lt;-- 存放模板文件</span><br><span class="hljs-string">|</span><br><span class="hljs-punctuation">+</span><span class="hljs-punctuation">-</span> mobile/               &lt;<span class="hljs-punctuation">-</span><span class="hljs-punctuation">-</span> 存放移动平台 App工程<br><span class="hljs-string">|</span><br><span class="hljs-punctuation">+</span><span class="hljs-punctuation">-</span> LICENSE               &lt;<span class="hljs-punctuation">-</span><span class="hljs-punctuation">-</span> 代码LICENSE<br></code></pre></td></tr></table></figure><h2 id="html特殊字符对照表">HTML特殊字符对照表</h2><p><ahref="https://www.cnblogs.com/samlin/archive/2009/07/28/html-entity-chart.html">网址:zap:</a></p><h2 id="github高级搜索">GitHub高级搜索</h2><p><a href="https://github.com/search/advanced">GitHub高级搜索</a></p><h2 id="chatgpt提示词模板">ChatGPT提示词模板</h2><p>我想让你成为我的 Prompt 创作者。你的目标是帮助我创建最佳的 Prompt，这个 Prompt 将由你 ChatGPT 使用。你将遵循以下过程：</p><ol type="1"><li><p>首先，你会问我 Prompt是关于什么的。我会告诉你，但我们需要通过不断的重复来改进它，通过则进行下一步。</p></li><li><p>根据我的输入，你会创建三个部分：</p><p>a）修订后的 Prompt （你编写修订后的 Prompt，应该清晰、精确、易于理解）</p><p>b）建议（你提出建议，哪些细节应该包含在 Prompt 中，以使其更好）</p><p>c）问题（你提出相关问题，询问我需要哪些额外信息来改进 Prompt）</p></li><li><p>你提供的 Prompt 应该采用我发出请求的形式，有 ChatGPT执行。</p></li><li><p>我们将继续这个迭代过程，我会提供更多的信息，你会更新 "修订后的Prompt" 不分的请求，直到它完整为止。</p></li></ol><h2 id="windows关闭端口">windows关闭端口</h2><p>查询端口：netstat -ano | findstr 8080</p><p>关闭端口：taskkill -PID 9172 -F 9172是进程ID</p><h2 id="powershell新手命令">PowerShell新手命令</h2><p>一、在当前目录下</p><p>新建文件</p><p>New-item空格1（文件名）.doc（文件类型后缀doc）</p><p>New-item 1.doc</p><p>删除文件</p><p>remove-item空格1（文件名）.doc（文件类型后缀doc）</p><p>remove-item 1.doc</p><p>对文件添加内容</p><p>Set-content 空格1.txt（文件名+后缀）空格-value空格”123（内容）”</p><p>Set-content 1.txt -value “123”</p><p>在文件中加内容</p><p>add-content空格1.txt(文件名+后缀)空格-value空格"123”（要添加的内容）</p><p>add-content 1.doc -value “123”</p><p>删除文件内容</p><p>Clear-content空格1.txt（文件名）</p><p>Clear-content 1.txt</p><p>打开创建的文件</p><p>.\1.txt</p><p>.+后缀</p><p>二、在其他目录</p><p>新建文件</p><p>new-item空格C:(创建目录)\2.ps1(文件名+后缀)</p><p>new-item C:\2.ps1</p><p>删除文件</p><p>Remove-item空格 C:（路径）\1.txt（+后缀）</p><p>remove-item C:\1.txt</p><p>添加内容</p><p>Set-content空格C:\1.txt（路径+后缀）空格-value空格”1111”(“添加的内容”)</p><p>set-content C:\1.txt -value "1111"</p><p>增加内容</p><p>add-content空格 C:\1.txt（路径+后缀）空格 -value"111"(“添加的内容”)</p><p>add-content C:\1.txt -value "111"</p><p>删除文件内容</p><p>clear-content空格 C:\1.txt（路径+后缀）</p><p>clear-content C:\1.txt</p><p>打开文件</p><p>C:\1.txt（路径+后缀）</p><p>C:\1.txt</p><h2 id="google搜索语法">Google搜索语法</h2><p>所有这些语法都可以组合使用，比如2和5里面<strong><code>intitle:"标题关键词" intext:"内容关键词"</code>。</strong></p><ol type="1"><li>用<code>"关键词"</code>限定关键词搜索，<code>" "</code>内的关键词是必须出现的。</li><li>用<code>intitle:标题关键词</code>前缀搜索，会以关键词为标题进行搜索。</li><li>用<code>allintitle:关键词A 关键词B</code>，限定标题多个关键词。</li><li>用<code>intext:内容关键词</code>，限定内容关键词。</li><li>用<code>inurl:网址关键词</code>，限定搜索网址的关键词。例：<code>李子柒 inurl:cctv</code></li><li>用<code>site:网址</code>，限定网址来源。例：<code>李子柒 site:zhihu.com</code></li><li>用<code>-搜索排除项</code>,可以排除包含有排除项搜索结果。</li><li>用<code>*</code>，表示通配符。例：<code>搜索*擎</code>，就会出现搜索引擎、搜索巨擎等。</li><li>用<code>imagesize:想要的图片尺寸（2560x1440）</code>，限定图片尺寸。</li><li>用<code>文件名 filetype:文件后缀</code>，限定文件格式。</li></ol><h2 id="rarpdf等文件破解流程">RAR,PDF等文件破解流程</h2><p>首先下载两个软件：</p><ul><li><a href="https://hashcat.net/hashcat/">hashcat</a></li><li><a href="https://www.openwall.com/john/">John the Ripper</a></li></ul><ol type="1"><li>进入John theRipper文件夹下的run文件夹，把需要破解的压缩包文件拖进去并重命名。以RAR为例：<code>test.rar</code></li><li>在该文件夹下的地址栏输入<code>cmd</code>进入命令行。windows10系统，其他系统可以通过命令行进入该文件夹。</li><li>输入命令：<code>rar2john.exe test.rar</code>，会得到一个以<code>$</code>开头的加密值，把它复制到<code>txt</code>文件。</li><li>进入到<code>hashcat</code>文件夹，在地址栏输入<code>cmd</code>进入命令行。</li><li>输入破解命令：hashcat.exe -m 13000 -a 3 上面$开头的哈希值 -opassword.txt这里的13000可以是哈希值为rar5的开头的值，如果是其他哈希值，可以通过<ahref="https://hashcat.net/wiki/doku.php?id=example_hashes">点击这里</a>查询-a是要使用的破解模式<code>-a 0</code>字典攻击，<code>-a 1</code>组合攻击，<code>-a 3</code>掩码攻击-o 是破解后输出明文密码的文件</li></ol><h2 id="markdown小技巧">MarkDown小技巧</h2><p>链接本地文件：</p><ul><li>绝对地址方法：<code>C:/文件夹/文件名.后缀</code></li><li>相对地址方法：<code>../文件夹/文件名.后缀</code></li><li>当前目录文件：<code>文件名.后缀</code></li></ul><h2 id="输入法切换">输入法切换</h2><p>当只有一个输入法或语言时：<code>win+空格</code>不能切换，需要添加一个语言才可以。</p><h2 id="删除右键菜单项目">删除右键菜单项目</h2><ul><li><p>注册表：计算机_CLASSES_ROOT</p><blockquote><p>这里面的<code>shell</code>是在桌面的情况下的右键菜单</p></blockquote></li><li><p>注册表：计算机_CLASSES_ROOT</p><blockquote><p>这个里面的<code>shell</code>是在<strong>右键点击文件</strong>的菜单</p></blockquote></li></ul><h2 id="安装激活-sublime-text4-4180">安装激活 sublime text4 4180</h2><p><a href="https://segmentfault.com/a/1190000045171775">运维 - SublimeText4 4180 安装激活 - 个人文章 - SegmentFault 思否</a></p><h2 id="steam市场批量卖出">steam市场批量卖出</h2><p>https://steamcommunity.com/market/multisell?appid=730&amp;contextid=2&amp;items[]=Kilowatt%20Case</p><p>:star:最后等号后面为物品代码（可以到市场点击物品查看复制）</p><h2 id="解决python图表中文乱码问题">解决Python图表中文乱码问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-comment"># 直接指定系统字体路径（适用于已知字体路径的情况）</span><br>plt.rcParams[<span class="hljs-string">&#x27;font.sans-serif&#x27;</span>] = [<span class="hljs-string">&#x27;SimHei&#x27;</span>]  <span class="hljs-comment"># 使用黑体</span><br>plt.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span>    <span class="hljs-comment"># 解决负号显示问题</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聪明的投资者——投资指南</title>
    <link href="/2024/10/25/2024-10-25-%E8%81%AA%E6%98%8E%E7%9A%84%E6%8A%95%E8%B5%84%E8%80%85%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/10/25/2024-10-25-%E8%81%AA%E6%98%8E%E7%9A%84%E6%8A%95%E8%B5%84%E8%80%85%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="聪明的投资者投资指南">聪明的投资者——投资指南</h1><p>防御型投资者和进攻型投资者之间的主要区别在于：</p><ul><li>防御型投资者要限制自己向大的和领先的公司投资</li><li>进攻型投资者的判断力和技巧告诉他这些公司有足够吸引力，那么他可能购买他们的股票</li></ul><p>评估普通股的规则：</p><ul><li><p>评估价值取决于对收益能力的预测，因此要选用合适的倍数，如果必要还要通过调整资产价值来决定</p></li><li><p>收益能力一般代表对未来7年平均收益的预测</p></li><li><p>上面的预测起点就是过去7到10年的真实情况</p></li><li><p>把早些年的价格用到计算中时，应该做出适当的调整，以反映后来的资本额所导致的变动</p></li><li><p>倍数应该反应未来收益更长期的变化</p><blockquote><p>倍数选12对股票的中立预测比较适当，也就是每股收益年预期增长不超过2%，这个数字的增加或家烧依赖于评估者的判断和偏爱，除了异常情况外，<strong>最大的倍数应该是20，最小的倍数应该是8</strong></p></blockquote></li><li><p>如果有形资产价值少于收益能力价值；将收益能力价值超过资产价值2倍的量减少0.25</p></li><li><p>如果净流动资产机制超过了收益能力价值，可以让后者增大到超过最后估定价值的50%</p></li></ul><h2 id="投资的一般方法">投资的一般方法</h2><h3 id="防御型投资者">防御型投资者</h3><p>策略：在股票和债券中选择比例平衡，一般市场情况下选择50%股票和50%债券，股市行情很好的时候慢慢的讲股票的占比往下调整并往上调整债券的比例。极端（25%的股票75%的债券）；当股市行情萧条或不好的时候反着调整资金在股票和债券中的占比。这种调整的主要目的和结果是比单纯全债券投资的收益高那么一点，如果债券收益为4%，那么这种策略会将这个收益提高到6%到8%左右。</p><h3 id="进攻型投资者">进攻型投资者</h3><p>策略：</p><ul><li><p>普通交易——全面产业市场活动，就像“平均指数”反应的那样。</p></li><li><p>有选择的交易——选择在一年左右时间中比一般股票在市场上表现更好的证券。</p><blockquote><p>:star:普通交易和有选择的交易在投资时间中并没有什么实际作用，这两者都有投机的特点，要其成功，潜在条件就是比大量专业投资者还聪明，显然这是很难做到的。</p></blockquote></li><li><p>低买高卖——当价格及行情较不乐观时入市，等到两者都上升时卖出。</p><blockquote><p>这种原理，也只有在特殊的情况下才能做到，也不太实用。这种就是等待购买机会，直到价格明显很低，但这样做并不容易。这种最怕的就是计算错误。</p></blockquote></li><li><p>长线选择——选择将来比一般企业更成功的公司（成长型股票）</p><blockquote><p>这种公司如果正确估计了它们的价值，那么会取得非凡的成绩，但是如果估计错失，代价也是非常之大。这个策略的主要障碍在于一个固有事实：:star:如果一个公司前途明显比较好，那几乎肯定已经在当前的股票价格中得到反应——经常过分贴现。有这样一条公理：:smile:如果总是做显而易见或大家都在做的事，你就赚不到钱。相反，如果大多数人和你的判断不一样，而且你的判断是正确的，那么就有机会获得丰厚的收益。但具有在别人判断都错误时判断正确的能力的人几乎是不存在的。这种预见力不能被看作理性投资的特点。</p></blockquote></li><li><p>廉价购买——购买那些经可靠的方法衡量，价格大大低于它们真实价值的证券。</p><blockquote><p>对进攻型投资者而言，也只有最后这种策略比较适合了。不受欢迎的股票通常价格过低。在熊市或萧条时期的后面，一个企业呈现不景气的时候，他的股票价格就会很低，甚至低得离谱。一旦我们足够的分析完成，并且显著的特点（市场低迷，企业不景气）出现，那么理性投资者要有必要的资料使自己确信该投资是正确的、有吸引力的；不应该盲从他人的建议，而应该有自己的判断力。</p></blockquote></li></ul><h3 id="防御型投资者应该购买">防御型投资者应该购买：</h3><ul><li>政府债券和免税证券</li><li>各种主要的普通股（大蓝筹）</li><li>主要的投资基金股份（好点的ETF）</li></ul><h3 id="进攻型投资者应该购买">进攻型投资者应该购买：</h3><ul><li>防御型投资者所有购买的</li><li>成长股，但应小心</li><li>重要的公司股票，其不被看好从而卖价大大低于平均收入增值率</li><li>在廉价水平上购买二级普通股、公司债券和优先股（小盘股）</li><li>一些特殊的可转债，甚至可能以全价购买。</li></ul><p>在买入证券后，如果之前自己购买是的<strong>逻辑</strong>没有改变，就持股守息。不要因为市场的波动改变持有的状态。</p>]]></content>
    
    
    <categories>
      
      <category>投资</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投资</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdowm表情符号</title>
    <link href="/2024/10/05/2024-10-05-markdown%E8%A1%A8%E6%83%85%E7%AC%A6%E5%8F%B7%E8%A1%A8/"/>
    <url>/2024/10/05/2024-10-05-markdown%E8%A1%A8%E6%83%85%E7%AC%A6%E5%8F%B7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>People</p><table><thead><tr><th>:bowtie: <code>:bowtie:</code></th><th>:smile: <code>:smile:</code></th><th>:laughing: <code>:laughing:</code></th></tr></thead><tbody><tr><td>:blush: <code>:blush:</code></td><td>:smiley: <code>:smiley:</code></td><td>:relaxed: <code>:relaxed:</code></td></tr><tr><td>:smirk: <code>:smirk:</code></td><td>:heart_eyes: <code>:heart_eyes:</code></td><td>:kissing_heart: <code>:kissing_heart:</code></td></tr><tr><td>:kissing_closed_eyes: <code>:kissing_closed_eyes:</code></td><td>:flushed: <code>:flushed:</code></td><td>:relieved: <code>:relieved:</code></td></tr><tr><td>:satisfied: <code>:satisfied:</code></td><td>:grin: <code>:grin:</code></td><td>:wink: <code>:wink:</code></td></tr><tr><td>:stuck_out_tongue_winking_eye:<code>:stuck_out_tongue_winking_eye:</code></td><td>:stuck_out_tongue_closed_eyes:<code>:stuck_out_tongue_closed_eyes:</code></td><td>:grinning: <code>:grinning:</code></td></tr><tr><td>:kissing: <code>:kissing:</code></td><td>:kissing_smiling_eyes: <code>:kissing_smiling_eyes:</code></td><td>:stuck_out_tongue: <code>:stuck_out_tongue:</code></td></tr><tr><td>:sleeping: <code>:sleeping:</code></td><td>:worried: <code>:worried:</code></td><td>:frowning: <code>:frowning:</code></td></tr><tr><td>:anguished: <code>:anguished:</code></td><td>:open_mouth: <code>:open_mouth:</code></td><td>:grimacing: <code>:grimacing:</code></td></tr><tr><td>:confused: <code>:confused:</code></td><td>:hushed: <code>:hushed:</code></td><td>:expressionless: <code>:expressionless:</code></td></tr><tr><td>:unamused: <code>:unamused:</code></td><td>:sweat_smile: <code>:sweat_smile:</code></td><td>:sweat: <code>:sweat:</code></td></tr><tr><td>:disappointed_relieved: <code>:disappointed_relieved:</code></td><td>:weary: <code>:weary:</code></td><td>:pensive: <code>:pensive:</code></td></tr><tr><td>:disappointed: <code>:disappointed:</code></td><td>:confounded: <code>:confounded:</code></td><td>:fearful: <code>:fearful:</code></td></tr><tr><td>:cold_sweat: <code>:cold_sweat:</code></td><td>:persevere: <code>:persevere:</code></td><td>:cry: <code>:cry:</code></td></tr><tr><td>:sob: <code>:sob:</code></td><td>:joy: <code>:joy:</code></td><td>:astonished: <code>:astonished:</code></td></tr><tr><td>:scream: <code>:scream:</code></td><td>:neckbeard: <code>:neckbeard:</code></td><td>:tired_face: <code>:tired_face:</code></td></tr><tr><td>:angry: <code>:angry:</code></td><td>:rage: <code>:rage:</code></td><td>:triumph: <code>:triumph:</code></td></tr><tr><td>:sleepy: <code>:sleepy:</code></td><td>:yum: <code>:yum:</code></td><td>:mask: <code>:mask:</code></td></tr><tr><td>:sunglasses: <code>:sunglasses:</code></td><td>:dizzy_face: <code>:dizzy_face:</code></td><td>:imp: <code>:imp:</code></td></tr><tr><td>:smiling_imp: <code>:smiling_imp:</code></td><td>:neutral_face: <code>:neutral_face:</code></td><td>:no_mouth: <code>:no_mouth:</code></td></tr><tr><td>:innocent: <code>:innocent:</code></td><td>:alien: <code>:alien:</code></td><td>:yellow_heart: <code>:yellow_heart:</code></td></tr><tr><td>:blue_heart: <code>:blue_heart:</code></td><td>:purple_heart: <code>:purple_heart:</code></td><td>:heart: <code>:heart:</code></td></tr><tr><td>:green_heart: <code>:green_heart:</code></td><td>:broken_heart: <code>:broken_heart:</code></td><td>:heartbeat: <code>:heartbeat:</code></td></tr><tr><td>:heartpulse: <code>:heartpulse:</code></td><td>:two_hearts: <code>:two_hearts:</code></td><td>:revolving_hearts: <code>:revolving_hearts:</code></td></tr><tr><td>:cupid: <code>:cupid:</code></td><td>:sparkling_heart: <code>:sparkling_heart:</code></td><td>:sparkles: <code>:sparkles:</code></td></tr><tr><td>:star: <code>:star:</code></td><td>:star2: <code>:star2:</code></td><td>:dizzy: <code>:dizzy:</code></td></tr><tr><td>:boom: <code>:boom:</code></td><td>:collision: <code>:collision:</code></td><td>:anger: <code>:anger:</code></td></tr><tr><td>:exclamation: <code>:exclamation:</code></td><td>:question: <code>:question:</code></td><td>:grey_exclamation: <code>:grey_exclamation:</code></td></tr><tr><td>:grey_question: <code>:grey_question:</code></td><td>:zzz: <code>:zzz:</code></td><td>:dash: <code>:dash:</code></td></tr><tr><td>:sweat_drops: <code>:sweat_drops:</code></td><td>:notes: <code>:notes:</code></td><td>:musical_note: <code>:musical_note:</code></td></tr><tr><td>:fire: <code>:fire:</code></td><td>:hankey: <code>:hankey:</code></td><td>:poop: <code>:poop:</code></td></tr><tr><td>:shit: <code>:shit:</code></td><td>:+1: <code>:+1:</code></td><td>:thumbsup: <code>:thumbsup:</code></td></tr><tr><td>:-1: <code>:-1:</code></td><td>:thumbsdown: <code>:thumbsdown:</code></td><td>:ok_hand: <code>:ok_hand:</code></td></tr><tr><td>:punch: <code>:punch:</code></td><td>:facepunch: <code>:facepunch:</code></td><td>:fist: <code>:fist:</code></td></tr><tr><td>:v: <code>:v:</code></td><td>:wave: <code>:wave:</code></td><td>:hand: <code>:hand:</code></td></tr><tr><td>:raised_hand: <code>:raised_hand:</code></td><td>:open_hands: <code>:open_hands:</code></td><td>:point_up: <code>:point_up:</code></td></tr><tr><td>:point_down: <code>:point_down:</code></td><td>:point_left: <code>:point_left:</code></td><td>:point_right: <code>:point_right:</code></td></tr><tr><td>:raised_hands: <code>:raised_hands:</code></td><td>:pray: <code>:pray:</code></td><td>:point_up_2: <code>:point_up_2:</code></td></tr><tr><td>:clap: <code>:clap:</code></td><td>:muscle: <code>:muscle:</code></td><td>:metal: <code>:metal:</code></td></tr><tr><td>:fu: <code>:fu:</code></td><td>:walking: <code>:walking:</code></td><td>:runner: <code>:runner:</code></td></tr><tr><td>:running: <code>:running:</code></td><td>:couple: <code>:couple:</code></td><td>:family: <code>:family:</code></td></tr><tr><td>:two_men_holding_hands: <code>:two_men_holding_hands:</code></td><td>:two_women_holding_hands:<code>:two_women_holding_hands:</code></td><td>:dancer: <code>:dancer:</code></td></tr><tr><td>:dancers: <code>:dancers:</code></td><td>:ok_woman: <code>:ok_woman:</code></td><td>:no_good: <code>:no_good:</code></td></tr><tr><td>:information_desk_person:<code>:information_desk_person:</code></td><td>:raising_hand: <code>:raising_hand:</code></td><td>:bride_with_veil: <code>:bride_with_veil:</code></td></tr><tr><td>:person_with_pouting_face:<code>:person_with_pouting_face:</code></td><td>:person_frowning: <code>:person_frowning:</code></td><td>:bow: <code>:bow:</code></td></tr><tr><td>:couplekiss: <code>:couplekiss:</code></td><td>:couple_with_heart: <code>:couple_with_heart:</code></td><td>:massage: <code>:massage:</code></td></tr><tr><td>:haircut: <code>:haircut:</code></td><td>:nail_care: <code>:nail_care:</code></td><td>:boy: <code>:boy:</code></td></tr><tr><td>:girl: <code>:girl:</code></td><td>:woman: <code>:woman:</code></td><td>:man: <code>:man:</code></td></tr><tr><td>:baby: <code>:baby:</code></td><td>:older_woman: <code>:older_woman:</code></td><td>:older_man: <code>:older_man:</code></td></tr><tr><td>:person_with_blond_hair: <code>:person_with_blond_hair:</code></td><td>:man_with_gua_pi_mao: <code>:man_with_gua_pi_mao:</code></td><td>:man_with_turban: <code>:man_with_turban:</code></td></tr><tr><td>:construction_worker: <code>:construction_worker:</code></td><td>:cop: <code>:cop:</code></td><td>:angel: <code>:angel:</code></td></tr><tr><td>:princess: <code>:princess:</code></td><td>:smiley_cat: <code>:smiley_cat:</code></td><td>:smile_cat: <code>:smile_cat:</code></td></tr><tr><td>:heart_eyes_cat: <code>:heart_eyes_cat:</code></td><td>:kissing_cat: <code>:kissing_cat:</code></td><td>:smirk_cat: <code>:smirk_cat:</code></td></tr><tr><td>:scream_cat: <code>:scream_cat:</code></td><td>:crying_cat_face: <code>:crying_cat_face:</code></td><td>:joy_cat: <code>:joy_cat:</code></td></tr><tr><td>:pouting_cat: <code>:pouting_cat:</code></td><td>:japanese_ogre: <code>:japanese_ogre:</code></td><td>:japanese_goblin: <code>:japanese_goblin:</code></td></tr><tr><td>:see_no_evil: <code>:see_no_evil:</code></td><td>:hear_no_evil: <code>:hear_no_evil:</code></td><td>:speak_no_evil: <code>:speak_no_evil:</code></td></tr><tr><td>:guardsman: <code>:guardsman:</code></td><td>:skull: <code>:skull:</code></td><td>:feet: <code>:feet:</code></td></tr><tr><td>:lips: <code>:lips:</code></td><td>:kiss: <code>:kiss:</code></td><td>:droplet: <code>:droplet:</code></td></tr><tr><td>:ear: <code>:ear:</code></td><td>:eyes: <code>:eyes:</code></td><td>:nose: <code>:nose:</code></td></tr><tr><td>:tongue: <code>:tongue:</code></td><td>:love_letter: <code>:love_letter:</code></td><td>:bust_in_silhouette: <code>:bust_in_silhouette:</code></td></tr><tr><td>:busts_in_silhouette: <code>:busts_in_silhouette:</code></td><td>:speech_balloon: <code>:speech_balloon:</code></td><td>:thought_balloon: <code>:thought_balloon:</code></td></tr><tr><td>:feelsgood: <code>:feelsgood:</code></td><td>:finnadie: <code>:finnadie:</code></td><td>:goberserk: <code>:goberserk:</code></td></tr><tr><td>:godmode: <code>:godmode:</code></td><td>:hurtrealbad: <code>:hurtrealbad:</code></td><td>:rage1: <code>:rage1:</code></td></tr><tr><td>:rage2: <code>:rage2:</code></td><td>:rage3: <code>:rage3:</code></td><td>:rage4: <code>:rage4:</code></td></tr><tr><td>:suspect: <code>:suspect:</code></td><td>:trollface: <code>:trollface:</code></td><td></td></tr></tbody></table><p>Nature</p><table><thead><tr><th>:sunny: <code>:sunny:</code></th><th>:umbrella: <code>:umbrella:</code></th><th>:cloud: <code>:cloud:</code></th></tr></thead><tbody><tr><td>:snowflake: <code>:snowflake:</code></td><td>:snowman: <code>:snowman:</code></td><td>:zap: <code>:zap:</code></td></tr><tr><td>:cyclone: <code>:cyclone:</code></td><td>:foggy: <code>:foggy:</code></td><td>:ocean: <code>:ocean:</code></td></tr><tr><td>:cat: <code>:cat:</code></td><td>:dog: <code>:dog:</code></td><td>:mouse: <code>:mouse:</code></td></tr><tr><td>:hamster: <code>:hamster:</code></td><td>:rabbit: <code>:rabbit:</code></td><td>:wolf: <code>:wolf:</code></td></tr><tr><td>:frog: <code>:frog:</code></td><td>:tiger: <code>:tiger:</code></td><td>:koala: <code>:koala:</code></td></tr><tr><td>:bear: <code>:bear:</code></td><td>:pig: <code>:pig:</code></td><td>:pig_nose: <code>:pig_nose:</code></td></tr><tr><td>:cow: <code>:cow:</code></td><td>:boar: <code>:boar:</code></td><td>:monkey_face: <code>:monkey_face:</code></td></tr><tr><td>:monkey: <code>:monkey:</code></td><td>:horse: <code>:horse:</code></td><td>:racehorse: <code>:racehorse:</code></td></tr><tr><td>:camel: <code>:camel:</code></td><td>:sheep: <code>:sheep:</code></td><td>:elephant: <code>:elephant:</code></td></tr><tr><td>:panda_face: <code>:panda_face:</code></td><td>:snake: <code>:snake:</code></td><td>:bird: <code>:bird:</code></td></tr><tr><td>:baby_chick: <code>:baby_chick:</code></td><td>:hatched_chick: <code>:hatched_chick:</code></td><td>:hatching_chick: <code>:hatching_chick:</code></td></tr><tr><td>:chicken: <code>:chicken:</code></td><td>:penguin: <code>:penguin:</code></td><td>:turtle: <code>:turtle:</code></td></tr><tr><td>:bug: <code>:bug:</code></td><td>:honeybee: <code>:honeybee:</code></td><td>:ant: <code>:ant:</code></td></tr><tr><td>:beetle: <code>:beetle:</code></td><td>:snail: <code>:snail:</code></td><td>:octopus: <code>:octopus:</code></td></tr><tr><td>:tropical_fish: <code>:tropical_fish:</code></td><td>:fish: <code>:fish:</code></td><td>:whale: <code>:whale:</code></td></tr><tr><td>:whale2: <code>:whale2:</code></td><td>:dolphin: <code>:dolphin:</code></td><td>:cow2: <code>:cow2:</code></td></tr><tr><td>:ram: <code>:ram:</code></td><td>:rat: <code>:rat:</code></td><td>:water_buffalo: <code>:water_buffalo:</code></td></tr><tr><td>:tiger2: <code>:tiger2:</code></td><td>:rabbit2: <code>:rabbit2:</code></td><td>:dragon: <code>:dragon:</code></td></tr><tr><td>:goat: <code>:goat:</code></td><td>:rooster: <code>:rooster:</code></td><td>:dog2: <code>:dog2:</code></td></tr><tr><td>:pig2: <code>:pig2:</code></td><td>:mouse2: <code>:mouse2:</code></td><td>:ox: <code>:ox:</code></td></tr><tr><td>:dragon_face: <code>:dragon_face:</code></td><td>:blowfish: <code>:blowfish:</code></td><td>:crocodile: <code>:crocodile:</code></td></tr><tr><td>:dromedary_camel: <code>:dromedary_camel:</code></td><td>:leopard: <code>:leopard:</code></td><td>:cat2: <code>:cat2:</code></td></tr><tr><td>:poodle: <code>:poodle:</code></td><td>:paw_prints: <code>:paw_prints:</code></td><td>:bouquet: <code>:bouquet:</code></td></tr><tr><td>:cherry_blossom: <code>:cherry_blossom:</code></td><td>:tulip: <code>:tulip:</code></td><td>:four_leaf_clover: <code>:four_leaf_clover:</code></td></tr><tr><td>:rose: <code>:rose:</code></td><td>:sunflower: <code>:sunflower:</code></td><td>:hibiscus: <code>:hibiscus:</code></td></tr><tr><td>:maple_leaf: <code>:maple_leaf:</code></td><td>:leaves: <code>:leaves:</code></td><td>:fallen_leaf: <code>:fallen_leaf:</code></td></tr><tr><td>:herb: <code>:herb:</code></td><td>:mushroom: <code>:mushroom:</code></td><td>:cactus: <code>:cactus:</code></td></tr><tr><td>:palm_tree: <code>:palm_tree:</code></td><td>:evergreen_tree: <code>:evergreen_tree:</code></td><td>:deciduous_tree: <code>:deciduous_tree:</code></td></tr><tr><td>:chestnut: <code>:chestnut:</code></td><td>:seedling: <code>:seedling:</code></td><td>:blossom: <code>:blossom:</code></td></tr><tr><td>:ear_of_rice: <code>:ear_of_rice:</code></td><td>:shell: <code>:shell:</code></td><td>:globe_with_meridians: <code>:globe_with_meridians:</code></td></tr><tr><td>:sun_with_face: <code>:sun_with_face:</code></td><td>:full_moon_with_face: <code>:full_moon_with_face:</code></td><td>:new_moon_with_face: <code>:new_moon_with_face:</code></td></tr><tr><td>:new_moon: <code>:new_moon:</code></td><td>:waxing_crescent_moon: <code>:waxing_crescent_moon:</code></td><td>:first_quarter_moon: <code>:first_quarter_moon:</code></td></tr><tr><td>:waxing_gibbous_moon: <code>:waxing_gibbous_moon:</code></td><td>:full_moon: <code>:full_moon:</code></td><td>:waning_gibbous_moon: <code>:waning_gibbous_moon:</code></td></tr><tr><td>:last_quarter_moon: <code>:last_quarter_moon:</code></td><td>:waning_crescent_moon: <code>:waning_crescent_moon:</code></td><td>:last_quarter_moon_with_face:<code>:last_quarter_moon_with_face:</code></td></tr><tr><td>:first_quarter_moon_with_face:<code>:first_quarter_moon_with_face:</code></td><td>:moon: <code>:moon:</code></td><td>:earth_africa: <code>:earth_africa:</code></td></tr><tr><td>:earth_americas: <code>:earth_americas:</code></td><td>:earth_asia: <code>:earth_asia:</code></td><td>:volcano: <code>:volcano:</code></td></tr><tr><td>:milky_way: <code>:milky_way:</code></td><td>:partly_sunny: <code>:partly_sunny:</code></td><td>:octocat: <code>:octocat:</code></td></tr><tr><td>:squirrel: <code>:squirrel:</code></td><td></td><td></td></tr></tbody></table><p>Objects</p><table><thead><tr><th>:bamboo: <code>:bamboo:</code></th><th>:gift_heart: <code>:gift_heart:</code></th><th>:dolls: <code>:dolls:</code></th></tr></thead><tbody><tr><td>:school_satchel: <code>:school_satchel:</code></td><td>:mortar_board: <code>:mortar_board:</code></td><td>:flags: <code>:flags:</code></td></tr><tr><td>:fireworks: <code>:fireworks:</code></td><td>:sparkler: <code>:sparkler:</code></td><td>:wind_chime: <code>:wind_chime:</code></td></tr><tr><td>:rice_scene: <code>:rice_scene:</code></td><td>:jack_o_lantern: <code>:jack_o_lantern:</code></td><td>:ghost: <code>:ghost:</code></td></tr><tr><td>:santa: <code>:santa:</code></td><td>:christmas_tree: <code>:christmas_tree:</code></td><td>:gift: <code>:gift:</code></td></tr><tr><td>:bell: <code>:bell:</code></td><td>:no_bell: <code>:no_bell:</code></td><td>:tanabata_tree: <code>:tanabata_tree:</code></td></tr><tr><td>:tada: <code>:tada:</code></td><td>:confetti_ball: <code>:confetti_ball:</code></td><td>:balloon: <code>:balloon:</code></td></tr><tr><td>:crystal_ball: <code>:crystal_ball:</code></td><td>:cd: <code>:cd:</code></td><td>:dvd: <code>:dvd:</code></td></tr><tr><td>:floppy_disk: <code>:floppy_disk:</code></td><td>:camera: <code>:camera:</code></td><td>:video_camera: <code>:video_camera:</code></td></tr><tr><td>:movie_camera: <code>:movie_camera:</code></td><td>:computer: <code>:computer:</code></td><td>:tv: <code>:tv:</code></td></tr><tr><td>:iphone: <code>:iphone:</code></td><td>:phone: <code>:phone:</code></td><td>:telephone: <code>:telephone:</code></td></tr><tr><td>:telephone_receiver: <code>:telephone_receiver:</code></td><td>:pager: <code>:pager:</code></td><td>:fax: <code>:fax:</code></td></tr><tr><td>:minidisc: <code>:minidisc:</code></td><td>:vhs: <code>:vhs:</code></td><td>:sound: <code>:sound:</code></td></tr><tr><td>:speaker: <code>:speaker:</code></td><td>:mute: <code>:mute:</code></td><td>:loudspeaker: <code>:loudspeaker:</code></td></tr><tr><td>:mega: <code>:mega:</code></td><td>:hourglass: <code>:hourglass:</code></td><td>:hourglass_flowing_sand: <code>:hourglass_flowing_sand:</code></td></tr><tr><td>:alarm_clock: <code>:alarm_clock:</code></td><td>:watch: <code>:watch:</code></td><td>:radio: <code>:radio:</code></td></tr><tr><td>:satellite: <code>:satellite:</code></td><td>:loop: <code>:loop:</code></td><td>:mag: <code>:mag:</code></td></tr><tr><td>:mag_right: <code>:mag_right:</code></td><td>:unlock: <code>:unlock:</code></td><td>:lock: <code>:lock:</code></td></tr><tr><td>:lock_with_ink_pen: <code>:lock_with_ink_pen:</code></td><td>:closed_lock_with_key: <code>:closed_lock_with_key:</code></td><td>:key: <code>:key:</code></td></tr><tr><td>:bulb: <code>:bulb:</code></td><td>:flashlight: <code>:flashlight:</code></td><td>:high_brightness: <code>:high_brightness:</code></td></tr><tr><td>:low_brightness: <code>:low_brightness:</code></td><td>:electric_plug: <code>:electric_plug:</code></td><td>:battery: <code>:battery:</code></td></tr><tr><td>:calling: <code>:calling:</code></td><td>:email: <code>:email:</code></td><td>:mailbox: <code>:mailbox:</code></td></tr><tr><td>:postbox: <code>:postbox:</code></td><td>:bath: <code>:bath:</code></td><td>:bathtub: <code>:bathtub:</code></td></tr><tr><td>:shower: <code>:shower:</code></td><td>:toilet: <code>:toilet:</code></td><td>:wrench: <code>:wrench:</code></td></tr><tr><td>:nut_and_bolt: <code>:nut_and_bolt:</code></td><td>:hammer: <code>:hammer:</code></td><td>:seat: <code>:seat:</code></td></tr><tr><td>:moneybag: <code>:moneybag:</code></td><td>:yen: <code>:yen:</code></td><td>:dollar: <code>:dollar:</code></td></tr><tr><td>:pound: <code>:pound:</code></td><td>:euro: <code>:euro:</code></td><td>:credit_card: <code>:credit_card:</code></td></tr><tr><td>:money_with_wings: <code>:money_with_wings:</code></td><td>:e-mail: <code>:e-mail:</code></td><td>:inbox_tray: <code>:inbox_tray:</code></td></tr><tr><td>:outbox_tray: <code>:outbox_tray:</code></td><td>:envelope: <code>:envelope:</code></td><td>:incoming_envelope: <code>:incoming_envelope:</code></td></tr><tr><td>:postal_horn: <code>:postal_horn:</code></td><td>:mailbox_closed: <code>:mailbox_closed:</code></td><td>:mailbox_with_mail: <code>:mailbox_with_mail:</code></td></tr><tr><td>:mailbox_with_no_mail: <code>:mailbox_with_no_mail:</code></td><td>:door: <code>:door:</code></td><td>:smoking: <code>:smoking:</code></td></tr><tr><td>:bomb: <code>:bomb:</code></td><td>:gun: <code>:gun:</code></td><td>:hocho: <code>:hocho:</code></td></tr><tr><td>:pill: <code>:pill:</code></td><td>:syringe: <code>:syringe:</code></td><td>:page_facing_up: <code>:page_facing_up:</code></td></tr><tr><td>:page_with_curl: <code>:page_with_curl:</code></td><td>:bookmark_tabs: <code>:bookmark_tabs:</code></td><td>:bar_chart: <code>:bar_chart:</code></td></tr><tr><td>:chart_with_upwards_trend:<code>:chart_with_upwards_trend:</code></td><td>:chart_with_downwards_trend:<code>:chart_with_downwards_trend:</code></td><td>:scroll: <code>:scroll:</code></td></tr><tr><td>:clipboard: <code>:clipboard:</code></td><td>:calendar: <code>:calendar:</code></td><td>:date: <code>:date:</code></td></tr><tr><td>:card_index: <code>:card_index:</code></td><td>:file_folder: <code>:file_folder:</code></td><td>:open_file_folder: <code>:open_file_folder:</code></td></tr><tr><td>:scissors: <code>:scissors:</code></td><td>:pushpin: <code>:pushpin:</code></td><td>:paperclip: <code>:paperclip:</code></td></tr><tr><td>:black_nib: <code>:black_nib:</code></td><td>:pencil2: <code>:pencil2:</code></td><td>:straight_ruler: <code>:straight_ruler:</code></td></tr><tr><td>:triangular_ruler: <code>:triangular_ruler:</code></td><td>:closed_book: <code>:closed_book:</code></td><td>:green_book: <code>:green_book:</code></td></tr><tr><td>:blue_book: <code>:blue_book:</code></td><td>:orange_book: <code>:orange_book:</code></td><td>:notebook: <code>:notebook:</code></td></tr><tr><td>:notebook_with_decorative_cover:<code>:notebook_with_decorative_cover:</code></td><td>:ledger: <code>:ledger:</code></td><td>:books: <code>:books:</code></td></tr><tr><td>:bookmark: <code>:bookmark:</code></td><td>:name_badge: <code>:name_badge:</code></td><td>:microscope: <code>:microscope:</code></td></tr><tr><td>:telescope: <code>:telescope:</code></td><td>:newspaper: <code>:newspaper:</code></td><td>:football: <code>:football:</code></td></tr><tr><td>:basketball: <code>:basketball:</code></td><td>:soccer: <code>:soccer:</code></td><td>:baseball: <code>:baseball:</code></td></tr><tr><td>:tennis: <code>:tennis:</code></td><td>:8ball: <code>:8ball:</code></td><td>:rugby_football: <code>:rugby_football:</code></td></tr><tr><td>:bowling: <code>:bowling:</code></td><td>:golf: <code>:golf:</code></td><td>:mountain_bicyclist: <code>:mountain_bicyclist:</code></td></tr><tr><td>:bicyclist: <code>:bicyclist:</code></td><td>:horse_racing: <code>:horse_racing:</code></td><td>:snowboarder: <code>:snowboarder:</code></td></tr><tr><td>:swimmer: <code>:swimmer:</code></td><td>:surfer: <code>:surfer:</code></td><td>:ski: <code>:ski:</code></td></tr><tr><td>:spades: <code>:spades:</code></td><td>:hearts: <code>:hearts:</code></td><td>:clubs: <code>:clubs:</code></td></tr><tr><td>:diamonds: <code>:diamonds:</code></td><td>:gem: <code>:gem:</code></td><td>:ring: <code>:ring:</code></td></tr><tr><td>:trophy: <code>:trophy:</code></td><td>:musical_score: <code>:musical_score:</code></td><td>:musical_keyboard: <code>:musical_keyboard:</code></td></tr><tr><td>:violin: <code>:violin:</code></td><td>:space_invader: <code>:space_invader:</code></td><td>:video_game: <code>:video_game:</code></td></tr><tr><td>:black_joker: <code>:black_joker:</code></td><td>:flower_playing_cards: <code>:flower_playing_cards:</code></td><td>:game_die: <code>:game_die:</code></td></tr><tr><td>:dart: <code>:dart:</code></td><td>:mahjong: <code>:mahjong:</code></td><td>:clapper: <code>:clapper:</code></td></tr><tr><td>:memo: <code>:memo:</code></td><td>:pencil: <code>:pencil:</code></td><td>:book: <code>:book:</code></td></tr><tr><td>:art: <code>:art:</code></td><td>:microphone: <code>:microphone:</code></td><td>:headphones: <code>:headphones:</code></td></tr><tr><td>:trumpet: <code>:trumpet:</code></td><td>:saxophone: <code>:saxophone:</code></td><td>:guitar: <code>:guitar:</code></td></tr><tr><td>:shoe: <code>:shoe:</code></td><td>:sandal: <code>:sandal:</code></td><td>:high_heel: <code>:high_heel:</code></td></tr><tr><td>:lipstick: <code>:lipstick:</code></td><td>:boot: <code>:boot:</code></td><td>:shirt: <code>:shirt:</code></td></tr><tr><td>:tshirt: <code>:tshirt:</code></td><td>:necktie: <code>:necktie:</code></td><td>:womans_clothes: <code>:womans_clothes:</code></td></tr><tr><td>:dress: <code>:dress:</code></td><td>:running_shirt_with_sash:<code>:running_shirt_with_sash:</code></td><td>:jeans: <code>:jeans:</code></td></tr><tr><td>:kimono: <code>:kimono:</code></td><td>:bikini: <code>:bikini:</code></td><td>:ribbon: <code>:ribbon:</code></td></tr><tr><td>:tophat: <code>:tophat:</code></td><td>:crown: <code>:crown:</code></td><td>:womans_hat: <code>:womans_hat:</code></td></tr><tr><td>:mans_shoe: <code>:mans_shoe:</code></td><td>:closed_umbrella: <code>:closed_umbrella:</code></td><td>:briefcase: <code>:briefcase:</code></td></tr><tr><td>:handbag: <code>:handbag:</code></td><td>:pouch: <code>:pouch:</code></td><td>:purse: <code>:purse:</code></td></tr><tr><td>:eyeglasses: <code>:eyeglasses:</code></td><td>:fishing_pole_and_fish: <code>:fishing_pole_and_fish:</code></td><td>:coffee: <code>:coffee:</code></td></tr><tr><td>:tea: <code>:tea:</code></td><td>:sake: <code>:sake:</code></td><td>:baby_bottle: <code>:baby_bottle:</code></td></tr><tr><td>:beer: <code>:beer:</code></td><td>:beers: <code>:beers:</code></td><td>:cocktail: <code>:cocktail:</code></td></tr><tr><td>:tropical_drink: <code>:tropical_drink:</code></td><td>:wine_glass: <code>:wine_glass:</code></td><td>:fork_and_knife: <code>:fork_and_knife:</code></td></tr><tr><td>:pizza: <code>:pizza:</code></td><td>:hamburger: <code>:hamburger:</code></td><td>:fries: <code>:fries:</code></td></tr><tr><td>:poultry_leg: <code>:poultry_leg:</code></td><td>:meat_on_bone: <code>:meat_on_bone:</code></td><td>:spaghetti: <code>:spaghetti:</code></td></tr><tr><td>:curry: <code>:curry:</code></td><td>:fried_shrimp: <code>:fried_shrimp:</code></td><td>:bento: <code>:bento:</code></td></tr><tr><td>:sushi: <code>:sushi:</code></td><td>:fish_cake: <code>:fish_cake:</code></td><td>:rice_ball: <code>:rice_ball:</code></td></tr><tr><td>:rice_cracker: <code>:rice_cracker:</code></td><td>:rice: <code>:rice:</code></td><td>:ramen: <code>:ramen:</code></td></tr><tr><td>:stew: <code>:stew:</code></td><td>:oden: <code>:oden:</code></td><td>:dango: <code>:dango:</code></td></tr><tr><td>:egg: <code>:egg:</code></td><td>:bread: <code>:bread:</code></td><td>:doughnut: <code>:doughnut:</code></td></tr><tr><td>:custard: <code>:custard:</code></td><td>:icecream: <code>:icecream:</code></td><td>:ice_cream: <code>:ice_cream:</code></td></tr><tr><td>:shaved_ice: <code>:shaved_ice:</code></td><td>:birthday: <code>:birthday:</code></td><td>:cake: <code>:cake:</code></td></tr><tr><td>:cookie: <code>:cookie:</code></td><td>:chocolate_bar: <code>:chocolate_bar:</code></td><td>:candy: <code>:candy:</code></td></tr><tr><td>:lollipop: <code>:lollipop:</code></td><td>:honey_pot: <code>:honey_pot:</code></td><td>:apple: <code>:apple:</code></td></tr><tr><td>:green_apple: <code>:green_apple:</code></td><td>:tangerine: <code>:tangerine:</code></td><td>:lemon: <code>:lemon:</code></td></tr><tr><td>:cherries: <code>:cherries:</code></td><td>:grapes: <code>:grapes:</code></td><td>:watermelon: <code>:watermelon:</code></td></tr><tr><td>:strawberry: <code>:strawberry:</code></td><td>:peach: <code>:peach:</code></td><td>:melon: <code>:melon:</code></td></tr><tr><td>:banana: <code>:banana:</code></td><td>:pear: <code>:pear:</code></td><td>:pineapple: <code>:pineapple:</code></td></tr><tr><td>:sweet_potato: <code>:sweet_potato:</code></td><td>:eggplant: <code>:eggplant:</code></td><td>:tomato: <code>:tomato:</code></td></tr><tr><td>:corn: <code>:corn:</code></td><td></td><td></td></tr></tbody></table><p>Places</p><table><thead><tr><th>:house: <code>:house:</code></th><th>:house_with_garden: <code>:house_with_garden:</code></th><th>:school: <code>:school:</code></th></tr></thead><tbody><tr><td>:office: <code>:office:</code></td><td>:post_office: <code>:post_office:</code></td><td>:hospital: <code>:hospital:</code></td></tr><tr><td>:bank: <code>:bank:</code></td><td>:convenience_store: <code>:convenience_store:</code></td><td>:love_hotel: <code>:love_hotel:</code></td></tr><tr><td>:hotel: <code>:hotel:</code></td><td>:wedding: <code>:wedding:</code></td><td>:church: <code>:church:</code></td></tr><tr><td>:department_store: <code>:department_store:</code></td><td>:european_post_office: <code>:european_post_office:</code></td><td>:city_sunrise: <code>:city_sunrise:</code></td></tr><tr><td>:city_sunset: <code>:city_sunset:</code></td><td>:japanese_castle: <code>:japanese_castle:</code></td><td>:european_castle: <code>:european_castle:</code></td></tr><tr><td>:tent: <code>:tent:</code></td><td>:factory: <code>:factory:</code></td><td>:tokyo_tower: <code>:tokyo_tower:</code></td></tr><tr><td>:japan: <code>:japan:</code></td><td>:mount_fuji: <code>:mount_fuji:</code></td><td>:sunrise_over_mountains: <code>:sunrise_over_mountains:</code></td></tr><tr><td>:sunrise: <code>:sunrise:</code></td><td>:stars: <code>:stars:</code></td><td>:statue_of_liberty: <code>:statue_of_liberty:</code></td></tr><tr><td>:bridge_at_night: <code>:bridge_at_night:</code></td><td>:carousel_horse: <code>:carousel_horse:</code></td><td>:rainbow: <code>:rainbow:</code></td></tr><tr><td>:ferris_wheel: <code>:ferris_wheel:</code></td><td>:fountain: <code>:fountain:</code></td><td>:roller_coaster: <code>:roller_coaster:</code></td></tr><tr><td>:ship: <code>:ship:</code></td><td>:speedboat: <code>:speedboat:</code></td><td>:boat: <code>:boat:</code></td></tr><tr><td>:sailboat: <code>:sailboat:</code></td><td>:rowboat: <code>:rowboat:</code></td><td>:anchor: <code>:anchor:</code></td></tr><tr><td>:rocket: <code>:rocket:</code></td><td>:airplane: <code>:airplane:</code></td><td>:helicopter: <code>:helicopter:</code></td></tr><tr><td>:steam_locomotive: <code>:steam_locomotive:</code></td><td>:tram: <code>:tram:</code></td><td>:mountain_railway: <code>:mountain_railway:</code></td></tr><tr><td>:bike: <code>:bike:</code></td><td>:aerial_tramway: <code>:aerial_tramway:</code></td><td>:suspension_railway: <code>:suspension_railway:</code></td></tr><tr><td>:mountain_cableway: <code>:mountain_cableway:</code></td><td>:tractor: <code>:tractor:</code></td><td>:blue_car: <code>:blue_car:</code></td></tr><tr><td>:oncoming_automobile: <code>:oncoming_automobile:</code></td><td>:car: <code>:car:</code></td><td>:red_car: <code>:red_car:</code></td></tr><tr><td>:taxi: <code>:taxi:</code></td><td>:oncoming_taxi: <code>:oncoming_taxi:</code></td><td>:articulated_lorry: <code>:articulated_lorry:</code></td></tr><tr><td>:bus: <code>:bus:</code></td><td>:oncoming_bus: <code>:oncoming_bus:</code></td><td>:rotating_light: <code>:rotating_light:</code></td></tr><tr><td>:police_car: <code>:police_car:</code></td><td>:oncoming_police_car: <code>:oncoming_police_car:</code></td><td>:fire_engine: <code>:fire_engine:</code></td></tr><tr><td>:ambulance: <code>:ambulance:</code></td><td>:minibus: <code>:minibus:</code></td><td>:truck: <code>:truck:</code></td></tr><tr><td>:train: <code>:train:</code></td><td>:station: <code>:station:</code></td><td>:train2: <code>:train2:</code></td></tr><tr><td>:bullettrain_front: <code>:bullettrain_front:</code></td><td>:bullettrain_side: <code>:bullettrain_side:</code></td><td>:light_rail: <code>:light_rail:</code></td></tr><tr><td>:monorail: <code>:monorail:</code></td><td>:railway_car: <code>:railway_car:</code></td><td>:trolleybus: <code>:trolleybus:</code></td></tr><tr><td>:ticket: <code>:ticket:</code></td><td>:fuelpump: <code>:fuelpump:</code></td><td>:vertical_traffic_light: <code>:vertical_traffic_light:</code></td></tr><tr><td>:traffic_light: <code>:traffic_light:</code></td><td>:warning: <code>:warning:</code></td><td>:construction: <code>:construction:</code></td></tr><tr><td>:beginner: <code>:beginner:</code></td><td>:atm: <code>:atm:</code></td><td>:slot_machine: <code>:slot_machine:</code></td></tr><tr><td>:busstop: <code>:busstop:</code></td><td>:barber: <code>:barber:</code></td><td>:hotsprings: <code>:hotsprings:</code></td></tr><tr><td>:checkered_flag: <code>:checkered_flag:</code></td><td>:crossed_flags: <code>:crossed_flags:</code></td><td>:izakaya_lantern: <code>:izakaya_lantern:</code></td></tr><tr><td>:moyai: <code>:moyai:</code></td><td>:circus_tent: <code>:circus_tent:</code></td><td>:performing_arts: <code>:performing_arts:</code></td></tr><tr><td>:round_pushpin: <code>:round_pushpin:</code></td><td>:triangular_flag_on_post:<code>:triangular_flag_on_post:</code></td><td>:jp: <code>:jp:</code></td></tr><tr><td>:kr: <code>:kr:</code></td><td>:cn: <code>:cn:</code></td><td>:us: <code>:us:</code></td></tr><tr><td>:fr: <code>:fr:</code></td><td>:es: <code>:es:</code></td><td>:it: <code>:it:</code></td></tr><tr><td>:ru: <code>:ru:</code></td><td>:gb: <code>:gb:</code></td><td>:uk: <code>:uk:</code></td></tr><tr><td>:de: <code>:de:</code></td><td></td><td></td></tr></tbody></table><p>Symbols</p><table><thead><tr><th>:one: <code>:one:</code></th><th>:two: <code>:two:</code></th><th>:three: <code>:three:</code></th></tr></thead><tbody><tr><td>:four: <code>:four:</code></td><td>:five: <code>:five:</code></td><td>:six: <code>:six:</code></td></tr><tr><td>:seven: <code>:seven:</code></td><td>:eight: <code>:eight:</code></td><td>:nine: <code>:nine:</code></td></tr><tr><td>:keycap_ten: <code>:keycap_ten:</code></td><td>:1234: <code>:1234:</code></td><td>:zero: <code>:zero:</code></td></tr><tr><td>:hash: <code>:hash:</code></td><td>:symbols: <code>:symbols:</code></td><td>:arrow_backward: <code>:arrow_backward:</code></td></tr><tr><td>:arrow_down: <code>:arrow_down:</code></td><td>:arrow_forward: <code>:arrow_forward:</code></td><td>:arrow_left: <code>:arrow_left:</code></td></tr><tr><td>:capital_abcd: <code>:capital_abcd:</code></td><td>:abcd: <code>:abcd:</code></td><td>:abc: <code>:abc:</code></td></tr><tr><td>:arrow_lower_left: <code>:arrow_lower_left:</code></td><td>:arrow_lower_right: <code>:arrow_lower_right:</code></td><td>:arrow_right: <code>:arrow_right:</code></td></tr><tr><td>:arrow_up: <code>:arrow_up:</code></td><td>:arrow_upper_left: <code>:arrow_upper_left:</code></td><td>:arrow_upper_right: <code>:arrow_upper_right:</code></td></tr><tr><td>:arrow_double_down: <code>:arrow_double_down:</code></td><td>:arrow_double_up: <code>:arrow_double_up:</code></td><td>:arrow_down_small: <code>:arrow_down_small:</code></td></tr><tr><td>:arrow_heading_down: <code>:arrow_heading_down:</code></td><td>:arrow_heading_up: <code>:arrow_heading_up:</code></td><td>:leftwards_arrow_with_hook:<code>:leftwards_arrow_with_hook:</code></td></tr><tr><td>:arrow_right_hook: <code>:arrow_right_hook:</code></td><td>:left_right_arrow: <code>:left_right_arrow:</code></td><td>:arrow_up_down: <code>:arrow_up_down:</code></td></tr><tr><td>:arrow_up_small: <code>:arrow_up_small:</code></td><td>:arrows_clockwise: <code>:arrows_clockwise:</code></td><td>:arrows_counterclockwise:<code>:arrows_counterclockwise:</code></td></tr><tr><td>:rewind: <code>:rewind:</code></td><td>:fast_forward: <code>:fast_forward:</code></td><td>:information_source: <code>:information_source:</code></td></tr><tr><td>:ok: <code>:ok:</code></td><td>:twisted_rightwards_arrows:<code>:twisted_rightwards_arrows:</code></td><td>:repeat: <code>:repeat:</code></td></tr><tr><td>:repeat_one: <code>:repeat_one:</code></td><td>:new: <code>:new:</code></td><td>:top: <code>:top:</code></td></tr><tr><td>:up: <code>:up:</code></td><td>:cool: <code>:cool:</code></td><td>:free: <code>:free:</code></td></tr><tr><td>:ng: <code>:ng:</code></td><td>:cinema: <code>:cinema:</code></td><td>:koko: <code>:koko:</code></td></tr><tr><td>:signal_strength: <code>:signal_strength:</code></td><td>:u5272: <code>:u5272:</code></td><td>:u5408: <code>:u5408:</code></td></tr><tr><td>:u55b6: <code>:u55b6:</code></td><td>:u6307: <code>:u6307:</code></td><td>:u6708: <code>:u6708:</code></td></tr><tr><td>:u6709: <code>:u6709:</code></td><td>:u6e80: <code>:u6e80:</code></td><td>:u7121: <code>:u7121:</code></td></tr><tr><td>:u7533: <code>:u7533:</code></td><td>:u7a7a: <code>:u7a7a:</code></td><td>:u7981: <code>:u7981:</code></td></tr><tr><td>:sa: <code>:sa:</code></td><td>:restroom: <code>:restroom:</code></td><td>:mens: <code>:mens:</code></td></tr><tr><td>:womens: <code>:womens:</code></td><td>:baby_symbol: <code>:baby_symbol:</code></td><td>:no_smoking: <code>:no_smoking:</code></td></tr><tr><td>:parking: <code>:parking:</code></td><td>:wheelchair: <code>:wheelchair:</code></td><td>:metro: <code>:metro:</code></td></tr><tr><td>:baggage_claim: <code>:baggage_claim:</code></td><td>:accept: <code>:accept:</code></td><td>:wc: <code>:wc:</code></td></tr><tr><td>:potable_water: <code>:potable_water:</code></td><td>:put_litter_in_its_place:<code>:put_litter_in_its_place:</code></td><td>:secret: <code>:secret:</code></td></tr><tr><td>:congratulations: <code>:congratulations:</code></td><td>:m: <code>:m:</code></td><td>:passport_control: <code>:passport_control:</code></td></tr><tr><td>:left_luggage: <code>:left_luggage:</code></td><td>:customs: <code>:customs:</code></td><td>:ideograph_advantage: <code>:ideograph_advantage:</code></td></tr><tr><td>:cl: <code>:cl:</code></td><td>:sos: <code>:sos:</code></td><td>:id: <code>:id:</code></td></tr><tr><td>:no_entry_sign: <code>:no_entry_sign:</code></td><td>:underage: <code>:underage:</code></td><td>:no_mobile_phones: <code>:no_mobile_phones:</code></td></tr><tr><td>:do_not_litter: <code>:do_not_litter:</code></td><td>:non-potable_water: <code>:non-potable_water:</code></td><td>:no_bicycles: <code>:no_bicycles:</code></td></tr><tr><td>:no_pedestrians: <code>:no_pedestrians:</code></td><td>:children_crossing: <code>:children_crossing:</code></td><td>:no_entry: <code>:no_entry:</code></td></tr><tr><td>:eight_spoked_asterisk: <code>:eight_spoked_asterisk:</code></td><td>:eight_pointed_black_star:<code>:eight_pointed_black_star:</code></td><td>:heart_decoration: <code>:heart_decoration:</code></td></tr><tr><td>:vs: <code>:vs:</code></td><td>:vibration_mode: <code>:vibration_mode:</code></td><td>:mobile_phone_off: <code>:mobile_phone_off:</code></td></tr><tr><td>:chart: <code>:chart:</code></td><td>:currency_exchange: <code>:currency_exchange:</code></td><td>:aries: <code>:aries:</code></td></tr><tr><td>:taurus: <code>:taurus:</code></td><td>:gemini: <code>:gemini:</code></td><td>:cancer: <code>:cancer:</code></td></tr><tr><td>:leo: <code>:leo:</code></td><td>:virgo: <code>:virgo:</code></td><td>:libra: <code>:libra:</code></td></tr><tr><td>:scorpius: <code>:scorpius:</code></td><td>:sagittarius: <code>:sagittarius:</code></td><td>:capricorn: <code>:capricorn:</code></td></tr><tr><td>:aquarius: <code>:aquarius:</code></td><td>:pisces: <code>:pisces:</code></td><td>:ophiuchus: <code>:ophiuchus:</code></td></tr><tr><td>:six_pointed_star: <code>:six_pointed_star:</code></td><td>:negative_squared_cross_mark:<code>:negative_squared_cross_mark:</code></td><td>:a: <code>:a:</code></td></tr><tr><td>:b: <code>:b:</code></td><td>:ab: <code>:ab:</code></td><td>:o2: <code>:o2:</code></td></tr><tr><td>:diamond_shape_with_a_dot_inside:<code>:diamond_shape_with_a_dot_inside:</code></td><td>:recycle: <code>:recycle:</code></td><td>:end: <code>:end:</code></td></tr><tr><td>:on: <code>:on:</code></td><td>:soon: <code>:soon:</code></td><td>:clock1: <code>:clock1:</code></td></tr><tr><td>:clock130: <code>:clock130:</code></td><td>:clock10: <code>:clock10:</code></td><td>:clock1030: <code>:clock1030:</code></td></tr><tr><td>:clock11: <code>:clock11:</code></td><td>:clock1130: <code>:clock1130:</code></td><td>:clock12: <code>:clock12:</code></td></tr><tr><td>:clock1230: <code>:clock1230:</code></td><td>:clock2: <code>:clock2:</code></td><td>:clock230: <code>:clock230:</code></td></tr><tr><td>:clock3: <code>:clock3:</code></td><td>:clock330: <code>:clock330:</code></td><td>:clock4: <code>:clock4:</code></td></tr><tr><td>:clock430: <code>:clock430:</code></td><td>:clock5: <code>:clock5:</code></td><td>:clock530: <code>:clock530:</code></td></tr><tr><td>:clock6: <code>:clock6:</code></td><td>:clock630: <code>:clock630:</code></td><td>:clock7: <code>:clock7:</code></td></tr><tr><td>:clock730: <code>:clock730:</code></td><td>:clock8: <code>:clock8:</code></td><td>:clock830: <code>:clock830:</code></td></tr><tr><td>:clock9: <code>:clock9:</code></td><td>:clock930: <code>:clock930:</code></td><td>:heavy_dollar_sign: <code>:heavy_dollar_sign:</code></td></tr><tr><td>:copyright: <code>:copyright:</code></td><td>:registered: <code>:registered:</code></td><td>:tm: <code>:tm:</code></td></tr><tr><td>:x: <code>:x:</code></td><td>:heavy_exclamation_mark: <code>:heavy_exclamation_mark:</code></td><td>:bangbang: <code>:bangbang:</code></td></tr><tr><td>:interrobang: <code>:interrobang:</code></td><td>:o: <code>:o:</code></td><td>:heavy_multiplication_x: <code>:heavy_multiplication_x:</code></td></tr><tr><td>:heavy_plus_sign: <code>:heavy_plus_sign:</code></td><td>:heavy_minus_sign: <code>:heavy_minus_sign:</code></td><td>:heavy_division_sign: <code>:heavy_division_sign:</code></td></tr><tr><td>:white_flower: <code>:white_flower:</code></td><td>:100: <code>:100:</code></td><td>:heavy_check_mark: <code>:heavy_check_mark:</code></td></tr><tr><td>:ballot_box_with_check: <code>:ballot_box_with_check:</code></td><td>:radio_button: <code>:radio_button:</code></td><td>:link: <code>:link:</code></td></tr><tr><td>:curly_loop: <code>:curly_loop:</code></td><td>:wavy_dash: <code>:wavy_dash:</code></td><td>:part_alternation_mark: <code>:part_alternation_mark:</code></td></tr><tr><td>:trident: <code>:trident:</code></td><td>:black_square: <code>:black_square:</code></td><td>:white_square: <code>:white_square:</code></td></tr><tr><td>:white_check_mark: <code>:white_check_mark:</code></td><td>:black_square_button: <code>:black_square_button:</code></td><td>:white_square_button: <code>:white_square_button:</code></td></tr><tr><td>:black_circle: <code>:black_circle:</code></td><td>:white_circle: <code>:white_circle:</code></td><td>:red_circle: <code>:red_circle:</code></td></tr><tr><td>:large_blue_circle: <code>:large_blue_circle:</code></td><td>:large_blue_diamond: <code>:large_blue_diamond:</code></td><td>:large_orange_diamond: <code>:large_orange_diamond:</code></td></tr><tr><td>:small_blue_diamond: <code>:small_blue_diamond:</code></td><td>:small_orange_diamond: <code>:small_orange_diamond:</code></td><td>:small_red_triangle: <code>:small_red_triangle:</code></td></tr><tr><td>:small_red_triangle_down:<code>:small_red_triangle_down:</code></td><td>:shipit: <code>:shipit:</code></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>其他领域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>资料</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>相对论的简单解释</title>
    <link href="/2024/10/05/2024-10-05-%E7%9B%B8%E5%AF%B9%E8%AE%BA%E7%9A%84%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A/"/>
    <url>/2024/10/05/2024-10-05-%E7%9B%B8%E5%AF%B9%E8%AE%BA%E7%9A%84%E7%AE%80%E5%8D%95%E8%A7%A3%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="相对论的简单解释">相对论的简单解释</h1><hr /><h3 id="狭义相对论">狭义相对论：</h3><ul><li><strong>核心思想：</strong>狭义相对论由爱因斯坦提出，主要研究物体在<strong>接近光速时的运动</strong>。</li><li><strong>两个主要原则：</strong><ol type="1"><li><strong>光速恒定：</strong>不论观察者如何运动，光的速度在真空中总是一样的。</li><li><strong>相对性原理：</strong>物理定律在所有的惯性参考系中都相同（无论你静止还是匀速运动）。</li></ol><strong>结果：</strong><ul><li>当物体接近光速时，时间会变慢（<strong>时间膨胀</strong>）、长度会缩短（<strong>长度收缩</strong>），而且质量会变大。</li></ul>简单来说，狭义相对论告诉我们，速度很快的物体会发生这些奇怪的现象。</li></ul><h3 id="广义相对论">广义相对论：</h3><ul><li><p><strong>核心思想：</strong>广义相对论扩展了狭义相对论，研究的是<strong>引力</strong>和<strong>时空的弯曲</strong>。</p></li><li><p><strong>主要观点：</strong>质量大的物体会<strong>弯曲时空</strong>，而引力就是物体沿着弯曲时空的路径运动的结果。</p><p><strong>结果：</strong></p><ul><li>重物（比如地球）使时空弯曲，导致物体（比如卫星）围绕它运动。</li><li>甚至光线也会被引力影响，弯曲经过质量大的天体。</li></ul></li></ul><p>简单来说，广义相对论把引力解释为时空的弯曲，而不是传统的“力”。</p><h2 id="狭义相对论解释">狭义相对论解释</h2><p>这些问题与狭义相对论的核心原理紧密相关。让我们逐一解释：</p><h3 id="为什么光速是恒定的">1.<strong>为什么光速是恒定的？</strong></h3><p>光速恒定是狭义相对论的基础假设之一，爱因斯坦在理论中指出，光速在真空中对于任何观察者来说都是不变的，不管观察者是否在运动。这个假设基于以下发现：</p><ul><li>在经典物理中，速度是相对的（如果你在一辆车上，车的速度会相对于地面不同于你在静止状态下测量的速度）。</li><li>然而，实验（如迈克尔逊-莫雷实验）显示，不管你怎么测量，光速在任何参考系下都保持不变。</li></ul><p><strong>为什么？</strong>这是因为光是一种不依赖于介质的传播波，它的速度取决于宇宙的基本常量（如电磁场的特性），而不是物体或观察者的运动。这与我们日常经验中的物体不同，因此光速恒定是相对论中的一个基本特性，属于宇宙的自然规律。</p><h3 id="物体接近光速时时间为什么会变慢时间膨胀">2.<strong>物体接近光速时，时间为什么会变慢？（时间膨胀）</strong></h3><p>根据狭义相对论，当物体的速度接近光速时，时间对于快速运动的物体会变慢。这可以通过爱因斯坦的<strong>时间膨胀</strong>公式来解释：</p><p><span class="math display">\[t&#39; = \frac{t}{\sqrt{1 - \frac{v^2}{c^2}}}\]</span> 其中： - (t') 是运动物体上的时间 - (t) 是静止参考系中的时间 -(v) 是物体的速度 - (c) 是光速</p><p><strong>为什么会这样？</strong>爱因斯坦认为时间并不是绝对的，而是相对的。时间膨胀意味着，随着物体速度越来越接近光速，时间会在不同的参考系中以不同的速度流逝。为了使光速保持不变，空间和时间都需要进行调整。因此，时间在物体接近光速时“变慢”，这是为了确保无论物体多快运动，光速对所有观察者来说都仍然是相同的。</p><h3 id="为什么长度会缩短长度收缩">3.<strong>为什么长度会缩短？（长度收缩）</strong></h3><p>当物体接近光速时，物体在运动方向上的长度会变短，这被称为<strong>长度收缩</strong>。公式为：<span class="math display">\[L = L_0 \sqrt{1 - \frac{v^2}{c^2}}\]</span> 其中： - (L) 是运动参考系中的长度 - (L_0)是静止参考系中的长度</p><p><strong>为什么会这样？</strong>长度收缩与时间膨胀类似，都是为了维持光速恒定而出现的现象。当物体以非常高的速度运动时，时空中的度量关系发生变化。运动物体的长度在运动方向上缩短，这种效应随着速度接近光速而变得越来越显著。这个收缩是观察者在静止参考系中看到的，而对于物体本身，它并没有感觉到自己的长度变化。</p><h3 id="为什么质量会变大">4. <strong>为什么质量会变大？</strong></h3><p>根据狭义相对论，当物体的速度接近光速时，它的动质量会增加。这个增加的质量通过以下公式描述：<span class="math display">\[m = \frac{m_0}{\sqrt{1 - \frac{v^2}{c^2}}}\]</span> 其中： - (m) 是物体运动时的质量 - (m_0) 是物体静止时的质量</p><p><strong>为什么会这样？</strong>质量的增加是物体接近光速时能量增加的结果。根据爱因斯坦的著名公式 (E =mc^2)，能量和质量是等价的。随着物体的速度越来越快，需要更多的能量来进一步加速它，因此它的动质量增加。实际上，这也是为什么物体不可能达到光速——因为需要无限的能量才能让质量无限大的物体达到光速。</p><h3 id="总结">总结：</h3><ul><li>光速恒定是一种自然现象，是宇宙的基本规律。</li><li>时间变慢、长度收缩和质量增大是为了确保光速在所有参考系中保持不变的结果。这些现象表明，空间和时间并不是固定的，而是随着速度的变化而相对变化。</li></ul><h2 id="广义相对论解释">广义相对论解释</h2><p>将“弯曲时空”具象化可以通过类比的方式来帮助理解。尽管时空弯曲是一个复杂的物理概念，但用一个简单的比喻可以帮助我们形成直观的印象。</p><h3 id="类比橡皮膜和重球">类比：<strong>橡皮膜和重球</strong></h3><p>想象一个<strong>弹性橡皮膜</strong>，代表<strong>二维的时空</strong>。现在，将一个<strong>重球</strong>（比如一个保龄球）放在橡皮膜的中心，橡皮膜会因为重球的重量而下陷，形成一个“凹坑”。</p><ul><li>在这个模型中，重球就像一个<strong>质量大的天体</strong>（例如地球、太阳或黑洞），它“压弯”了时空。</li><li><strong>橡皮膜的下陷</strong>就是时空被弯曲的结果。</li></ul><h3id="重球引起的凹陷代表时空的弯曲">重球引起的“凹陷”代表时空的弯曲：</h3><ul><li>如果你在这块橡皮膜上再放一个<strong>小球</strong>（比如一个弹珠），小球会沿着“凹坑”的边缘滚动，绕着重球转动。这个行为可以类比为<strong>行星围绕恒星的轨道运动</strong>。</li><li>小球并不是因为某种“力”被吸引，而是它在沿着被大质量物体弯曲的时空运动。这就是爱因斯坦的广义相对论告诉我们的：<strong>引力并不是一种“力”，而是时空的弯曲造成的效果</strong>。</li></ul><h3 id="三维时空的弯曲">三维时空的弯曲：</h3><p>在我们的日常生活中，时空是四维的（包括三维空间和一维时间），但为了简化理解，我们可以将时空的弯曲想象成橡皮膜的二维表面被“压弯”。实际上，<strong>时空的弯曲不仅仅是在空间维度上弯曲，还包括时间维度的变化</strong>。例如，靠近大质量天体（如黑洞），<strong>时间流逝得更慢</strong>，这就是所谓的<strong>引力时间膨胀</strong>。</p><h3 id="总结-1">总结：</h3><ul><li><strong>重球弯曲橡皮膜</strong>的类比帮助我们理解<strong>大质量天体弯曲时空</strong>。</li><li><strong>小球沿弯曲轨道运动</strong>类比了天体如何在弯曲时空中围绕其他天体运动（如地球绕着太阳转）。</li><li>这种弯曲并不局限于空间，还包括<strong>时间维度</strong>，影响时间的流逝。</li></ul><p>通过这个具象化的模型，我们可以理解：物体通过弯曲的时空运动，而引力只是这种时空几何变化的结果。</p><p>根据这个类比，直觉上似乎小球（行星）会最终滚入大球（恒星），但实际上在真实宇宙中并不总是这样。为了更好理解这一点，我们需要注意两个关键的因素：</p><h3 id="惯性运动与轨道稳定性">1.<strong>惯性运动与轨道稳定性：</strong></h3><p>在实际物理世界中，行星不会因为时空弯曲而直接掉进恒星。行星绕恒星运动时，它们受到的引力是由时空弯曲引起的，但行星本身也有<strong>惯性</strong>，即它们沿着某个速度方向前进。如果没有引力的作用，行星会沿着直线运动，但由于引力（时空的弯曲），它们被“牵引”到一个弯曲的轨道上。</p><p>这个轨道运动的结果是：<strong>行星不会直接坠入恒星，而是围绕恒星运行</strong>。只要行星的速度和轨道都保持适当的平衡，行星可以在很长时间内稳定地绕着恒星运转，而不会掉进去。这个过程就像你将小球沿着橡皮膜的弯曲部分快速旋转，它不会立刻滚入中央的重物，而是会沿着弯曲轨道绕圈。</p><h3 id="能量损耗的影响">2. <strong>能量损耗的影响：</strong></h3><p>尽管行星通常不会坠入恒星，但有一些特殊情况可能导致它们逐渐接近恒星。例如，在现实中，如果行星的<strong>轨道能量</strong>因为某种原因（例如大气摩擦、潮汐效应或辐射能量损耗）逐渐耗尽，它可能会慢慢向恒星靠近，并最终坠入。这种情况在一些天体系统中是可能发生的，比如人造卫星如果没有足够的速度保持轨道高度，就会逐渐坠入地球大气层。</p><p>不过，行星围绕恒星运行通常是<strong>稳定的轨道运动</strong>，只要没有外力干扰（如摩擦、碰撞或引力波耗能），行星可以长期处于稳定的轨道上。</p><h3 id="现实中的轨道运动">现实中的轨道运动：</h3><p>在广义相对论的框架下，行星沿着恒星周围的<strong>弯曲时空</strong>路径运行，这是稳定的椭圆或圆形轨道，类似经典物理中的开普勒定律解释的轨道运动。</p><p>所以，尽管类比橡皮膜的模型可能给我们直观感受小球会滚入大球，但在真实宇宙中，行星<strong>由于惯性和时空弯曲的共同作用</strong>，通常不会掉入恒星，而是在稳定的轨道上运行。</p><h3 id="总结-2">总结：</h3><ul><li>行星并不会直接坠入恒星，因为它们的<strong>惯性和引力的平衡</strong>保持了稳定的轨道。</li><li>只有在能量耗尽或受到外力的情况下，行星才可能慢慢坠入恒星。</li></ul>]]></content>
    
    
    <categories>
      
      <category>其他领域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文框架</title>
    <link href="/2024/10/05/2024-10-05-%E8%AE%BA%E6%96%87%E7%9B%AE%E5%BD%95/"/>
    <url>/2024/10/05/2024-10-05-%E8%AE%BA%E6%96%87%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="论文框架">论文框架</h2><ol type="1"><li><h3 id="封面学校统一发放">封面：学校统一发放</h3></li><li><h3 id="标题页排版要求">标题页：排版要求</h3><ul><li>标题：四号黑体，居中</li><li>副标题（仅在必要时）：以破折号引导，四号黑体，居中</li><li>作者、指导教师、完成时间：宋体小四，1.5倍行距，缩进6个中文字符</li></ul></li><li><h3 id="鸣谢">鸣谢：</h3><ul><li>鸣谢是在自己论文写作过程中，在学术思想、资料或素材、写作条件等方面提供帮助的单位或个人表达的谢意，要求客观而不夸张，语气诚恳。字数以不超过1页为限。---内容排版要求：小四宋体，首行缩进2个字符</li><li>谢辞排版要求：小四，黑体，首行居中，段后空1行</li></ul></li><li><h3 id="诚信声明">诚信声明</h3></li><li><h3 id="中文摘要">中文摘要：</h3><p>摘要是对论文内容的高度概括（而不是引言），要让读者通过摘要能了解本论文的选题意义、研究方法、基本结论和本论文的创新点。关键词：3-5 个关键词</p><ul><li>排版要求：标题为首行居中，小四黑体，段后空1行，内容小四宋体，首行缩进2字符</li><li>关键词排版要求：首行缩进2字符，小四黑体，后面3-5个关键词小四宋体，相互间用逗号隔开</li></ul></li><li><h3 id="英文摘要">英文摘要：</h3><p>中文摘要的英文翻译，格式要求同上，英文字体为<code>times new roman</code></p></li><li><h3 id="目录">目录：</h3><p>由word生成，章节从引言开始，一级标题为章，二级标题为节，三级标题用“一、二、三……..”，正文四级标题用“1,2, 3……”。目录页显示限在三级标题以内。</p><ul><li>排版要求：“目录”首行居中，三号黑体</li><li>一级标题：黑体小四，无缩进</li><li>二级标题：宋体小四，缩进2字符</li><li>三级标题：宋体小四，缩进3字符</li></ul></li><li><h3 id="正文">正文</h3><ul><li><p>引言</p></li><li><p>导论</p></li><li><p>文献回顾</p></li><li><p>分析内容</p></li><li><p>结论与展望</p></li><li><p>参考文献</p></li><li><p>附录</p></li><li><p>排版要求：</p><blockquote><p>一级标题：首行居中，黑体小三，段后空1行</p><p>二级标题：无缩进，黑体小四，段前空1行</p><p>三级标题：首行缩进2字符，宋体小四，单倍行距</p><p>正文文字：首行缩进2字符，宋体小四，单倍行距</p><p>脚注：宋体5号</p><p>图表居中</p><p>公式缩进2字符</p></blockquote></li><li><p>内容写作规范</p><ol type="1"><li><p>论文在结构上和内容上，能清楚地分为导论、文献综述、主体和结论四个部分（每一部分可根据具体内容赋予一个或更多的特定的章节标题）：</p><ul><li>导论内容：该部分应明确提出研究的问题，该问题的意义（其它诸如题目的来源）等</li><li>文献综述：现有文献对该问题的研究方法、结论以及待研究的问题。文献综述要以一定的逻辑将已有的国内外研究成果进行梳理总结，而不是简单地将所掌握的各种研究文献简单地罗列在一起。</li><li>主体内容：本部分集中体现论文作者所进行的研究分析，应明确研究该问题的切入点，限定分析的前提条件，体现由前提到结论的逻辑推导过程（即论述展开过程）；在使用数据的场合，要注明数据来源，验证方法、基本结果及对结果的经济意义解释；</li><li>结论与展望：总结论文的基本结论及政策含义。结论必须是本文主题内容分析部分的结果，政策建议（或所谓的对策）也应与此紧密相关。最后是本论文研究的局限性和未来继续研究的方向（可选择）</li></ul></li><li><p>毕业论文的核心在于用理论、数据或事实资料证明或论证某个论点。为此必须做到如下几点：</p><ul><li><p>所研究的问题（论文的主题）要清晰准确，并对研究方向、切入点做出明确限定，不能过于宽泛。</p></li><li><p>各章节在逻辑上要连贯，每章节的内容要紧扣由本章节题目限定的具体内容；</p></li><li><p>要言之有据，每一个数据、资料都必须注明出处，而不能用“据研究”、“据报道”、“据分析”等类似表述。论文中每个论点、观点的提出都要对其进行论证，不是论点或建议的堆积；每个结论都应当通过符合逻辑推理而得出，不能用主观的意愿或推测。例如：</p><blockquote><p>如果用如下表述“我认为网络营销存在很多问题”，那么，（I）你要说明你所说的“问题”为什么成为问题；（II）有什么证据表明该问题的存在。</p><p>如果文中有“政府应当增加纺织品出口退税”，那么，（I）政府为什么要增加出口退税，（II）如果说是为了保护纺织品行业，要说明为什么要对它保护等等。</p></blockquote></li><li><p>学术论文研究某一经济问题，目的是揭示经济现象背后的实质，要用论证的语言来写，而不是工作总结或类似政府工作报告中的旨在凝聚人心的口号，不能用感情的、煽动的语言，例：</p><blockquote><p>可以写“因为中美贸易差额损害了某些美国利益集团（包括美国劳工）的利益，它们会向通过各种渠道向美国政府/国会施压，迫使人民币升值以缓解来自中国的竞争压力”。但要避免诸如“美国迫使人民币升值是为了阻碍中国经济的崛起，用心极其险恶”等字样。</p></blockquote></li></ul></li><li><p>参考文献和注的规范使用：</p><ul><li><p>参考文献体现了论文作者对所研究问题阅读的深度和广度，参考文献符合引用规范是一篇合格论文的基本要求。</p><ol type="1"><li><p>正文中引用的文献与论文后面的参考文献必须一一对应，即凡正文中引用的文献在文后参考文献条目中都能找到，正文中没有引用或提到的不能放在参考文献条目中；</p></li><li><p>应参考 5 篇以上中文核心期刊（如 CSSCI索引包含的期刊）、3篇以上外文期刊（不含电子刊物的文献，如Workingpaper）上的重要文献，这里的重要文献是指在所选研究领域极具影响力、在该领域研究中引用率极高的作品[例如，查阅这方面的最新研究文献，总能（或以极高的频率）从这些文献中看到对上述定义的重要文献的引用。</p></li><li><p>文后参考文献应编号，并将中文和英文分开排列：英文文献按（第一）作者姓氏第一字母顺序排列；中文文献可以按作者姓（名）的拼音顺序或汉字笔画排列；</p></li><li><p>参考文献在包括如下内容并按下列顺序排列：作者，出版年份，文章标题，刊物名称（斜体），卷，起止页；例：</p><blockquote><p>[正文中] Hau (2000) introduces non-traded goods into theanalysis.</p><p>[参考文献中] Hau, H., 2000. Exchange rate determination: the role offactor price rigidities and non-tradables. Journal of InternationalEconomics 50, 421–448.</p></blockquote></li></ol></li><li><p>注（使用脚注）是不宜放在正文但又需要对正文提到的内容加以解释或说明（或做其它延伸解释）的内容，因此是否使用要视论文内容而定。例：</p><blockquote><p>[正文中]Second, equilibrium prices set above marginal costrationalize demand-determined output in the short run, since firms arenot losing money on the additional production1. Third, monopoly powermeans that…….</p><p>[脚注中]1，As is discussed below, this is only true if the shock isnot so large as to drive marginal costs above marginal revenues.</p></blockquote></li></ul></li></ol></li></ul></li></ol><h2 id="论文题目"><strong>论文题目</strong></h2><p>I. <strong>引言</strong></p><p>A. 研究背景和意义</p><p>B. 研究目的和意义</p><p>C. 研究范围和结构</p><ol start="2" type="I"><li><strong>文献综述</strong></li></ol><p>A. 国内外环境保护政策执行研究现状</p><p>B. 相关理论和研究框架介绍</p><ol start="3" type="I"><li><strong>研究方法</strong></li></ol><p>A. 数据收集与采样方法</p><p>B. 数据分析方法和工具</p><ol start="4" type="I"><li><strong>镇远县环境保护政策执行情况分析</strong></li></ol><p>A. 政策执行机制与协调</p><p>B. 利益相关者参与与反馈</p><p>C. 环境保护政策执行效果评估</p><p>V. <strong>问题分析与讨论</strong></p><p>A. 政策执行中的问题与挑战</p><p>B. 政府部门能力与资源投入分析</p><p>C. 政策执行对环境和社会经济的影响分析</p><ol start="6" type="I"><li><strong>结论与建议</strong></li></ol><p>A. 研究总结与归纳</p><p>B. 政策改进建议和实施建议</p><ol start="7" type="I"><li><strong>参考文献</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>其他领域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>方法论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>费曼学习法</title>
    <link href="/2024/10/05/2024-10-05-%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/"/>
    <url>/2024/10/05/2024-10-05-%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="费曼学习法">费曼学习法</h1><hr /><h3 id="选择目标领域并完全了解这个概念">1.选择目标领域，并完全了解这个概念</h3><p>​ 将需要学习的概念写在纸上，尽可能的去熟悉这个概念。</p><ul><li>一定要将自己脑海的语言组织出来并反应在书面上</li><li>如果写不出来再回去看哪里不懂</li></ul><h3 id="向别人复述这个概念">2. 向别人复述这个概念</h3><p>​向身边人复述一遍你所学习到的知识，如果没有，就只好假装自己是一个老师，向学生复述这个概念，记住，尽量使用简单的语言，这一步是为了让你更好的融入自己的理解。在复述时，一定会在所难免的会卡住，或者结巴，叙述不完整。这时候，恭喜你，喜提知识概念薄弱点。这时候，将这些薄弱点重新学习巩固一遍，直到真正理解。</p><h3 id="纠错之后的再次学习">3. 纠错之后的再次学习</h3><p>​把刚才学习的不完善的地方再次学习，回归原材料或者书本本身，直到能够流畅地阐述学习的知识点。</p><h3 id="回顾和精简">4. 回顾和精简</h3><p>​走完上述三个步骤之后，想必你们可以能够很流畅精准地将概念完整的阐述出来。而现在我们需要做的是用我们理解的语言去阐述知识概念。</p><p>​当你完成，请从头重复这整个过程。但是这一次要简化你的说法或使用图形的比喻。如果你还是一样解释的太冗长或混乱，那你可能并不太了解他，所以你必须重复的进行修饰，直到最好。</p>]]></content>
    
    
    <categories>
      
      <category>其他领域</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原理</tag>
      
      <tag>方法论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>神经网络编程</title>
    <link href="/2024/10/04/2024-10-04-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/10/04/2024-10-04-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="神经网络编程">神经网络编程</h1><h2 id="框架代码">框架代码</h2><p>神经网络类至少需要3个函数：</p><ul><li>初始化函数————设定输入层节点、隐藏层节点和输出层节点的数量、学习率、权重、激活函数</li><li>训练————学习给定训练集样本后，优化权重</li><li>查询————给定输入，从输出节点给出答案</li></ul><h2 id="权重">权重</h2><ul><li>在输入层与隐藏层之间的链接权重矩阵为<spanclass="math inline">\(W_{input-hidden}\)</span>，大小为<code>hidden_nodes乘以input_nodes</code></li><li>在隐藏层与输出层之间的链接权重矩阵为<spanclass="math inline">\(W_{hidden-output}\)</span>，大小为<code>outpu_nodes乘以hidden_nodes</code></li></ul><h2 id="查询网络">查询网络</h2><ul><li>链接权重点乘输入层就可以得到隐藏层的输入信号<spanclass="math inline">\(X_{hidden}=W_{input-hidden}\cdot I\)</span></li><li>为了获得从隐藏层节点处出现的信号，使用sigmoid激活函数<spanclass="math inline">\(O_{hidden}=sigmod(X_{hidden})\)</span>,sigmod函数：1/(1+exp(-x))；exp(-x)就是e的-x次方</li><li>同理链接权重点乘隐藏层可以得到输出层的输入信号<spanclass="math inline">\(X_{output}=W_{hidden-output}\cdot H\)</span></li><li>通过将输出层的输入信号带入激活函数得到输出层的输出信号</li></ul><h1 id="训练网络">训练网络</h1><ul><li>针对给定的训练样本计算输出</li><li>将计算得到的输出与所需的输出对比，使用差值来指导网络权重的更新</li><li>通过隐藏层节点反向传播误差<spanclass="math inline">\(error_{hidden}=W^T_{hidden-output}\cdoterror_{output}\)</span> T代表需要转置权重</li><li>更新节点j与其下一层节点k之间链接权重的矩阵表达式<spanclass="math inline">\(\DeltaW_{j,k}+=\alpha*E_k*sigmoid(O_k)*(1-sigmoid(O_k))\cdot O_j\)</span> &gt;<spanclass="math inline">\(\alpha\)</span>是学习率，sigmoid是激活函数，*是普通乘法，<spanclass="math inline">\(\cdot\)</span> 是点乘矩阵点积</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入库</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> scipy.special <span class="hljs-keyword">import</span> expit<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 神经网络类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">neuralNetwork</span>:<br>    <span class="hljs-comment"># 初始化神经网络</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, inputnodes, hiddennodes, outputnodes, learningrate</span>):<br>        <span class="hljs-comment"># 初始化输入层、隐藏层、输出层</span><br>        <span class="hljs-variable language_">self</span>.inodes = inputnodes<br>        <span class="hljs-variable language_">self</span>.hnodes = hiddennodes<br>        <span class="hljs-variable language_">self</span>.onodes = outputnodes<br>        <br>        <span class="hljs-comment"># 初始化学习率</span><br>        <span class="hljs-variable language_">self</span>.lr = learningrate<br><br>        <span class="hljs-comment"># 初始化权重参数（输入到隐藏，隐藏到输出）传播时，前面的为列，后面的为行,W表示权重</span><br>        <span class="hljs-comment"># 使用正态分布初始化权重(中心设定为0.0，与下一层节点相关用标准方差表达式，第三个参数是数组形状大小)normal(loc=0.0, scale=1.0, size=None)</span><br>        <span class="hljs-variable language_">self</span>.wih = np.random.normal(<span class="hljs-number">0.0</span>, <span class="hljs-built_in">pow</span>(<span class="hljs-variable language_">self</span>.hnodes, -<span class="hljs-number">0.5</span>),(<span class="hljs-variable language_">self</span>.hnodes, <span class="hljs-variable language_">self</span>.inodes))<br>        <span class="hljs-variable language_">self</span>.who = np.random.normal(<span class="hljs-number">0.0</span>, <span class="hljs-built_in">pow</span>(<span class="hljs-variable language_">self</span>.onodes, -<span class="hljs-number">0.5</span>),(<span class="hljs-variable language_">self</span>.onodes, <span class="hljs-variable language_">self</span>.hnodes))<br><br>        <span class="hljs-comment"># 激活函数，公式为：1 / 1 + e ** x</span><br>        <span class="hljs-variable language_">self</span>.activation_function = <span class="hljs-keyword">lambda</span> x: expit(x)<br><br>        <br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-comment"># 训练神经网络</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">self, inputs_list, targets_list</span>):<br><br>        <span class="hljs-comment"># 转置 2D 数组的行和列</span><br>        inputs = np.array(inputs_list, ndmin=<span class="hljs-number">2</span>).T<br>        targets = np.array(targets_list, ndmin=<span class="hljs-number">2</span>).T<br>        <span class="hljs-comment"># 用点乘获取隐藏层输入信号</span><br>        hidden_inputs = np.dot(<span class="hljs-variable language_">self</span>.wih, inputs)<br>        <span class="hljs-comment"># 通过激活函数获取隐藏层输出信号</span><br>        hidden_outputs = <span class="hljs-variable language_">self</span>.activation_function(hidden_inputs)<br>        <span class="hljs-comment"># 用点乘获取输出层输入信号</span><br>        final_inputs = np.dot(<span class="hljs-variable language_">self</span>.who, hidden_outputs)<br>        <span class="hljs-comment"># 用激活函数获取输出层的输出层信号</span><br>        final_outputs = <span class="hljs-variable language_">self</span>.activation_function(final_inputs)<br><br>        <span class="hljs-comment"># 反向传播--计算误差</span><br>        output_errors = targets - final_outputs<br>        <span class="hljs-comment"># 通过点乘权重获取隐藏层误差</span><br>        hidden_error = np.dot(<span class="hljs-variable language_">self</span>.who.T, output_errors)<br>        <span class="hljs-comment"># 更新输出层和隐藏层的链接权重</span><br>        <span class="hljs-variable language_">self</span>.who += <span class="hljs-variable language_">self</span>.lr * np.dot((output_errors * final_outputs * (<span class="hljs-number">1.0</span> - final_outputs)),np.transpose(hidden_outputs))<br>        <span class="hljs-comment"># 更新隐藏层和输入层的链接权重</span><br>        <span class="hljs-variable language_">self</span>.wih += <span class="hljs-variable language_">self</span>.lr * np.dot((hidden_error * hidden_outputs * (<span class="hljs-number">1.0</span> - hidden_outputs)),np.transpose(inputs))<br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-comment"># 查询神经网络</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">query</span>(<span class="hljs-params">self, inputs_list</span>):<br><br>        <span class="hljs-comment"># 转置 2D 数组的行和列</span><br>        inputs = np.array(inputs_list, ndmin=<span class="hljs-number">2</span>).T<br>        <span class="hljs-comment"># 用点乘获取隐藏层输入信号</span><br>        hidden_inputs = np.dot(<span class="hljs-variable language_">self</span>.wih, inputs)<br>        <span class="hljs-comment"># 通过激活函数获取隐藏层输出信号</span><br>        hidden_outputs = <span class="hljs-variable language_">self</span>.activation_function(hidden_inputs)<br>        <span class="hljs-comment"># 用点乘获取输出层输入信号</span><br>        final_inputs = np.dot(<span class="hljs-variable language_">self</span>.who, hidden_outputs)<br>        <span class="hljs-comment"># 用激活函数获取输出层的输出层信号</span><br>        final_outputs = <span class="hljs-variable language_">self</span>.activation_function(final_inputs)<br>        <span class="hljs-comment"># 返回最终输出</span><br>        <span class="hljs-keyword">return</span> final_outputs<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置节点和学习率</span><br>input_nodes = <span class="hljs-number">784</span><br>hidden_nodes = <span class="hljs-number">200</span><br>output_nodes = <span class="hljs-number">10</span><br>learning_rate = <span class="hljs-number">0.1</span><br><br><span class="hljs-comment"># 创建一个神经网络对象</span><br>n = neuralNetwork(input_nodes, hidden_nodes, output_nodes, learning_rate)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入训练数据</span><br>training_data_file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;../GPT神经网络学习/mnist_train.csv&quot;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)<br>training_data_list = training_data_file.readlines()<br>training_data_file.close()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练神经网络</span><br><span class="hljs-comment"># 设置训练次数，这里设置为5</span><br>epochs = <span class="hljs-number">5</span><br><span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epochs):<br>    <span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> training_data_list:<br>        <span class="hljs-comment"># 分割数据</span><br>        all_values = record.split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>        <span class="hljs-comment"># 缩放数据</span><br>        inputs = (np.asfarray(all_values[<span class="hljs-number">1</span>:]) / <span class="hljs-number">255.0</span> * <span class="hljs-number">0.99</span>) + <span class="hljs-number">0.01</span><br>        <span class="hljs-comment"># 创建训练目标</span><br>        targets = np.zeros(output_nodes) + <span class="hljs-number">0.01</span><br>        <span class="hljs-comment"># 设置训练目标，就是数据的标签数据设置为答案</span><br>        targets[<span class="hljs-built_in">int</span>(all_values[<span class="hljs-number">0</span>])] = <span class="hljs-number">0.99</span><br>        <span class="hljs-comment"># 训练数据</span><br>        n.train(inputs, targets)<br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入测试数据</span><br>test_data_file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;../GPT神经网络学习/mnist_test.csv&quot;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)<br>test_data_list = test_data_file.readlines()<br>test_data_file.close()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试神经网络</span><br><span class="hljs-comment"># 创建计分卡</span><br>scorecard = []<br><br><span class="hljs-comment"># 测试模型并计分</span><br><span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> test_data_list:<br>    <span class="hljs-comment"># 分割数据</span><br>    all_values = record.split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>    <span class="hljs-comment"># 设置列表的第一列元素为答案</span><br>    correct_label = <span class="hljs-built_in">int</span>(all_values[<span class="hljs-number">0</span>])<br>    <span class="hljs-comment"># 缩放数据</span><br>    inputs = (np.asfarray(all_values[<span class="hljs-number">1</span>:]) / <span class="hljs-number">255.0</span> * <span class="hljs-number">0.99</span>) + <span class="hljs-number">0.01</span><br>    <span class="hljs-comment"># 查询神经网络</span><br>    outputs = n.query(inputs)<br>    <span class="hljs-comment"># 筛选输出的最大值</span><br>    label = np.argmax(outputs)<br>    <span class="hljs-comment"># 添加到计分卡</span><br>    <span class="hljs-keyword">if</span> (label == correct_label):<br>        <span class="hljs-comment"># 列表最大值的下标如果等于列表第一列，那就是正确的</span><br>        scorecard.append(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># 否则就把0添加到计分卡</span><br>        scorecard.append(<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">pass</span><br>        <br>    <span class="hljs-keyword">pass</span><br>    <br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 显示计分卡分数</span><br>scorecard_array = np.asarray(scorecard)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试得分: &quot;</span>, scorecard_array.<span class="hljs-built_in">sum</span>() / scorecard_array.size)<br></code></pre></td></tr></table></figure><pre><code class="hljs">测试得分:  0.975</code></pre><h1 id="识别手写数字">识别手写数字</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打开下载的训练和测试集</span><br>training_data_file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;../GPT神经网络学习/mnist_train.csv&quot;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)<br>training_data_list = training_data_file.readlines()<br>training_data_file.close()<br></code></pre></td></tr></table></figure><p>用<code>imshow()</code>函数绘制矩形数组</p><ul><li>将由逗号分隔，长的文本字符串值，拆分成单个值，在逗号处进行分割</li><li>忽略第一个值，一般是标签，将剩余的值转换成28*28的矩阵</li><li>绘制数组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">all_values = training_data_list[<span class="hljs-number">0</span>].split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>image_array = np.asfarray(all_values[<span class="hljs-number">1</span>:]).reshape([<span class="hljs-number">28</span>,<span class="hljs-number">28</span>])<br>plt.imshow(image_array, cmap=<span class="hljs-string">&#x27;Greys&#x27;</span>,interpolation=<span class="hljs-string">&#x27;None&#x27;</span>)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;matplotlib.image.AxesImage at 0x1525b492b10&gt;</code></pre><p>​<br /><img src="/img/output_14_1.png" alt="png" /> ​</p><h2 id="准备mnist训练数据">准备MNIST训练数据</h2><ul><li>将数据的范围缩小到0.01--0.99</li><li>因为是训练识别数字，我们的输出层节点应该有10个，输入层为数据的节点784个，隐藏层不好设置，可以先默认为100个</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 缩放数据为 0.01 到 1.00之间</span><br>scaled_input = (np.asfarray(all_values[<span class="hljs-number">1</span>:]) / <span class="hljs-number">255.0</span> * <span class="hljs-number">0.99</span>) + <span class="hljs-number">0.01</span><br><span class="hljs-comment"># print(scaled_input)</span><br><br><span class="hljs-comment"># 设置输出层节点，并设置数据标签为训练目标，也就是正确答案</span><br>onodes = <span class="hljs-number">10</span><br>targets = np.zeros(onodes) + <span class="hljs-number">0.01</span><br>targets[<span class="hljs-built_in">int</span>(all_values[<span class="hljs-number">0</span>])] = <span class="hljs-number">0.99</span><br></code></pre></td></tr></table></figure><h3 id="训练神经网络">训练神经网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置节点和学习率</span><br>input_nodes = <span class="hljs-number">784</span><br>hidden_nodes = <span class="hljs-number">100</span><br>output_nodes = <span class="hljs-number">10</span><br>learning_rate = <span class="hljs-number">0.3</span><br><br><span class="hljs-comment"># 创建一个神经网络对象</span><br>n = neuralNetwork(input_nodes, hidden_nodes, output_nodes, learning_rate)<br><br><span class="hljs-comment"># 导入数据</span><br>training_data_file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;../GPT神经网络学习/mnist_train.csv&quot;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)<br>training_data_list = training_data_file.readlines()<br>training_data_file.close()<br><br><span class="hljs-comment"># 训练神经网络</span><br><span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> training_data_list:<br>    <span class="hljs-comment"># 分割数据</span><br>    all_values = record.split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>    <span class="hljs-comment"># 缩放数据</span><br>    inputs = (np.asfarray(all_values[<span class="hljs-number">1</span>:]) / <span class="hljs-number">255.0</span> * <span class="hljs-number">0.99</span>) + <span class="hljs-number">0.01</span><br>    <span class="hljs-comment"># 创建训练目标</span><br>    targets = np.zeros(output_nodes) + <span class="hljs-number">0.01</span><br>    <span class="hljs-comment"># 设置训练目标，就是数据的标签数据设置会答案</span><br>    targets[<span class="hljs-built_in">int</span>(all_values[<span class="hljs-number">0</span>])] = <span class="hljs-number">0.99</span><br>    <span class="hljs-comment"># 训练数据</span><br>    n.train(inputs, targets)<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>python</tag>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>神经元学习</title>
    <link href="/2024/10/04/2024-10-04-%E7%A5%9E%E7%BB%8F%E5%85%83%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/10/04/2024-10-04-%E7%A5%9E%E7%BB%8F%E5%85%83%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2id="第一步了解神经网络的基本概念">第一步：了解神经网络的基本概念</h2><p>:smile:矩阵点乘规则：<strong>当矩阵A的列数（column）等于矩阵B的行数（row）时，A与B可以相乘</strong></p><ul><li>2行3列 * 3行2列 = 2行2列 （取第一个矩阵的行和第二个矩阵的列）</li><li>3行2列 * 2行3列 = 3行3列 （取第一个矩阵的行和第二个矩阵的列）</li></ul><p>神经网络是一种模拟生物神经网络的计算模型，用于处理复杂的模式识别问题。它们由一系列<strong>神经元</strong>（或称节点）组成，这些神经元通过<strong>权重</strong>相连，权重是神经网络中最重要的参数之一。每个神经元接收输入信号，并应用一个<strong>激活函数</strong>来决定输出信号。</p><h4 id="关键术语">关键术语：</h4><ol type="1"><li><strong>神经元（Neuron）</strong>：基本的处理单元，接收输入并生成输出。</li><li><strong>权重（Weight）</strong>：连接神经元之间的参数，决定信号的强度。</li><li><strong>偏置（Bias）</strong>：一个神经元输出中独立于输入的项，帮助调整输出。</li><li><strong>激活函数（ActivationFunction）</strong>：用于非线性转换神经元的输出，例如Sigmoid, Tanh,ReLU。</li></ol><h4 id="一个简单的神经网络结构">一个简单的神经网络结构：</h4><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sas">输入层（<span class="hljs-keyword">Input</span> Layer） → 隐藏层（Hidden Layer） → 输出层（<span class="hljs-keyword">Output</span> Layer）<br></code></pre></td></tr></table></figure><ul><li><strong>输入层</strong>：接收输入数据。</li><li><strong>隐藏层</strong>：中间层，可以有多层，用于提取特征。</li><li><strong>输出层</strong>：输出最终的结果。</li></ul><h3 id="练习">练习：</h3><ol type="1"><li><p>请你简单描述神经网络是什么。</p></li><li><p>列出并解释神经网络的三个主要组件。</p><p>神经网络是一种模拟生物神经网络的计算模型，用于处理复杂的模式识别问题；三个主要组件是输入层、隐藏层、输出层</p></li></ol><h2id="第二步理解一个简单神经元的工作原理">第二步：理解一个简单神经元的工作原理</h2><p>一个神经元接收输入、计算加权和并应用激活函数来生成输出。让我们更详细地看一下一个简单神经元的工作过程：</p><h4 id="神经元的数学表达">神经元的数学表达：</h4><p>假设我们有一个输入 ( x )，它经过权重 ( w ) 和偏置 ( b )调整，然后通过激活函数 ( f ) 来生成输出 ( y )：</p><p>$ y = f(w x + b) $</p><p>其中： - ( x ) 是输入。 - ( w ) 是权重。 - ( b ) 是偏置。 - ( f )是激活函数（例如：Sigmoid、ReLU 等）。</p><h4 id="常见激活函数">常见激活函数：</h4><ol type="1"><li><p><strong>Sigmoid 函数</strong>：将输入映射到 (0) 和 (1) 之间。 $(x) = $</p></li><li><p><strong>ReLU 函数</strong>：将负数部分映射为 (0)，正数部分不变。$ (x) = (0, x) $</p></li></ol><h4 id="练习-1">练习：</h4><ol type="1"><li>假设你有一个输入 ( x = 2 )，权重 ( w = 0.5 )，偏置 ( b = 1)，并且使用 Sigmoid 激活函数。计算输出 ( y )。</li><li>为什么激活函数是必要的？</li></ol><p>输入 x=2，权重 w=0.5，偏置 b=1，计算输出 y。</p><p>计算步骤如下：</p><ul><li>首先，计算加权和及偏置： <spanclass="math inline">\(w⋅x+b=0.5⋅2+1=1+1=2\)</span></li><li>然后，计算 Sigmoid 函数的值： <span class="math inline">\(\sigma(2)= \frac{1}{1 + e^{-2}} \approx 0.88\)</span></li></ul><p>因此，输出$ y≈0.88$</p><h4 id="为什么激活函数是必要的">为什么激活函数是必要的？</h4><p>激活函数引入了非线性，使得神经网络能够学习和表示复杂的模式。如果没有激活函数，网络只会进行线性变换（输入的加权求和），这无法有效地处理复杂的模式或决策问题。</p><h2 id="第三步构建一个简单的神经元">第三步：构建一个简单的神经元</h2><p>接下来，我们将把刚才学到的知识应用于构建一个简单的神经元，并用 Python代码来实现它。</p><h4 id="构建步骤">构建步骤：</h4><ol type="1"><li><strong>定义神经元的结构</strong>：包括输入、权重、偏置和激活函数。</li><li><strong>实现加权和及偏置</strong>：计算 <spanclass="math inline">\(( w \cdot x + b )\)</span>。</li><li><strong>应用激活函数</strong>：使用 Sigmoid 函数来计算输出。</li></ol><h3 id="python-代码实现">Python 代码实现</h3><p>以下是一个简单神经元的 Python 实现，包括输入、权重、偏置和 Sigmoid激活函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><br><span class="hljs-comment"># 定义 Sigmoid 激活函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sigmoid</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + math.exp(-x))<br><br><span class="hljs-comment"># 输入、权重和偏置</span><br>x = <span class="hljs-number">2</span>            <span class="hljs-comment"># 输入</span><br>w = <span class="hljs-number">0.5</span>          <span class="hljs-comment"># 权重</span><br>b = <span class="hljs-number">1</span>            <span class="hljs-comment"># 偏置</span><br><br><span class="hljs-comment"># 计算加权和及偏置</span><br>z = w * x + b<br><br><span class="hljs-comment"># 应用 Sigmoid 激活函数</span><br>y = sigmoid(z)<br><br><span class="hljs-comment"># 输出结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;输出 y = <span class="hljs-subst">&#123;y&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="代码解释">代码解释：</h4><ol type="1"><li>定义了一个 <code>sigmoid</code> 函数来计算 Sigmoid激活函数的值。</li><li>设置了输入 ( x )、权重 ( w ) 和偏置 ( b )。</li><li>计算了加权和及偏置 ( z )。</li><li>使用 <code>sigmoid</code> 函数计算输出 ( y )。</li><li>打印输出结果。</li></ol><h3 id="练习-2">练习：</h3><ol type="1"><li>请在你的 Python 环境中运行上述代码，观察输出。</li><li>尝试修改输入 ( x )、权重 ( w ) 和偏置 ( b )的值，观察输出是如何变化的。</li></ol><h2id="第四步构建一个简单的神经网络">第四步：构建一个简单的神经网络</h2><p>我们将构建一个包含输入层、一个隐藏层和输出层的简单神经网络。这个神经网络将接受两个输入，经过一个隐藏层处理后，生成一个输出。</p><h4 id="神经网络结构">神经网络结构：</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入层 <span class="hljs-comment">(2 个输入)</span> → 隐藏层 <span class="hljs-comment">(2 个神经元)</span> → 输出层 <span class="hljs-comment">(1 个输出)</span><br></code></pre></td></tr></table></figure><h3 id="具体步骤">具体步骤：</h3><ol type="1"><li><strong>初始化输入、权重和偏置</strong>。</li><li><strong>计算隐藏层的输出</strong>。</li><li><strong>计算输出层的输出</strong>。</li></ol><h3 id="python-代码实现-1">Python 代码实现</h3><p>以下代码展示了如何构建和运行这个简单的神经网络：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 定义 Sigmoid 激活函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sigmoid</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + np.exp(-x))<br><br><span class="hljs-comment"># 输入</span><br>inputs = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])  <span class="hljs-comment"># 2 个输入</span><br><br><span class="hljs-comment"># 权重和偏置</span><br><span class="hljs-comment"># 隐藏层 (2 个神经元，每个神经元有 2 个输入)</span><br>hidden_weights = np.array([[<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.6</span>], <br>                           [<span class="hljs-number">0.1</span>, <span class="hljs-number">0.8</span>]])  <span class="hljs-comment"># 权重矩阵 2x2</span><br>hidden_bias = np.array([<span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>])      <span class="hljs-comment"># 偏置向量</span><br><br><span class="hljs-comment"># 输出层 (1 个神经元，2 个输入)</span><br>output_weights = np.array([<span class="hljs-number">0.4</span>, -<span class="hljs-number">0.7</span>])  <span class="hljs-comment"># 权重向量</span><br>output_bias = <span class="hljs-number">0.1</span>                       <span class="hljs-comment"># 偏置</span><br><br><span class="hljs-comment"># 计算隐藏层的输出</span><br>hidden_input = np.dot(hidden_weights, inputs) + hidden_bias<br>hidden_output = sigmoid(hidden_input)<br><br><span class="hljs-comment"># 计算输出层的输出</span><br>output_input = np.dot(output_weights, hidden_output) + output_bias<br>output = sigmoid(output_input)<br><br><span class="hljs-comment"># 输出结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;隐藏层输出: <span class="hljs-subst">&#123;hidden_output&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最终输出: <span class="hljs-subst">&#123;output&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="代码解释-1">代码解释：</h4><ol type="1"><li><strong>定义 Sigmoid 激活函数</strong>：使用 <code>numpy</code> 的<code>exp</code> 函数处理数组。</li><li><strong>初始化输入</strong>：<code>inputs</code> 是一个包含 2个输入的数组。</li><li><strong>初始化隐藏层的权重和偏置</strong>：<code>hidden_weights</code>是 2x2 的权重矩阵，<code>hidden_bias</code> 是包含 2 个偏置的数组。</li><li><strong>初始化输出层的权重和偏置</strong>：<code>output_weights</code>是 1x2 的权重向量，<code>output_bias</code> 是一个单一的偏置值。</li><li><strong>计算隐藏层的输出</strong>：使用 <code>np.dot</code>计算权重和输入的点积，加上偏置，再通过 <code>sigmoid</code>函数处理。</li><li><strong>计算输出层的输出</strong>：类似地，使用隐藏层的输出计算输出层的最终输出。</li></ol><h3 id="练习-3">练习：</h3><ol type="1"><li>请在你的 Python 环境中运行上述代码，并观察输出结果。</li><li>尝试修改输入、隐藏层和输出层的权重和偏置，观察输出是如何变化的。</li></ol><h2id="第五步理解神经网络的训练过程">第五步：理解神经网络的训练过程</h2><p>神经网络的训练主要包括两个阶段：<strong>前向传播（ForwardPropagation）</strong> 和<strong>反向传播（Backpropagation）</strong>。我们来逐步理解这两个过程。</p><h4 id="前向传播forward-propagation">1. 前向传播（ForwardPropagation）</h4><p>前向传播是将输入数据通过神经网络，计算出预测的输出。</p><p><strong>步骤</strong>：</p><ol type="1"><li>输入数据通过输入层传递到隐藏层。</li><li>隐藏层的输出传递到输出层。</li><li>输出层生成最终的预测输出。</li></ol><h4 id="损失函数loss-function">2. 损失函数（Loss Function）</h4><p>损失函数用于衡量预测输出与真实值之间的差距。一个常见的损失函数是<strong>均方误差（MeanSquared Error, MSE）</strong>：</p><p>$ = _{i=1}^N ( - y_i)^2 $</p><p>其中： - $ N $是样本数量。 - $ $是预测值。 - <spanclass="math inline">\(y_i\)</span> 是真实值。</p><h4 id="反向传播backpropagation">3. 反向传播（Backpropagation）</h4><p>反向传播用于调整神经网络中的权重和偏置，以最小化损失函数的值。它基于梯度下降算法，通过计算损失函数相对于每个权重和偏置的偏导数来更新它们。</p><p><strong>步骤</strong>： 1. 计算损失函数的梯度。 2.反向传播这些梯度，通过链式法则调整每一层的权重和偏置。</p><h3 id="python-代码实现简化版">Python 代码实现（简化版）</h3><p>我们将实现一个简单的神经网络训练过程，使用一个输入样本进行训练。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 定义激活函数及其导数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sigmoid</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + np.exp(-x))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sigmoid_derivative</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x * (<span class="hljs-number">1</span> - x)<br><br><span class="hljs-comment"># 输入数据和真实输出</span><br>inputs = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br>true_output = np.array([<span class="hljs-number">0.8</span>])<br><br><span class="hljs-comment"># 初始化权重和偏置</span><br>hidden_weights = np.array([[<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.6</span>], <br>                           [<span class="hljs-number">0.1</span>, <span class="hljs-number">0.8</span>]])<br>hidden_bias = np.array([<span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>])<br><br>output_weights = np.array([[<span class="hljs-number">0.4</span>, -<span class="hljs-number">0.7</span>]])<br>output_bias = <span class="hljs-number">0.1</span><br><br><span class="hljs-comment"># 学习率</span><br>learning_rate = <span class="hljs-number">0.5</span><br><br><span class="hljs-comment"># 前向传播</span><br>hidden_input = np.dot(hidden_weights, inputs) + hidden_bias<br>hidden_output = sigmoid(hidden_input)<br><br>output_input = np.dot(output_weights, hidden_output) + output_bias<br>predicted_output = sigmoid(output_input)<br><br><span class="hljs-comment"># 计算损失（均方误差）</span><br>loss = np.mean((true_output - predicted_output) ** <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 反向传播</span><br><span class="hljs-comment"># 输出层误差</span><br>output_error = true_output - predicted_output<br>output_delta = output_error * sigmoid_derivative(predicted_output)<br><br><span class="hljs-comment"># 隐藏层误差</span><br>hidden_error = output_delta.dot(output_weights)<br>hidden_delta = hidden_error * sigmoid_derivative(hidden_output)<br><br><span class="hljs-comment"># 更新权重和偏置</span><br>output_weights += learning_rate * output_delta * hidden_output<br>output_bias += learning_rate * output_delta<br><br>hidden_weights += learning_rate * np.outer(hidden_delta, inputs)<br>hidden_bias += learning_rate * hidden_delta<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;预测输出: <span class="hljs-subst">&#123;predicted_output&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;损失: <span class="hljs-subst">&#123;loss&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;更新后的权重和偏置: <span class="hljs-subst">&#123;output_weights&#125;</span>, <span class="hljs-subst">&#123;output_bias&#125;</span>, <span class="hljs-subst">&#123;hidden_weights&#125;</span>, <span class="hljs-subst">&#123;hidden_bias&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="代码解释-2">代码解释：</h4><ol type="1"><li><strong>定义激活函数及其导数</strong>：<code>sigmoid</code> 及<code>sigmoid_derivative</code>。</li><li><strong>初始化输入和真实输出</strong>：<code>inputs</code> 和<code>true_output</code>。</li><li><strong>初始化权重和偏置</strong>：<code>hidden_weights</code>、<code>hidden_bias</code>、<code>output_weights</code>和 <code>output_bias</code>。</li><li><strong>设置学习率</strong>。</li><li><strong>前向传播</strong>：计算隐藏层和输出层的输出。</li><li><strong>计算损失</strong>：使用均方误差。</li><li><strong>反向传播</strong>：计算输出层和隐藏层的误差及更新量。</li><li><strong>更新权重和偏置</strong>。</li></ol><h3 id="练习-4">练习：</h3><ol type="1"><li>在你的 Python 环境中运行上述代码，观察输出和权重更新。</li><li>尝试修改输入、真实输出、权重和偏置的初始值，观察训练过程中的变化。</li></ol><h2 id="第六步扩展神经网络">第六步：扩展神经网络</h2><p>我们将扩展神经网络，增加更多的隐藏层和神经元，以处理更复杂的数据。然后，我们会使用批量梯度下降和其他优化技巧。</p><h4 id="批量梯度下降batch-gradient-descent">批量梯度下降（Batch GradientDescent）</h4><p>批量梯度下降是训练神经网络的一个重要方法，它在整个训练数据集上计算损失并更新权重。这种方法有助于稳定训练过程。</p><h4 id="扩展网络的步骤">扩展网络的步骤：</h4><ol type="1"><li><strong>增加更多的隐藏层</strong>：可以通过增加更多的隐藏层和神经元来提高网络的表现力。</li><li><strong>引入更多激活函数</strong>：比如ReLU，可以处理更复杂的非线性关系。</li><li><strong>使用批量梯度下降</strong>：在整个训练集上计算损失并更新权重。</li></ol><h3 id="python-代码实现扩展版">Python 代码实现（扩展版）</h3><p>以下代码展示了一个包含更多隐藏层的神经网络，并使用批量梯度下降来训练：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 定义激活函数及其导数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sigmoid</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + np.exp(-x))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sigmoid_derivative</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x * (<span class="hljs-number">1</span> - x)<br><br><span class="hljs-comment"># 数据集（简单示例）</span><br>inputs = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.3</span>], [<span class="hljs-number">0.2</span>, <span class="hljs-number">0.8</span>]])<br>true_outputs = np.array([[<span class="hljs-number">0.8</span>], [<span class="hljs-number">0.4</span>], [<span class="hljs-number">0.6</span>]])<br><br><span class="hljs-comment"># 初始化权重和偏置</span><br>input_size = <span class="hljs-number">2</span><br>hidden_size1 = <span class="hljs-number">3</span><br>hidden_size2 = <span class="hljs-number">2</span><br>output_size = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 隐藏层 1</span><br>hidden_weights1 = np.random.rand(hidden_size1, input_size)<br>hidden_bias1 = np.random.rand(hidden_size1)<br><br><span class="hljs-comment"># 隐藏层 2</span><br>hidden_weights2 = np.random.rand(hidden_size2, hidden_size1)<br>hidden_bias2 = np.random.rand(hidden_size2)<br><br><span class="hljs-comment"># 输出层</span><br>output_weights = np.random.rand(output_size, hidden_size2)<br>output_bias = np.random.rand(output_size)<br><br><span class="hljs-comment"># 学习率</span><br>learning_rate = <span class="hljs-number">0.5</span><br><br><span class="hljs-comment"># 训练过程</span><br>epochs = <span class="hljs-number">10000</span><br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epochs):<br>    <span class="hljs-comment"># 前向传播</span><br>    hidden_input1 = np.dot(inputs, hidden_weights1.T) + hidden_bias1<br>    hidden_output1 = sigmoid(hidden_input1)<br><br>    hidden_input2 = np.dot(hidden_output1, hidden_weights2.T) + hidden_bias2<br>    hidden_output2 = sigmoid(hidden_input2)<br><br>    output_input = np.dot(hidden_output2, output_weights.T) + output_bias<br>    predicted_output = sigmoid(output_input)<br><br>    <span class="hljs-comment"># 计算损失</span><br>    loss = np.mean((true_outputs - predicted_output) ** <span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment"># 反向传播</span><br>    <span class="hljs-comment"># 输出层误差</span><br>    output_error = true_outputs - predicted_output<br>    output_delta = output_error * sigmoid_derivative(predicted_output)<br><br>    <span class="hljs-comment"># 隐藏层 2 误差</span><br>    hidden_error2 = np.dot(output_delta, output_weights)<br>    hidden_delta2 = hidden_error2 * sigmoid_derivative(hidden_output2)<br><br>    <span class="hljs-comment"># 隐藏层 1 误差</span><br>    hidden_error1 = np.dot(hidden_delta2, hidden_weights2)<br>    hidden_delta1 = hidden_error1 * sigmoid_derivative(hidden_output1)<br><br>    <span class="hljs-comment"># 更新权重和偏置</span><br>    output_weights += learning_rate * np.dot(output_delta.T, hidden_output2)<br>    output_bias += learning_rate * np.mean(output_delta, axis=<span class="hljs-number">0</span>)<br><br>    hidden_weights2 += learning_rate * np.dot(hidden_delta2.T, hidden_output1)<br>    hidden_bias2 += learning_rate * np.mean(hidden_delta2, axis=<span class="hljs-number">0</span>)<br><br>    hidden_weights1 += learning_rate * np.dot(hidden_delta1.T, inputs)<br>    hidden_bias1 += learning_rate * np.mean(hidden_delta1, axis=<span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment"># 打印损失</span><br>    <span class="hljs-keyword">if</span> epoch % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Epoch <span class="hljs-subst">&#123;epoch&#125;</span>, Loss: <span class="hljs-subst">&#123;loss&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 最终预测输出</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最终预测输出: <span class="hljs-subst">&#123;predicted_output&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="代码解释-3">代码解释：</h4><ol type="1"><li><strong>扩展数据集</strong>：使用多个样本。</li><li><strong>增加隐藏层</strong>：增加一个额外的隐藏层<code>hidden_layer2</code>。</li><li><strong>批量梯度下降</strong>：在每个 epoch 中更新权重和偏置。</li><li><strong>输出预测结果</strong>：打印损失并显示最终预测输出。</li></ol><h3 id="练习-5">练习：</h3><ol type="1"><li>请在你的 Python 环境中运行上述代码，并观察输出结果。</li><li>尝试调整网络结构（如增加神经元数量或隐藏层），观察对训练过程的影响。</li><li>了解批量大小（batch size）和 epoch 数对训练的影响。</li></ol><h3 id="常见问题">常见问题：</h3><ol type="1"><li><strong>如何避免过拟合？</strong><ul><li>使用正则化技术（如 L2 正则化）。</li><li>使用 Dropout 技术。</li><li>增加数据集。</li></ul></li><li><strong>如何选择学习率？</strong><ul><li>学习率过高会导致训练不稳定，过低会导致训练过慢。可以使用学习率调度器逐步调整。</li></ul></li></ol><h3 id="true-outputs-超过-1-的情况">True Outputs 超过 1 的情况</h3><h4 id="使用-sigmoid-作为输出层激活函数">1. 使用 Sigmoid作为输出层激活函数</h4><p><strong>Sigmoid 函数</strong>的输出范围是 0 到 1。如果<code>true_outputs</code> 超过 1，会导致以下问题：</p><ul><li><strong>不匹配的输出范围</strong>：Sigmoid 函数的输出永远不会超过1，因此 <code>true_outputs</code> 超过 1会导致较大的误差，可能影响训练效果。</li><li><strong>损失函数计算问题</strong>：如果使用均方误差 (MSE)作为损失函数，过大的误差会导致梯度过大，可能使训练不稳定。</li></ul><h4 id="解决方法">解决方法：</h4><ul><li><strong>归一化输出</strong>：将 <code>true_outputs</code> 归一化到 0到 1 范围内，使之与 Sigmoid 函数的输出匹配。</li><li><strong>使用不同的激活函数</strong>：如果输出不应该被限制在 0 到 1范围，可以考虑其他激活函数，如线性激活函数（即没有激活函数）。</li></ul><h3 id="修改代码以处理-true-outputs-超过-1">修改代码以处理 True Outputs超过 1</h3><h4 id="方法-1归一化-true-outputs">方法 1：归一化 True Outputs</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设你的 true_outputs 原始范围是 0 到 10</span><br>true_outputs = np.array([[<span class="hljs-number">8</span>], [<span class="hljs-number">4</span>], [<span class="hljs-number">6</span>]])<br><br><span class="hljs-comment"># 归一化 true_outputs 到 0 到 1</span><br>true_outputs = true_outputs / <span class="hljs-number">10.0</span><br></code></pre></td></tr></table></figure><h4 id="方法-2使用线性激活函数">方法 2：使用线性激活函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 线性激活函数及其导数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_derivative</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 修改代码中 sigmoid 函数部分为线性函数</span><br>hidden_output2 = sigmoid(hidden_input2)  <span class="hljs-comment"># 隐藏层仍然使用 Sigmoid</span><br>output_input = np.dot(hidden_output2, output_weights.T) + output_bias<br>predicted_output = linear(output_input)  <span class="hljs-comment"># 输出层使用线性函数</span><br><br><span class="hljs-comment"># 反向传播</span><br>output_error = true_outputs - predicted_output<br>output_delta = output_error * linear_derivative(predicted_output)<br></code></pre></td></tr></table></figure><h3id="示例代码使用线性激活函数的完整示例">示例代码：使用线性激活函数的完整示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 定义激活函数及其导数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sigmoid</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + np.exp(-x))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sigmoid_derivative</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x * (<span class="hljs-number">1</span> - x)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> x<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_derivative</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 数据集（简单示例）</span><br>inputs = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.3</span>], [<span class="hljs-number">0.2</span>, <span class="hljs-number">0.8</span>]])<br>true_outputs = np.array([[<span class="hljs-number">8</span>], [<span class="hljs-number">4</span>], [<span class="hljs-number">6</span>]])<br><br><span class="hljs-comment"># 初始化权重和偏置</span><br>input_size = <span class="hljs-number">2</span><br>hidden_size1 = <span class="hljs-number">3</span><br>hidden_size2 = <span class="hljs-number">2</span><br>output_size = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 隐藏层 1</span><br>hidden_weights1 = np.random.rand(hidden_size1, input_size)<br>hidden_bias1 = np.random.rand(hidden_size1)<br><br><span class="hljs-comment"># 隐藏层 2</span><br>hidden_weights2 = np.random.rand(hidden_size2, hidden_size1)<br>hidden_bias2 = np.random.rand(hidden_size2)<br><br><span class="hljs-comment"># 输出层</span><br>output_weights = np.random.rand(output_size, hidden_size2)<br>output_bias = np.random.rand(output_size)<br><br><span class="hljs-comment"># 学习率</span><br>learning_rate = <span class="hljs-number">0.5</span><br><br><span class="hljs-comment"># 训练过程</span><br>epochs = <span class="hljs-number">10000</span><br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epochs):<br>    <span class="hljs-comment"># 前向传播</span><br>    hidden_input1 = np.dot(inputs, hidden_weights1.T) + hidden_bias1<br>    hidden_output1 = sigmoid(hidden_input1)<br><br>    hidden_input2 = np.dot(hidden_output1, hidden_weights2.T) + hidden_bias2<br>    hidden_output2 = sigmoid(hidden_input2)<br><br>    output_input = np.dot(hidden_output2, output_weights.T) + output_bias<br>    predicted_output = linear(output_input)  <span class="hljs-comment"># 输出层使用线性函数</span><br><br>    <span class="hljs-comment"># 计算损失</span><br>    loss = np.mean((true_outputs - predicted_output) ** <span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment"># 反向传播</span><br>    <span class="hljs-comment"># 输出层误差</span><br>    output_error = true_outputs - predicted_output<br>    output_delta = output_error * linear_derivative(predicted_output)<br><br>    <span class="hljs-comment"># 隐藏层 2 误差</span><br>    hidden_error2 = np.dot(output_delta, output_weights)<br>    hidden_delta2 = hidden_error2 * sigmoid_derivative(hidden_output2)<br><br>    <span class="hljs-comment"># 隐藏层 1 误差</span><br>    hidden_error1 = np.dot(hidden_delta2, hidden_weights2)<br>    hidden_delta1 = hidden_error1 * sigmoid_derivative(hidden_output1)<br><br>    <span class="hljs-comment"># 更新权重和偏置</span><br>    output_weights += learning_rate * np.dot(output_delta.T, hidden_output2)<br>    output_bias += learning_rate * np.mean(output_delta, axis=<span class="hljs-number">0</span>)<br><br>    hidden_weights2 += learning_rate * np.dot(hidden_delta2.T, hidden_output1)<br>    hidden_bias2 += learning_rate * np.mean(hidden_delta2, axis=<span class="hljs-number">0</span>)<br><br>    hidden_weights1 += learning_rate * np.dot(hidden_delta1.T, inputs)<br>    hidden_bias1 += learning_rate * np.mean(hidden_delta1, axis=<span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment"># 打印损失</span><br>    <span class="hljs-keyword">if</span> epoch % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Epoch <span class="hljs-subst">&#123;epoch&#125;</span>, Loss: <span class="hljs-subst">&#123;loss&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 最终预测输出</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;最终预测输出: <span class="hljs-subst">&#123;predicted_output&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="总结">总结</h3><ul><li><strong>归一化 <code>true_outputs</code></strong>是一种简单的处理方法，可以让你的网络输出与 <code>true_outputs</code>匹配。</li><li><strong>使用线性激活函数</strong> 可以适应范围超过 0-1 的<code>true_outputs</code>，适合于回归问题等情况。</li></ul><p>你可以根据需要选择合适的处理方法，或者结合两者，确保网络输出与目标范围匹配。如果有进一步的问题或需要更多解释，请随时告知！</p><h2 id="各类神经网络在投资中的应用">各类神经网络在投资中的应用</h2><p>在投资领域，神经网络和深度学习技术有许多应用，主要用于数据分析、市场预测、交易策略的自动化等。以下是各类神经网络在投资中的具体应用及适用情况：</p><ol type="1"><li><strong>高级优化算法</strong><ul><li><strong>应用场景</strong>：优化交易策略、调优模型参数。</li><li><strong>适用情况</strong>：适用于需要精确控制模型训练过程的场景，如量化交易策略优化。</li></ul></li><li><strong>深度学习框架</strong><ul><li><strong>应用场景</strong>：快速构建和部署复杂的模型，如股票价格预测、投资组合优化。</li><li><strong>适用情况</strong>：适用于需要构建大规模深度学习模型的任务。</li></ul></li><li><strong>卷积神经网络（CNN）</strong><ul><li><strong>应用场景</strong>：分析金融市场中的图像数据，如股票走势图、财经新闻图片。</li><li><strong>适用情况</strong>：适用于从图像数据中提取信息，例如技术图表分析，但在投资中应用较少，除非涉及图像或图表识别。</li></ul></li><li><strong>递归神经网络（RNN）</strong><ul><li><strong>应用场景</strong>：时间序列预测，如股票价格走势预测、经济指标分析。</li><li><strong>适用情况</strong>：非常适合处理金融时间序列数据，能捕捉长期依赖关系。LSTM和 GRU 是常用的变体。</li></ul></li><li><strong>正则化技术</strong><ul><li><strong>应用场景</strong>：防止模型在训练数据上过拟合，提高模型的泛化能力。</li><li><strong>适用情况</strong>：适用于所有神经网络模型，以提高其稳定性和性能。</li></ul></li><li><strong>超参数调优</strong><ul><li><strong>应用场景</strong>：自动寻找最佳模型参数组合，如调优学习率、层数、神经元数量。</li><li><strong>适用情况</strong>：适用于需要自动化调优过程的场景。</li></ul></li><li><strong>迁移学习</strong><ul><li><strong>应用场景</strong>：利用预训练模型在金融数据上微调，如利用新闻分类模型来分析财经新闻对市场的影响。</li><li><strong>适用情况</strong>：适用于有相关预训练模型且新任务数据有限的情况。</li></ul></li><li><strong>生成对抗网络（GAN）</strong><ul><li><strong>应用场景</strong>：生成虚拟的市场数据用于模拟或测试交易策略。</li><li><strong>适用情况</strong>：适用于生成新的数据集或增强数据集，但在金融领域应用较少。</li></ul></li></ol><h3 id="最适合投资的神经网络类型">最适合投资的神经网络类型</h3><p><strong>递归神经网络（RNN）</strong>及其变体（如 LSTM 和GRU）是投资领域最常用的神经网络类型，特别适合时间序列预测。这类模型能够处理过去的金融数据并预测未来的市场行为。</p><p><strong>深度学习框架</strong>（如 TensorFlow 和PyTorch）能够帮助你快速构建和部署这些复杂的模型。此外，结合<strong>高级优化算法</strong>和<strong>正则化技术</strong>，可以进一步提高模型的性能和稳定性。</p><h3 id="实现步骤">实现步骤</h3><h4 id="使用-rnnlstm-进行股票价格预测">使用 RNN/LSTM进行股票价格预测</h4><ol type="1"><li><strong>数据准备</strong><ul><li>收集并预处理时间序列数据，如股票价格、交易量等。</li><li>常见数据源包括 Yahoo Finance、Alpha Vantage 等。</li></ul></li><li><strong>模型构建</strong><ul><li>构建 RNN 或 LSTM 模型，设定输入层、隐藏层和输出层。</li><li>定义损失函数（如 MSE）和优化算法（如 Adam）。</li></ul></li><li><strong>模型训练</strong><ul><li>使用历史数据训练模型，使用批量梯度下降优化模型参数。</li><li>可以设置多次迭代（epochs）和适当的学习率。</li></ul></li><li><strong>模型评估</strong><ul><li>在测试数据集上评估模型性能，使用指标如 RMSE、MAE 等。</li></ul></li><li><strong>预测和应用</strong><ul><li>使用训练好的模型进行未来价格预测，结合投资策略进行应用。</li></ul></li></ol><h3 id="代码示例">代码示例</h3><p>以下是使用 LSTM 进行股票价格预测的简化示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> MinMaxScaler<br><br><span class="hljs-comment"># 读取数据</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_stock_data</span>(<span class="hljs-params">file_path</span>):<br>    data = pd.read_csv(file_path, parse_dates=[<span class="hljs-string">&#x27;Date&#x27;</span>], index_col=<span class="hljs-string">&#x27;Date&#x27;</span>)<br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-comment"># 特征工程：计算技术指标</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_technical_indicators</span>(<span class="hljs-params">data</span>):<br>    data[<span class="hljs-string">&#x27;SMA&#x27;</span>] = data[<span class="hljs-string">&#x27;close&#x27;</span>].rolling(window=<span class="hljs-number">10</span>).mean()<br>    data[<span class="hljs-string">&#x27;EMA&#x27;</span>] = data[<span class="hljs-string">&#x27;close&#x27;</span>].ewm(span=<span class="hljs-number">10</span>, adjust=<span class="hljs-literal">False</span>).mean()<br><br>    delta = data[<span class="hljs-string">&#x27;close&#x27;</span>].diff()<br>    gain = (delta.where(delta &gt; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)).rolling(window=<span class="hljs-number">14</span>).mean()<br>    loss = (-delta.where(delta &lt; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)).rolling(window=<span class="hljs-number">14</span>).mean()<br>    rs = gain / loss<br>    data[<span class="hljs-string">&#x27;RSI&#x27;</span>] = <span class="hljs-number">100</span> - (<span class="hljs-number">100</span> / (<span class="hljs-number">1</span> + rs))<br><br>    data[<span class="hljs-string">&#x27;Bollinger Upper&#x27;</span>] = data[<span class="hljs-string">&#x27;SMA&#x27;</span>] + <span class="hljs-number">2</span> * \<br>        data[<span class="hljs-string">&#x27;close&#x27;</span>].rolling(window=<span class="hljs-number">20</span>).std()<br>    data[<span class="hljs-string">&#x27;Bollinger Lower&#x27;</span>] = data[<span class="hljs-string">&#x27;SMA&#x27;</span>] - <span class="hljs-number">2</span> * \<br>        data[<span class="hljs-string">&#x27;close&#x27;</span>].rolling(window=<span class="hljs-number">20</span>).std()<br><br>    data = data.dropna()  <span class="hljs-comment"># 去除 NaN 值</span><br>    <span class="hljs-keyword">return</span> data<br><br><span class="hljs-comment"># 数据预处理：标准化</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">preprocess_data</span>(<span class="hljs-params">data</span>):<br>    scaler = MinMaxScaler(feature_range=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>    scaled_data = scaler.fit_transform(data)<br>    <span class="hljs-keyword">return</span> scaled_data, scaler<br><br><span class="hljs-comment"># 创建数据集</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_dataset</span>(<span class="hljs-params">data, seq_length</span>):<br>    X, y = [], []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data) - seq_length - <span class="hljs-number">1</span>):<br>        X.append(data[i:(i + seq_length)])<br>        y.append(data[i + seq_length, <span class="hljs-number">3</span>])  <span class="hljs-comment"># 预测 &#x27;Close&#x27; 价格</span><br>    <span class="hljs-keyword">return</span> np.array(X), np.array(y)<br><br><span class="hljs-comment"># LSTM 单元实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LSTMCell</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_size, hidden_size</span>):<br>        <span class="hljs-variable language_">self</span>.input_size = input_size<br>        <span class="hljs-variable language_">self</span>.hidden_size = hidden_size<br>        <span class="hljs-variable language_">self</span>.Wf = np.random.randn(hidden_size, input_size + hidden_size) * <span class="hljs-number">0.01</span><br>        <span class="hljs-variable language_">self</span>.Wi = np.random.randn(hidden_size, input_size + hidden_size) * <span class="hljs-number">0.01</span><br>        <span class="hljs-variable language_">self</span>.Wc = np.random.randn(hidden_size, input_size + hidden_size) * <span class="hljs-number">0.01</span><br>        <span class="hljs-variable language_">self</span>.Wo = np.random.randn(hidden_size, input_size + hidden_size) * <span class="hljs-number">0.01</span><br>        <span class="hljs-variable language_">self</span>.bf = np.zeros((hidden_size, <span class="hljs-number">1</span>))<br>        <span class="hljs-variable language_">self</span>.bi = np.zeros((hidden_size, <span class="hljs-number">1</span>))<br>        <span class="hljs-variable language_">self</span>.bc = np.zeros((hidden_size, <span class="hljs-number">1</span>))<br>        <span class="hljs-variable language_">self</span>.bo = np.zeros((hidden_size, <span class="hljs-number">1</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x, h_prev, c_prev</span>):<br>        combined = np.concatenate((x, h_prev), axis=<span class="hljs-number">0</span>)<br><br>        ft = sigmoid(np.dot(<span class="hljs-variable language_">self</span>.Wf, combined) + <span class="hljs-variable language_">self</span>.bf)<br>        it = sigmoid(np.dot(<span class="hljs-variable language_">self</span>.Wi, combined) + <span class="hljs-variable language_">self</span>.bi)<br>        c_hat = np.tanh(np.dot(<span class="hljs-variable language_">self</span>.Wc, combined) + <span class="hljs-variable language_">self</span>.bc)<br>        c = ft * c_prev + it * c_hat<br>        ot = sigmoid(np.dot(<span class="hljs-variable language_">self</span>.Wo, combined) + <span class="hljs-variable language_">self</span>.bo)<br>        h = ot * np.tanh(c)<br><br>        <span class="hljs-keyword">return</span> h, c<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sigmoid</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + np.exp(-x))<br><br><span class="hljs-comment"># 训练 LSTM</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_lstm</span>(<span class="hljs-params">X, y, hidden_size, epochs, learning_rate</span>):<br>    input_size = X.shape[<span class="hljs-number">2</span>]<br>    lstm_cell = LSTMCell(input_size, hidden_size)<br>    W_out = np.random.randn(<span class="hljs-number">1</span>, hidden_size) * <span class="hljs-number">0.01</span><br>    b_out = np.zeros((<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epochs):<br>        total_loss = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(X.shape[<span class="hljs-number">0</span>]):<br>            h_prev = np.zeros((hidden_size, <span class="hljs-number">1</span>))<br>            c_prev = np.zeros((hidden_size, <span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(X.shape[<span class="hljs-number">1</span>]):<br>                x_t = X[i, t, :].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>                h_prev, c_prev = lstm_cell.forward(x_t, h_prev, c_prev)<br><br>            y_hat = np.dot(W_out, h_prev) + b_out<br>            loss = np.mean((y_hat - y[i]) ** <span class="hljs-number">2</span>)<br>            total_loss += loss<br><br>            <span class="hljs-comment"># 反向传播</span><br>            dW_out = (y_hat - y[i]) * h_prev.T<br>            db_out = (y_hat - y[i])<br><br>            <span class="hljs-comment"># dh_prev = np.dot(W_out.T, (y_hat - y[i]))</span><br><br>            W_out -= learning_rate * dW_out<br>            b_out -= learning_rate * db_out<br><br>        <span class="hljs-keyword">if</span> epoch % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Epoch <span class="hljs-subst">&#123;epoch&#125;</span>, Loss: <span class="hljs-subst">&#123;total_loss / X.shape[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 返回训练好的模型参数</span><br>    <span class="hljs-keyword">return</span> lstm_cell, W_out, b_out<br><br><span class="hljs-comment"># 测试 LSTM</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_lstm</span>(<span class="hljs-params">X, lstm_cell, W_out, b_out</span>):<br>    h_prev = np.zeros((lstm_cell.hidden_size, <span class="hljs-number">1</span>))<br>    c_prev = np.zeros((lstm_cell.hidden_size, <span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(X.shape[<span class="hljs-number">1</span>]):<br>        x_t = X[t, :].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        h_prev, c_prev = lstm_cell.forward(x_t, h_prev, c_prev)<br>    y_hat = np.dot(W_out, h_prev) + b_out<br>    <span class="hljs-keyword">return</span> y_hat<br><br><br><span class="hljs-comment"># 主流程</span><br>file_path = <span class="hljs-string">&#x27;data_600519.csv&#x27;</span><br>data = load_stock_data(file_path)<br>data = calculate_technical_indicators(data)<br>scaled_data, scaler = preprocess_data(<br>    data[[<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-string">&#x27;high&#x27;</span>, <span class="hljs-string">&#x27;low&#x27;</span>, <span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-string">&#x27;volume&#x27;</span>, <span class="hljs-string">&#x27;SMA&#x27;</span>, <span class="hljs-string">&#x27;EMA&#x27;</span>, <span class="hljs-string">&#x27;RSI&#x27;</span>, <span class="hljs-string">&#x27;Bollinger Upper&#x27;</span>, <span class="hljs-string">&#x27;Bollinger Lower&#x27;</span>]])<br>seq_length = <span class="hljs-number">10</span><br>X, y = create_dataset(scaled_data, seq_length)<br><br><span class="hljs-comment"># 训练 LSTM</span><br>hidden_size = <span class="hljs-number">10</span><br>epochs = <span class="hljs-number">500</span><br>learning_rate = <span class="hljs-number">0.5</span><br>lstm_cell, W_out, b_out = train_lstm(X, y, hidden_size, epochs, learning_rate)<br><br><span class="hljs-comment"># 预测</span><br>X_test, y_test = create_dataset(scaled_data[-<span class="hljs-number">20</span>:], seq_length)<br>predicted = [predict_lstm(X_test[i], lstm_cell, W_out, b_out)<br>             <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(X_test))]<br>predicted = np.array(predicted).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment"># 扩展预测值</span><br>num_features = scaled_data.shape[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 原始数据的特征数量</span><br>predicted_full = np.zeros((predicted.shape[<span class="hljs-number">0</span>], num_features))<br>predicted_full[:, <span class="hljs-number">3</span>] = predicted[:, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 假设 &#x27;Close&#x27; 是第 4 列（索引 3） </span><br><span class="hljs-comment"># 进行逆变换</span><br>original_predicted_full = scaler.inverse_transform(predicted_full)<br>original_predicted = original_predicted_full[:, <span class="hljs-number">3</span>]  <span class="hljs-comment"># 提取 &#x27;Close&#x27; 列</span><br>pingjun = np.mean(original_predicted)<br><br><span class="hljs-comment"># 输出结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;预测结果: <span class="hljs-subst">&#123;original_predicted&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;预测结果(平均值): <span class="hljs-subst">&#123;pingjun&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="总结-1">总结</h3><ul><li><strong>RNN/LSTM</strong>非常适合处理时间序列数据，用于投资领域的市场预测和策略制定。</li><li>你可以结合<strong>深度学习框架</strong>和<strong>高级优化算法</strong>来提高模型的性能和效率。</li><li>结合投资实际需求选择合适的模型和方法，逐步构建和优化你的投资策略。</li></ul><h3 id="代码逐行解释">代码逐行解释：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> MinMaxScaler<br><span class="hljs-comment"># 读取数据</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_stock_data</span>(<span class="hljs-params">file_path</span>):<br>    data = pd.read_csv(file_path, parse_dates=[<span class="hljs-string">&#x27;Date&#x27;</span>], index_col=<span class="hljs-string">&#x27;Date&#x27;</span>)<br>    <span class="hljs-keyword">return</span> data<br></code></pre></td></tr></table></figure><p>这段代码定义了一个名为 <code>load_stock_data</code>的函数，用于加载和预处理股票数据。该函数接收一个参数<code>file_path</code>，即包含股票数据的CSV文件的路径。下面是逐行解释：</p><ol type="1"><li><p><code>import numpy as np</code>：这行代码导入了NumPy库，并将其简称为<code>np</code>。NumPy是Python中用于科学计算的一个基础库，提供了大量的数学函数操作以及高性能的多维数组对象。然而，在这段代码中，NumPy库实际上没有被直接使用，可能是为了其他部分的代码（未在此展示）准备的。</p></li><li><p><code>import pandas as pd</code>：这行代码导入了Pandas库，并将其简称为<code>pd</code>。Pandas是Python中用于数据分析的一个强大库，提供了易于使用的数据结构和数据分析工具。这段代码主要使用了Pandas来处理CSV格式的股票数据。</p></li><li><p><code>from sklearn.preprocessing import MinMaxScaler</code>：这行代码从scikit-learn（一个流行的Python机器学习库）的预处理模块中导入了<code>MinMaxScaler</code>类。<code>MinMaxScaler</code>用于将特征缩放到给定的最小值和最大值之间（通常是0和1），这是数据预处理中常用的一种技术，可以帮助改善许多机器学习算法的性能。然而，在这段特定的代码中，<code>MinMaxScaler</code>没有被直接使用，可能是为了后续的数据处理步骤预留的。</p></li><li><p>定义<code>load_stock_data</code>函数：</p><ul><li><code>def load_stock_data(file_path):</code>：定义了一个名为<code>load_stock_data</code>的函数，它接受一个参数<code>file_path</code>，即包含股票数据的CSV文件的路径。</li></ul></li><li><p>加载和预处理数据：</p><ul><li><code>data = pd.read_csv(file_path, parse_dates=['Date'], index_col='Date')</code>：使用Pandas的<code>read_csv</code>函数加载CSV文件。<code>parse_dates=['Date']</code>参数告诉Pandas将<code>Date</code>列解析为日期时间类型。<code>index_col='Date'</code>参数指定将<code>Date</code>列用作DataFrame的行索引。这意味着加载后的DataFrame将使用日期时间作为索引，而不是默认的整数索引。</li></ul></li><li><p>返回处理后的数据：</p><ul><li><code>return data</code>：函数返回处理后的DataFrame，其中包含了按日期时间索引的股票数据。</li></ul></li></ol><p>综上所述，这段代码的主要作用是加载一个包含股票数据的CSV文件，将<code>Date</code>列解析为日期时间类型，并将其作为行索引，然后返回这个处理后的DataFrame。虽然<code>MinMaxScaler</code>被导入了，但在这段代码中并没有直接使用，可能是为了后续的数据标准化步骤准备的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 特征工程：计算技术指标</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_technical_indicators</span>(<span class="hljs-params">data</span>):<br>    data[<span class="hljs-string">&#x27;SMA&#x27;</span>] = data[<span class="hljs-string">&#x27;close&#x27;</span>].rolling(window=<span class="hljs-number">10</span>).mean()<br>    data[<span class="hljs-string">&#x27;EMA&#x27;</span>] = data[<span class="hljs-string">&#x27;close&#x27;</span>].ewm(span=<span class="hljs-number">10</span>, adjust=<span class="hljs-literal">False</span>).mean()<br><br>    delta = data[<span class="hljs-string">&#x27;close&#x27;</span>].diff()<br>    gain = (delta.where(delta &gt; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)).rolling(window=<span class="hljs-number">14</span>).mean()<br>    loss = (-delta.where(delta &lt; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)).rolling(window=<span class="hljs-number">14</span>).mean()<br>    rs = gain / loss<br>    data[<span class="hljs-string">&#x27;RSI&#x27;</span>] = <span class="hljs-number">100</span> - (<span class="hljs-number">100</span> / (<span class="hljs-number">1</span> + rs))<br><br>    data[<span class="hljs-string">&#x27;Bollinger Upper&#x27;</span>] = data[<span class="hljs-string">&#x27;SMA&#x27;</span>] + <span class="hljs-number">2</span> * \<br>        data[<span class="hljs-string">&#x27;close&#x27;</span>].rolling(window=<span class="hljs-number">20</span>).std()<br>    data[<span class="hljs-string">&#x27;Bollinger Lower&#x27;</span>] = data[<span class="hljs-string">&#x27;SMA&#x27;</span>] - <span class="hljs-number">2</span> * \<br>        data[<span class="hljs-string">&#x27;close&#x27;</span>].rolling(window=<span class="hljs-number">20</span>).std()<br><br>    data = data.dropna()  <span class="hljs-comment"># 去除 NaN 值</span><br>    <span class="hljs-keyword">return</span> data<br></code></pre></td></tr></table></figure><p>这段代码定义了一个名为 <code>calculate_technical_indicators</code>的函数，它接受一个包含股票价格数据的<code>DataFrame</code>（假设至少包含 <code>close</code>列，即收盘价）作为输入，并计算并添加几个常见的技术指标到该<code>DataFrame</code> 中，最后返回更新后的<code>DataFrame</code>。这些技术指标包括简单移动平均（SMA）、指数移动平均（EMA）、相对强弱指数（RSI）和布林带（BollingerBands）。下面是对每个步骤的详细解释：</p><ol type="1"><li><strong>简单移动平均（SMA）</strong>：<ul><li>使用 <code>rolling(window=10).mean()</code>计算过去10天的收盘价的平均值，结果存储在 <code>data['SMA']</code>中。</li></ul></li><li><strong>指数移动平均（EMA）</strong>：<ul><li>使用 <code>ewm(span=10, adjust=False).mean()</code>计算指数移动平均。这里的 <code>span=10</code>大致相当于传统的平滑系数（alpha）的倒数，但 <code>ewm</code> 方法通过<code>span</code> 参数自动计算平滑系数。<code>adjust=False</code>表示不使用调整因子（即不将EMA的初始值设为第一个值）。结果存储在<code>data['EMA']</code> 中。</li></ul></li><li><strong>相对强弱指数（RSI）</strong>：<ul><li>首先计算收盘价的差异（<code>delta</code>），即当天的收盘价与前一天的收盘价之差。</li><li>然后分别计算过去14天内所有上涨日（<code>gain</code>）和下跌日（<code>loss</code>）的平均值。上涨日定义为<code>delta &gt; 0</code> 的日子，下跌日定义为 <code>delta &lt; 0</code>的日子。注意，这里使用了 <code>where</code>方法来将非上涨/下跌日的值设为0，以便计算平均值。</li><li>计算RS（相对强弱），即上涨平均除以下跌平均。</li><li>最后，使用RS值计算RSI（相对强弱指数），公式为<code>100 - (100 / (1 + rs))</code>。结果存储在 <code>data['RSI']</code>中。</li></ul></li><li><strong>布林带（Bollinger Bands）</strong>：<ul><li>计算过去20天的收盘价的标准差（<code>std()</code>），并以此为基础计算布林带的上限和下限。</li><li>布林带上限是简单移动平均（SMA）加上两倍的标准差，存储在<code>data['Bollinger Upper']</code> 中。</li><li>布林带下限是简单移动平均（SMA）减去两倍的标准差，存储在<code>data['Bollinger Lower']</code> 中。</li></ul></li><li><strong>去除 NaN 值</strong>：<ul><li>使用 <code>dropna()</code>方法去除所有包含NaN值的行。这是必要的，因为计算移动平均、标准差等统计量时，在数据集的开始部分会产生NaN值。</li></ul></li><li><strong>返回更新后的 DataFrame</strong>：<ul><li>函数返回更新后包含新计算的技术指标的 <code>DataFrame</code>。</li></ul></li></ol><p>这个函数是金融数据分析中常用的一个工具，可以帮助投资者和分析师更好地理解股票价格的动态和趋势。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数据预处理：标准化</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">preprocess_data</span>(<span class="hljs-params">data</span>):<br>    scaler = MinMaxScaler(feature_range=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>    scaled_data = scaler.fit_transform(data)<br>    <span class="hljs-keyword">return</span> scaled_data, scaler<br></code></pre></td></tr></table></figure><p>这个函数 <code>preprocess_data</code> 的目的是对给定的数据集<code>data</code> 进行预处理，具体来说是进行特征缩放（FeatureScaling），将数据的特征值缩放到一个指定的范围内，这里使用的是 0 到 1的范围。这种预处理步骤对于许多机器学习算法来说是非常重要的，因为它可以帮助改善算法的收敛速度和性能。</p><p>让我们逐行解释这个函数：</p><ol type="1"><li><p><code>scaler = MinMaxScaler(feature_range=(0, 1))</code></p><p>这行代码创建了一个 <code>MinMaxScaler</code> 对象，它是从<code>sklearn.preprocessing</code>模块中导入的。<code>MinMaxScaler</code>将数据缩放到给定的最小值和最大值之间（这里是 0 和1）。默认情况下，<code>MinMaxScaler</code> 会将数据缩放到 [0,1]，但通过设置 <code>feature_range</code>参数，我们可以自定义这个范围。在这个例子中，我们显式地指定了<code>feature_range=(0, 1)</code>，尽管这是默认值。</p></li><li><p><code>scaled_data = scaler.fit_transform(data)</code></p><p>这行代码执行了两个步骤：首先，<code>fit</code>方法计算了数据的最小值和最大值，这是进行缩放所必需的；然后，<code>transform</code>方法使用这些计算出的最小值和最大值将原始数据 <code>data</code>缩放到指定的范围内（即 0 到 1）。这两个步骤通过<code>fit_transform</code>方法合并为一个步骤，以提高效率。<code>scaled_data</code>变量现在包含了缩放后的数据。</p></li><li><p><code>return scaled_data, scaler</code></p><p>最后，函数返回两个值：缩放后的数据 <code>scaled_data</code> 和<code>MinMaxScaler</code> 对象 <code>scaler</code>。返回<code>scaler</code>对象可能很有用，因为它允许我们在未来的数据点（比如测试集或新数据）上使用相同的缩放参数进行缩放，以确保数据的一致性和可比性。</p></li></ol><p>总的来说，这个函数是一个用于数据预处理的实用工具，它通过特征缩放将数据集的特征值缩放到0 到 1 的范围内，并返回缩放后的数据以及用于缩放的<code>MinMaxScaler</code> 对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建数据集</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_dataset</span>(<span class="hljs-params">data, seq_length</span>):<br>    X, y = [], []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data) - seq_length - <span class="hljs-number">1</span>):<br>        X.append(data[i:(i + seq_length)])<br>        y.append(data[i + seq_length, <span class="hljs-number">3</span>])  <span class="hljs-comment"># 预测 &#x27;Close&#x27; 价格</span><br>    <span class="hljs-keyword">return</span> np.array(X), np.array(y)<br></code></pre></td></tr></table></figure><p>这个函数 <code>create_dataset</code> 的目的是从给定的数据<code>data</code>中创建一个用于监督学习（特别是时间序列预测）的数据集。它接收两个参数：<code>data</code>和 <code>seq_length</code>。<code>data</code>是一个多维数组，其中包含了时间序列数据；<code>seq_length</code>是一个整数，指定了每个输入序列的长度。函数返回两个数组：<code>X</code>和 <code>y</code>，其中 <code>X</code> 包含输入序列，<code>y</code>包含每个输入序列对应的目标值（即下一个时间步的某个特定特征值）。</p><p>不过，需要注意的是，函数中存在一个潜在的错误或不一致之处，这取决于<code>data</code>的具体结构。下面是对函数行为的详细解释和潜在问题的说明：</p><ol type="1"><li><p><strong>初始化 X 和 y</strong>：函数开始时，通过空列表<code>X</code> 和 <code>y</code> 来存储输入序列和目标值。</p></li><li><p><strong>循环遍历数据</strong>：函数通过一个循环遍历<code>data</code>，从索引 <code>i</code> 开始，直到<code>len(data) - seq_length - 1</code>。这是因为我们需要有足够的后续数据来作为目标值（即<code>y</code>），同时保持每个输入序列的长度为<code>seq_length</code>。</p></li><li><p><strong>构建输入序列 X</strong>：在每次循环中，通过<code>data[i:(i + seq_length)]</code> 从 <code>data</code>中切取一个长度为 <code>seq_length</code> 的序列，并将其添加到<code>X</code> 列表中。</p></li><li><p><strong>构建目标值 y</strong>：这里有一个潜在的问题。代码<code>y.append(data[i + seq_length, 3])</code> 试图从<code>data[i + seq_length]</code> 中获取第四个元素（索引为 3，因为索引从0 开始）。但是，这假设 <code>data</code>是一个二维数组，并且每一行都至少有四个元素。如果 <code>data</code>是一维数组或每行的元素数量少于四个，这将导致错误。此外，如果<code>data</code> 是三维或更高维的，这种索引方式也是不正确的。</p></li><li><p><strong>返回结果</strong>：最后，函数将 <code>X</code> 和<code>y</code> 列表转换为 NumPy 数组并返回它们。</p></li></ol><p><strong>修正建议</strong>：</p><ul><li><p>如果 <code>data</code>是一维时间序列数据，并且你想要预测的是序列中下一个时间步的某个特定值（但不一定是第四个值），你应该首先确认这一点，并在代码中明确这一点。例如，如果你想要预测的是下一个时间步的值，那么你可以将<code>y.append(data[i + seq_length])</code> 改为<code>y.append(data[i + seq_length])</code>（但这会假设你预测的是整个序列的下一个值，而不是某个特定特征）。</p></li><li><p>如果 <code>data</code>是二维或多维的，并且你确实想要获取每个序列的下一个时间步的第四个元素作为目标值，你需要确保<code>data</code> 的形状和结构符合这种索引方式。</p></li><li><p>如果 <code>data</code>的形状和结构不确定，你可能需要添加一些检查来验证这些假设，或者在文档中清楚地说明函数的使用条件和要求。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># LSTM 单元实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LSTMCell</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_size, hidden_size</span>):<br>        <span class="hljs-variable language_">self</span>.input_size = input_size<br>        <span class="hljs-variable language_">self</span>.hidden_size = hidden_size<br>        <span class="hljs-variable language_">self</span>.Wf = np.random.randn(hidden_size, input_size + hidden_size) * <span class="hljs-number">0.01</span><br>        <span class="hljs-variable language_">self</span>.Wi = np.random.randn(hidden_size, input_size + hidden_size) * <span class="hljs-number">0.01</span><br>        <span class="hljs-variable language_">self</span>.Wc = np.random.randn(hidden_size, input_size + hidden_size) * <span class="hljs-number">0.01</span><br>        <span class="hljs-variable language_">self</span>.Wo = np.random.randn(hidden_size, input_size + hidden_size) * <span class="hljs-number">0.01</span><br>        <span class="hljs-variable language_">self</span>.bf = np.zeros((hidden_size, <span class="hljs-number">1</span>))<br>        <span class="hljs-variable language_">self</span>.bi = np.zeros((hidden_size, <span class="hljs-number">1</span>))<br>        <span class="hljs-variable language_">self</span>.bc = np.zeros((hidden_size, <span class="hljs-number">1</span>))<br>        <span class="hljs-variable language_">self</span>.bo = np.zeros((hidden_size, <span class="hljs-number">1</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x, h_prev, c_prev</span>):<br>        <span class="hljs-comment"># # 假设 x 和 h_prev 都是一维数组，转换为二维以便拼接</span><br>        <span class="hljs-comment"># x = x.reshape(-1, 1)</span><br>        <span class="hljs-comment"># h_prev = h_prev.reshape(-1, 1)</span><br>        combined = np.concatenate((x, h_prev), axis=<span class="hljs-number">0</span>)<br><br>        ft = sigmoid(np.dot(<span class="hljs-variable language_">self</span>.Wf, combined) + <span class="hljs-variable language_">self</span>.bf)<br>        it = sigmoid(np.dot(<span class="hljs-variable language_">self</span>.Wi, combined) + <span class="hljs-variable language_">self</span>.bi)<br>        c_hat = np.tanh(np.dot(<span class="hljs-variable language_">self</span>.Wc, combined) + <span class="hljs-variable language_">self</span>.bc)<br>        c = ft * c_prev + it * c_hat<br>        ot = sigmoid(np.dot(<span class="hljs-variable language_">self</span>.Wo, combined) + <span class="hljs-variable language_">self</span>.bo)<br>        h = ot * np.tanh(c)<br><br>        <span class="hljs-keyword">return</span> h, c<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sigmoid</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + np.exp(-x))<br></code></pre></td></tr></table></figure><p>您提供的 <code>LSTMCell</code> 类实现了一个基本的 LSTM (长短期记忆)单元的前向传播过程。LSTM 是一种特殊的 RNN (循环神经网络)单元，它通过引入“门”机制（遗忘门、输入门、输出门）来解决传统 RNN在处理长序列时容易出现的梯度消失或梯度爆炸问题。下面是对您实现的详细解释和可能需要注意的地方：</p><h4 id="初始化">初始化</h4><p>在 <code>__init__</code> 方法中，您为 LSTM单元的权重和偏置项进行了随机初始化，并将它们乘以一个小的系数（这里是0.01）来减少初始化时的随机性对训练的影响。这是深度学习中的常见做法，称为权重初始化。</p><h4 id="前向传播">前向传播</h4><p>在 <code>forward</code> 方法中，您实现了 LSTM的前向传播过程，这包括计算遗忘门 <code>ft</code>、输入门<code>it</code>、候选单元状态 <code>c_hat</code>、更新后的单元状态<code>c</code> 和输出门 <code>ot</code>，最后输出隐藏状态<code>h</code>。</p><h4 id="注意事项">注意事项</h4><ol type="1"><li><p><strong>维度匹配</strong>：在<code>np.concatenate((x, h_prev), axis=0)</code>中，您沿着第一个轴（axis=0）拼接了输入 <code>x</code> 和前一个隐藏状态<code>h_prev</code>。然而，在 LSTM 中，通常 <code>x</code> 和<code>h_prev</code> 的维度应该是 <code>(input_size,)</code> 和<code>(hidden_size,)</code>，并且它们应该沿着特征维度（即第二维，axis=1）进行拼接。因此，正确的拼接方式应该是<code>np.concatenate((x.reshape(-1, 1), h_prev.reshape(-1, 1)), axis=1)</code>，但更常见的是直接使用<code>np.hstack((x, h_prev))</code> 或者假设 <code>x</code> 和<code>h_prev</code> 已经是二维的，并直接拼接<code>np.concatenate((x, h_prev), axis=1)</code>。</p></li><li><p><strong>广播机制</strong>：在<code>ft * c_prev + it * c_hat</code> 和 <code>ot * np.tanh(c)</code>中，NumPy的广播机制会自动处理不同形状的数组相乘。但是，为了避免潜在的维度问题，确保<code>ft</code>, <code>it</code>, <code>c_prev</code>,<code>c_hat</code>, <code>ot</code>, 和 <code>c</code>的形状符合预期是很重要的。</p></li><li><p><strong>性能优化</strong>：虽然您的实现是教育和研究目的的好例子，但在实际应用中，使用专门的深度学习库（如TensorFlow 或 PyTorch）会更高效，因为这些库经过优化，可以在 GPU上并行处理，并提供自动微分等功能。</p></li></ol><h4 id="示例修正">示例修正</h4><p>假设 <code>x</code> 和 <code>h_prev</code>都是一维数组（或需要被转换为二维数组以便拼接），这里是一个简化的修正版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x, h_prev, c_prev</span>):<br>    <span class="hljs-comment"># 假设 x 和 h_prev 都是一维数组，转换为二维以便拼接</span><br>    x = x.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    h_prev = h_prev.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    combined = np.hstack((x, h_prev))<br><br>    <span class="hljs-comment"># ...（接下来的计算保持不变）</span><br><br>    <span class="hljs-keyword">return</span> h, c<br></code></pre></td></tr></table></figure><p>注意，这里假设 <code>x</code> 和 <code>h_prev</code>都是标量或一维数组，并通过 <code>.reshape(-1, 1)</code>转换为二维数组，然后使用 <code>np.hstack</code>沿着第二个轴（特征轴）进行拼接。如果它们已经是二维的，则可以直接使用<code>np.concatenate</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练 LSTM</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_lstm</span>(<span class="hljs-params">X, y, hidden_size, epochs, learning_rate</span>):<br>    input_size = X.shape[<span class="hljs-number">2</span>]<br>    lstm_cell = LSTMCell(input_size, hidden_size)<br>    W_out = np.random.randn(<span class="hljs-number">1</span>, hidden_size) * <span class="hljs-number">0.01</span><br>    b_out = np.zeros((<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epochs):<br>        total_loss = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(X.shape[<span class="hljs-number">0</span>]):<br>            h_prev = np.zeros((hidden_size, <span class="hljs-number">1</span>))<br>            c_prev = np.zeros((hidden_size, <span class="hljs-number">1</span>))<br>            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(X.shape[<span class="hljs-number">1</span>]):<br>                x_t = X[i, t, :].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>                h_prev, c_prev = lstm_cell.forward(x_t, h_prev, c_prev)<br><br>            y_hat = np.dot(W_out, h_prev) + b_out<br>            loss = np.mean((y_hat - y[i]) ** <span class="hljs-number">2</span>)<br>            total_loss += loss<br><br>            <span class="hljs-comment"># 反向传播</span><br>            dW_out = (y_hat - y[i]) * h_prev.T<br>            db_out = (y_hat - y[i])<br><br>            <span class="hljs-comment"># dh_prev = np.dot(W_out.T, (y_hat - y[i]))</span><br><br>            W_out -= learning_rate * dW_out<br>            b_out -= learning_rate * db_out<br><br>        <span class="hljs-keyword">if</span> epoch % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Epoch <span class="hljs-subst">&#123;epoch&#125;</span>, Loss: <span class="hljs-subst">&#123;total_loss / X.shape[<span class="hljs-number">0</span>]&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 返回训练好的模型参数</span><br>    <span class="hljs-keyword">return</span> lstm_cell, W_out, b_out<br></code></pre></td></tr></table></figure><p>您提供的 <code>train_lstm</code> 函数实现了使用单个 LSTM单元进行序列数据训练的基本框架，但是有几个关键的问题和遗漏点需要注意和修正：</p><ol type="1"><li><p><strong>反向传播不完整</strong>：您的代码只实现了输出层的权重和偏置的更新，但没有实现 LSTM单元内部权重（<code>Wf</code>, <code>Wi</code>, <code>Wc</code>,<code>Wo</code> 和对应的偏置 <code>bf</code>, <code>bi</code>,<code>bc</code>, <code>bo</code>）的更新。这意味着 LSTM单元的参数在训练过程中保持不变，这显然是不正确的。</p></li><li><p><strong>损失函数和梯度计算</strong>：您的损失函数是均方误差（MSE），这是合理的。但是，梯度计算<code>dW_out</code> 和 <code>db_out</code>的方式在批量处理时可能不够准确，因为它们只考虑了最后一个时间步的隐藏状态。在序列预测中，通常需要考虑整个序列的损失。</p></li><li><p><strong>LSTM 单元内部更新</strong>： 为了更新 LSTM单元内部的权重，您需要实现 LSTM 的反向传播算法（也称为通过时间反向传播BPTT）。这涉及到计算每个时间步的误差项，并将它们反向传播回 LSTM单元以更新权重。</p></li><li><p><strong>学习率和优化器</strong>：您使用了简单的梯度下降（SGD）来更新参数，这是可行的，但在实际应用中，更复杂的优化器（如Adam、RMSprop 等）可能更有效。</p></li><li><p><strong>序列长度和批量处理</strong>：您的代码目前是按单个序列进行训练的，没有实现批量处理。在实际应用中，为了提高效率，通常会同时处理多个序列。</p></li></ol><p>由于实现 LSTM的完整反向传播算法相当复杂，这里不会给出完整的代码，但我可以提供一些指导思路：</p><ul><li><strong>实现 LSTM的反向传播</strong>：您需要计算每个时间步的误差项，并将其反向传播回 LSTM单元。这涉及到计算关于遗忘门、输入门、候选单元状态和输出门的梯度。</li><li><strong>更新 LSTM 权重</strong>：使用反向传播得到的梯度来更新 LSTM单元的权重和偏置。</li><li><strong>考虑序列和批量处理</strong>：在循环中同时迭代多个序列和每个序列的多个时间步。</li></ul><p>如果您正在学习 LSTM 并希望逐步构建理解，我建议从更简单的 RNN单元开始，并逐步增加复杂性，直到您能够处理 LSTM。同时，使用像 TensorFlow或 PyTorch这样的深度学习框架可以大大简化这些过程，因为它们已经为您处理了大部分底层细节。</p><p>对于您当前的项目，如果您只是想快速了解 LSTM的基本工作原理，并且不打算深入实现其反向传播算法，您可以使用这些框架来构建和训练LSTM 模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试 LSTM</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_lstm</span>(<span class="hljs-params">X, lstm_cell, W_out, b_out</span>):<br>    h_prev = np.zeros((lstm_cell.hidden_size, <span class="hljs-number">1</span>))<br>    c_prev = np.zeros((lstm_cell.hidden_size, <span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(X.shape[<span class="hljs-number">1</span>]):<br>        x_t = X[t, :].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        h_prev, c_prev = lstm_cell.forward(x_t, h_prev, c_prev)<br>    y_hat = np.dot(W_out, h_prev) + b_out<br>    <span class="hljs-keyword">return</span> y_hat<br></code></pre></td></tr></table></figure><p>您提供的 <code>predict_lstm</code> 函数实现了使用训练好的 LSTM单元进行序列预测的过程。这个函数接收输入序列 <code>X</code>、训练好的LSTM 单元 <code>lstm_cell</code>、输出层的权重 <code>W_out</code> 和偏置<code>b_out</code>，并返回预测的输出<code>y_hat</code>。不过，有几个小地方可能需要调整或注意：</p><ol type="1"><li><p><strong>输入序列的形状</strong>： 在您的函数中，您假设了<code>X</code> 的形状是<code>(time_steps, input_size)</code>，即它是一个二维数组，其中第一维是时间步长，第二维是每个时间步的输入特征数量。这通常是合理的，但请确保这与您训练LSTM 时使用的输入序列形状相匹配。</p></li><li><p><strong>输出形状</strong>： <code>y_hat</code> 的形状将是<code>(1, 1)</code>，因为它是一个单个预测值（假设 <code>W_out</code>的形状是<code>(1, hidden_size)</code>）。如果您的任务是多类别分类或需要多个输出值，您需要相应地调整<code>W_out</code> 的形状。</p></li><li><p><strong>广播机制</strong>： 在<code>np.dot(W_out, h_prev) + b_out</code> 中，NumPy 的广播机制将确保<code>b_out</code>（形状 <code>(1, 1)</code>）被正确地添加到<code>np.dot(W_out, h_prev)</code> 的结果中。但是，请确保<code>W_out</code> 和 <code>h_prev</code> 的形状是兼容的。</p></li><li><p><strong>错误处理</strong>：您的函数没有错误处理机制。在实际应用中，添加一些基本的错误检查（如检查输入形状、权重和偏置的形状等）是一个好习惯。</p></li><li><p><strong>批量预测</strong>：当前函数只能对单个序列进行预测。如果您需要同时预测多个序列，您需要将这个函数包装在一个循环或函数中，以便能够迭代多个输入序列。</p></li><li><p><strong>函数注释</strong>：添加函数注释可以帮助其他开发者（或未来的您）更好地理解函数的用途、参数和返回值。</p></li></ol><p>这里是一个添加了简单注释的 <code>predict_lstm</code> 函数示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_lstm</span>(<span class="hljs-params">X, lstm_cell, W_out, b_out</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    使用训练好的 LSTM 单元进行序列预测。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    参数:</span><br><span class="hljs-string">    - X: 输入序列，形状为 (time_steps, input_size)</span><br><span class="hljs-string">    - lstm_cell: 训练好的 LSTMCell 实例</span><br><span class="hljs-string">    - W_out: 输出层的权重矩阵，形状为 (num_outputs, hidden_size)</span><br><span class="hljs-string">    - b_out: 输出层的偏置向量，形状为 (num_outputs, 1)</span><br><span class="hljs-string"></span><br><span class="hljs-string">    返回:</span><br><span class="hljs-string">    - y_hat: 预测的输出值，形状为 (num_outputs, 1)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    h_prev = np.zeros((lstm_cell.hidden_size, <span class="hljs-number">1</span>))<br>    c_prev = np.zeros((lstm_cell.hidden_size, <span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(X.shape[<span class="hljs-number">0</span>]):  <span class="hljs-comment"># 注意这里使用 X.shape[0] 遍历时间步</span><br>        x_t = X[t, :].reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        h_prev, c_prev = lstm_cell.forward(x_t, h_prev, c_prev)<br>    y_hat = np.dot(W_out, h_prev) + b_out<br>    <span class="hljs-keyword">return</span> y_hat<br></code></pre></td></tr></table></figure><p>请注意，我在遍历时间步时使用了 <code>X.shape[0]</code> 而不是<code>X.shape[1]</code>，因为 <code>X</code> 的形状是<code>(time_steps, input_size)</code>，所以时间步数应该是第一维。如果您的<code>X</code> 形状实际上是<code>(batch_size, time_steps, input_size)</code>（即包含批量处理），则您需要进一步修改这个函数以处理批量数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 主流程</span><br>file_path = <span class="hljs-string">&#x27;data_600519.csv&#x27;</span><br>data = load_stock_data(file_path)<br>data = calculate_technical_indicators(data)<br>scaled_data, scaler = preprocess_data(<br>    data[[<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-string">&#x27;high&#x27;</span>, <span class="hljs-string">&#x27;low&#x27;</span>, <span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-string">&#x27;volume&#x27;</span>, <span class="hljs-string">&#x27;SMA&#x27;</span>, <span class="hljs-string">&#x27;EMA&#x27;</span>, <span class="hljs-string">&#x27;RSI&#x27;</span>, <span class="hljs-string">&#x27;Bollinger Upper&#x27;</span>, <span class="hljs-string">&#x27;Bollinger Lower&#x27;</span>]])<br>seq_length = <span class="hljs-number">10</span><br>X, y = create_dataset(scaled_data, seq_length)<br></code></pre></td></tr></table></figure><p>下面是对您提供的代码段进行逐行解释，包括注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义股票数据文件的路径</span><br>file_path = <span class="hljs-string">&#x27;data_600519.csv&#x27;</span><br><br><span class="hljs-comment"># 加载股票数据文件，这里假设load_stock_data是一个自定义函数，用于从CSV文件中读取并处理股票数据</span><br><span class="hljs-comment"># 函数可能返回Pandas DataFrame对象，其中包含股票的各种数据（如开盘价、收盘价等）</span><br>data = load_stock_data(file_path)<br><br><span class="hljs-comment"># 计算技术指标，这里假设calculate_technical_indicators是一个自定义函数</span><br><span class="hljs-comment"># 它接收股票数据DataFrame作为输入，并计算一些技术指标（如简单移动平均SMA、指数移动平均EMA、相对强弱指数RSI、布林带等）</span><br><span class="hljs-comment"># 然后将这些指标作为新列添加到原始DataFrame中，并返回更新后的DataFrame</span><br>data = calculate_technical_indicators(data)<br><br><span class="hljs-comment"># 数据预处理，这里假设preprocess_data是一个自定义函数</span><br><span class="hljs-comment"># 它接收包含选定特征（如开盘价、收盘价、成交量、计算出的技术指标等）的DataFrame作为输入</span><br><span class="hljs-comment"># 函数首先对数据进行缩放（可能是归一化或标准化），以便模型能够更好地学习</span><br><span class="hljs-comment"># 然后返回缩放后的数据以及用于缩放数据的scaler对象（这可能在后续的数据预测中需要用到）</span><br>scaled_data, scaler = preprocess_data(<br>    data[[<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-string">&#x27;high&#x27;</span>, <span class="hljs-string">&#x27;low&#x27;</span>, <span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-string">&#x27;volume&#x27;</span>, <span class="hljs-string">&#x27;SMA&#x27;</span>, <span class="hljs-string">&#x27;EMA&#x27;</span>, <span class="hljs-string">&#x27;RSI&#x27;</span>, <span class="hljs-string">&#x27;Bollinger Upper&#x27;</span>, <span class="hljs-string">&#x27;Bollinger Lower&#x27;</span>]]<br>)<br><br><span class="hljs-comment"># 定义序列长度，这是时间序列分析中常用的一个参数</span><br><span class="hljs-comment"># 它决定了模型在预测时考虑的历史数据点的数量</span><br>seq_length = <span class="hljs-number">10</span><br><br><span class="hljs-comment"># 创建数据集，这里假设create_dataset是一个自定义函数</span><br><span class="hljs-comment"># 它接收缩放后的数据和序列长度作为输入</span><br><span class="hljs-comment"># 函数的作用是将缩放后的数据转换为适合模型训练的格式</span><br><span class="hljs-comment"># 通常，这意味着将时间序列数据转换为监督学习问题所需的输入（X）和目标（y）</span><br><span class="hljs-comment"># 在时间序列预测中，X通常是多个连续的时间步，而y是紧随其后的时间步的某个值（如下一个时间步的收盘价）</span><br>X, y = create_dataset(scaled_data, seq_length)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练 LSTM</span><br>hidden_size = <span class="hljs-number">10</span><br>epochs = <span class="hljs-number">500</span><br>learning_rate = <span class="hljs-number">0.5</span><br>lstm_cell, W_out, b_out = train_lstm(X, y, hidden_size, epochs, learning_rate)<br><br><span class="hljs-comment"># 预测</span><br>X_test, y_test = create_dataset(scaled_data[-<span class="hljs-number">20</span>:], seq_length)<br>predicted = [predict_lstm(X_test[i], lstm_cell, W_out, b_out)<br>             <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(X_test))]<br>predicted = np.array(predicted).reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment"># 扩展预测值</span><br>num_features = scaled_data.shape[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 原始数据的特征数量</span><br>predicted_full = np.zeros((predicted.shape[<span class="hljs-number">0</span>], num_features))<br>predicted_full[:, <span class="hljs-number">3</span>] = predicted[:, <span class="hljs-number">0</span>]  <span class="hljs-comment"># 假设 &#x27;Close&#x27; 是第 4 列（索引 3）</span><br><span class="hljs-comment"># 进行逆变换</span><br>original_predicted_full = scaler.inverse_transform(predicted_full)<br>original_predicted = original_predicted_full[:, <span class="hljs-number">3</span>]  <span class="hljs-comment"># 提取 &#x27;Close&#x27; 列</span><br>pingjun = np.mean(original_predicted)<br><br><span class="hljs-comment"># 输出结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;预测结果: <span class="hljs-subst">&#123;original_predicted&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;预测结果(平均值): <span class="hljs-subst">&#123;pingjun&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>在您提供的代码段中，您首先训练了一个LSTM模型，并使用该模型进行了预测。然而，有几个地方需要注意或可能需要修改，以确保代码能够正确运行并产生预期的结果。以下是对代码段的详细解释和可能的修改建议：</p><ol type="1"><li><p><strong>训练 LSTM</strong>： 您假设有一个名为<code>train_lstm</code> 的函数，它接收输入数据 <code>X</code>、目标数据<code>y</code>、隐藏层大小 <code>hidden_size</code>、训练轮次<code>epochs</code> 和学习率 <code>learning_rate</code>，并返回训练好的LSTM 单元、输出层权重 <code>W_out</code> 和偏置<code>b_out</code>。这个函数的具体实现不在您提供的代码段中，但它是关键部分，需要确保它正确实现了LSTM 的训练过程。</p></li><li><p><strong>预测</strong>：</p><ul><li>您使用 <code>create_dataset</code> 函数从 <code>scaled_data</code>的最后 20 个时间点中创建了一个测试数据集 <code>X_test</code> 和<code>y_test</code>。请注意，由于您正在使用 LSTM进行预测，因此实际上可能不需要<code>y_test</code>（除非您打算在测试集上评估模型性能）。</li><li>您定义了一个 <code>predict_lstm</code>函数（尽管它的实现细节不在这里），该函数应该接收单个时间步的输入序列<code>X_test[i]</code>、LSTM单元、输出层权重和偏置，并返回预测结果。然而，在 LSTM的上下文中，通常一次预测多个时间步（使用滑动窗口或类似方法），但这里您似乎是对每个时间步单独进行预测。</li><li>您将预测结果收集到一个列表中，并将其转换为 NumPy数组。然后，您创建了一个与原始数据特征数量相同大小的零数组<code>predicted_full</code>，并将预测结果（假设是收盘价）放入该数组的适当列中。</li></ul></li><li><p><strong>逆变换和结果提取</strong>：</p><ul><li>您使用 <code>scaler.inverse_transform</code>方法将缩放后的预测数据转换回原始比例。这是必要的，因为模型是在缩放后的数据上训练的。</li><li>您从转换后的数据中提取了“Close”列的预测值。</li></ul></li><li><p><strong>可能的修改</strong>：</p><ul><li>确保 <code>predict_lstm</code>函数能够处理单个时间步的输入，并返回正确的预测值。如果 LSTM单元设计为处理多个时间步，则可能需要修改该函数以适应这一点。</li><li>如果您的目标是进行多步预测（即预测未来多个时间点的收盘价），则可能需要修改预测循环以生成多个时间步的预测。</li><li>验证 <code>scaler</code>是否确实包含了用于逆变换所需的所有信息（例如，均值和标准差）。</li></ul></li><li><p><strong>输出结果</strong>：</p><ul><li>您打印了预测结果及其平均值。这可以帮助您了解模型的预测性能。</li></ul></li><li><p><strong>注意</strong>：</p><ul><li>LSTM通常用于处理序列数据，并且一次可以处理多个时间步。在您的代码中，您似乎对每个时间步单独进行了预测，这在实际应用中可能不是最优的。</li><li>确保 <code>scaler</code>和其他预处理步骤（如特征选择）在训练和测试数据上保持一致。</li></ul></li></ol><p>以下是一个简化的预测步骤示例，假设 <code>predict_lstm</code>函数已经能够处理整个序列（而不仅仅是单个时间步）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 假设 predict_lstm 现在可以处理整个序列 X_test</span><br>predicted_full = predict_lstm(X_test, lstm_cell, W_out, b_out)<br><span class="hljs-comment"># 注意：这里 predicted_full 的形状应该与 scaled_data 的相应部分相匹配</span><br><span class="hljs-comment"># 逆变换和结果提取保持不变</span><br>original_predicted_full = scaler.inverse_transform(predicted_full)<br>original_predicted = original_predicted_full[:, <span class="hljs-number">3</span>]  <span class="hljs-comment"># 提取 &#x27;Close&#x27; 列</span><br>pingjun = np.mean(original_predicted)<br><br><span class="hljs-comment"># 输出结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;预测结果: <span class="hljs-subst">&#123;original_predicted&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;预测结果(平均值): <span class="hljs-subst">&#123;pingjun&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>但是，请注意，这个简化的示例假设 <code>predict_lstm</code>已经被相应地修改以处理整个序列。如果它仍然只能处理单个时间步，则您可能需要使用循环或其他方法来生成整个序列的预测。</p><h2id="用于抓取股价的python代码">用于抓取股价的<code>python</code>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding:utf-8 -*-    --------------Ashare 股票行情数据双核心版( https://github.com/mpquant/Ashare )</span><br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd  <span class="hljs-comment">#</span><br><br><span class="hljs-comment"># 腾讯日线</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_price_day_tx</span>(<span class="hljs-params">code, end_date=<span class="hljs-string">&#x27;&#x27;</span>, count=<span class="hljs-number">10</span>, frequency=<span class="hljs-string">&#x27;1d&#x27;</span></span>):  <span class="hljs-comment"># 日线获取</span><br>    unit = <span class="hljs-string">&#x27;week&#x27;</span> <span class="hljs-keyword">if</span> frequency <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;1w&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;month&#x27;</span> <span class="hljs-keyword">if</span> frequency <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;1M&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;day&#x27;</span>  <span class="hljs-comment"># 判断日线，周线，月线</span><br>    <span class="hljs-keyword">if</span> end_date:<br>        end_date = end_date.strftime(<br>            <span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>) <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(end_date, datetime.date) <span class="hljs-keyword">else</span> end_date.split(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">0</span>]<br>    end_date = <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">if</span> end_date == datetime.datetime.now().strftime(<br>        <span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>) <span class="hljs-keyword">else</span> end_date  <span class="hljs-comment"># 如果日期今天就变成空</span><br>    URL = <span class="hljs-string">f&#x27;http://web.ifzq.gtimg.cn/appstock/app/fqkline/get?param=<span class="hljs-subst">&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">        code&#125;</span>,<span class="hljs-subst">&#123;unit&#125;</span>,,<span class="hljs-subst">&#123;end_date&#125;</span>,<span class="hljs-subst">&#123;count&#125;</span>,qfq&#x27;</span><br>    st = json.loads(requests.get(URL).content)<br>    ms = <span class="hljs-string">&#x27;qfq&#x27;</span>+unit<br>    stk = st[<span class="hljs-string">&#x27;data&#x27;</span>][code]<br>    buf = stk[ms] <span class="hljs-keyword">if</span> ms <span class="hljs-keyword">in</span> stk <span class="hljs-keyword">else</span> stk[unit]  <span class="hljs-comment"># 指数返回不是qfqday,是day</span><br>    df = pd.DataFrame(<br>        buf, columns=[<span class="hljs-string">&#x27;time&#x27;</span>, <span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-string">&#x27;high&#x27;</span>, <span class="hljs-string">&#x27;low&#x27;</span>, <span class="hljs-string">&#x27;volume&#x27;</span>], dtype=<span class="hljs-string">&#x27;float&#x27;</span>)<br>    df.time = pd.to_datetime(df.time)<br>    df.set_index([<span class="hljs-string">&#x27;time&#x27;</span>], inplace=<span class="hljs-literal">True</span>)<br>    df.index.name = <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-comment"># 处理索引</span><br>    <span class="hljs-keyword">return</span> df<br><br><span class="hljs-comment"># 腾讯分钟线</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_price_min_tx</span>(<span class="hljs-params">code, end_date=<span class="hljs-literal">None</span>, count=<span class="hljs-number">10</span>, frequency=<span class="hljs-string">&#x27;1d&#x27;</span></span>):  <span class="hljs-comment"># 分钟线获取</span><br>    ts = <span class="hljs-built_in">int</span>(frequency[:-<span class="hljs-number">1</span>]) <span class="hljs-keyword">if</span> frequency[:-<span class="hljs-number">1</span>].isdigit() <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>  <span class="hljs-comment"># 解析K线周期数</span><br>    <span class="hljs-keyword">if</span> end_date:<br>        end_date = end_date.strftime(<br>            <span class="hljs-string">&#x27;%Y-%m-%d&#x27;</span>) <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(end_date, datetime.date) <span class="hljs-keyword">else</span> end_date.split(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">0</span>]<br>    URL = <span class="hljs-string">f&#x27;http://ifzq.gtimg.cn/appstock/app/kline/mkline?param=<span class="hljs-subst">&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">        code&#125;</span>,m<span class="hljs-subst">&#123;ts&#125;</span>,,<span class="hljs-subst">&#123;count&#125;</span>&#x27;</span><br>    st = json.loads(requests.get(URL).content)<br>    buf = st[<span class="hljs-string">&#x27;data&#x27;</span>][code][<span class="hljs-string">&#x27;m&#x27;</span>+<span class="hljs-built_in">str</span>(ts)]<br>    df = pd.DataFrame(<br>        buf, columns=[<span class="hljs-string">&#x27;time&#x27;</span>, <span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-string">&#x27;high&#x27;</span>, <span class="hljs-string">&#x27;low&#x27;</span>, <span class="hljs-string">&#x27;volume&#x27;</span>, <span class="hljs-string">&#x27;n1&#x27;</span>, <span class="hljs-string">&#x27;n2&#x27;</span>])<br>    df = df[[<span class="hljs-string">&#x27;time&#x27;</span>, <span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-string">&#x27;high&#x27;</span>, <span class="hljs-string">&#x27;low&#x27;</span>, <span class="hljs-string">&#x27;volume&#x27;</span>]]<br>    df[[<span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-string">&#x27;high&#x27;</span>, <span class="hljs-string">&#x27;low&#x27;</span>, <span class="hljs-string">&#x27;volume&#x27;</span>]] = df[[<br>        <span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-string">&#x27;high&#x27;</span>, <span class="hljs-string">&#x27;low&#x27;</span>, <span class="hljs-string">&#x27;volume&#x27;</span>]].astype(<span class="hljs-string">&#x27;float&#x27;</span>)<br>    df.time = pd.to_datetime(df.time)<br>    df.set_index([<span class="hljs-string">&#x27;time&#x27;</span>], inplace=<span class="hljs-literal">True</span>)<br>    df.index.name = <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-comment"># 处理索引</span><br>    df[<span class="hljs-string">&#x27;close&#x27;</span>][-<span class="hljs-number">1</span>] = <span class="hljs-built_in">float</span>(st[<span class="hljs-string">&#x27;data&#x27;</span>][code][<span class="hljs-string">&#x27;qt&#x27;</span>][code][<span class="hljs-number">3</span>])  <span class="hljs-comment"># 最新基金数据是3位的</span><br>    <span class="hljs-keyword">return</span> df<br><br><br><span class="hljs-comment"># sina新浪全周期获取函数，分钟线 5m,15m,30m,60m  日线1d=240m   周线1w=1200m  1月=7200m</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_price_sina</span>(<span class="hljs-params">code, end_date=<span class="hljs-string">&#x27;&#x27;</span>, count=<span class="hljs-number">10</span>, frequency=<span class="hljs-string">&#x27;60m&#x27;</span></span>):  <span class="hljs-comment"># 新浪全周期获取函数</span><br>    frequency = frequency.replace(<span class="hljs-string">&#x27;1d&#x27;</span>, <span class="hljs-string">&#x27;240m&#x27;</span>).replace(<br>        <span class="hljs-string">&#x27;1w&#x27;</span>, <span class="hljs-string">&#x27;1200m&#x27;</span>).replace(<span class="hljs-string">&#x27;1M&#x27;</span>, <span class="hljs-string">&#x27;7200m&#x27;</span>)<br>    mcount = count<br>    ts = <span class="hljs-built_in">int</span>(frequency[:-<span class="hljs-number">1</span>]) <span class="hljs-keyword">if</span> frequency[:-<span class="hljs-number">1</span>].isdigit() <span class="hljs-keyword">else</span> <span class="hljs-number">1</span>  <span class="hljs-comment"># 解析K线周期数</span><br>    <span class="hljs-keyword">if</span> (end_date != <span class="hljs-string">&#x27;&#x27;</span>) &amp; (frequency <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;240m&#x27;</span>, <span class="hljs-string">&#x27;1200m&#x27;</span>, <span class="hljs-string">&#x27;7200m&#x27;</span>]):<br>        end_date = pd.to_datetime(end_date) <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(<br>            end_date, datetime.date) <span class="hljs-keyword">else</span> end_date  <span class="hljs-comment"># 转换成datetime</span><br>        unit = <span class="hljs-number">4</span> <span class="hljs-keyword">if</span> frequency == <span class="hljs-string">&#x27;1200m&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-number">29</span> <span class="hljs-keyword">if</span> frequency == <span class="hljs-string">&#x27;7200m&#x27;</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 4,29多几个数据不影响速度</span><br>        <span class="hljs-comment"># 结束时间到今天有多少天自然日(肯定 &gt;交易日)</span><br>        count = count+(datetime.datetime.now()-end_date).days//unit<br>        <span class="hljs-comment"># print(code,end_date,count)</span><br>    URL = <span class="hljs-string">f&#x27;http://money.finance.sina.com.cn/quotes_service/api/json_v2.php/CN_MarketData.getKLineData?symbol=<span class="hljs-subst">&#123;</span></span><br><span class="hljs-subst"><span class="hljs-string">        code&#125;</span>&amp;scale=<span class="hljs-subst">&#123;ts&#125;</span>&amp;ma=5&amp;datalen=<span class="hljs-subst">&#123;count&#125;</span>&#x27;</span><br>    dstr = json.loads(requests.get(URL).content)<br>    <span class="hljs-comment"># df=pd.DataFrame(dstr,columns=[&#x27;day&#x27;,&#x27;open&#x27;,&#x27;high&#x27;,&#x27;low&#x27;,&#x27;close&#x27;,&#x27;volume&#x27;],dtype=&#x27;float&#x27;)</span><br>    df = pd.DataFrame(<br>        dstr, columns=[<span class="hljs-string">&#x27;day&#x27;</span>, <span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-string">&#x27;high&#x27;</span>, <span class="hljs-string">&#x27;low&#x27;</span>, <span class="hljs-string">&#x27;close&#x27;</span>, <span class="hljs-string">&#x27;volume&#x27;</span>])<br>    df[<span class="hljs-string">&#x27;open&#x27;</span>] = df[<span class="hljs-string">&#x27;open&#x27;</span>].astype(<span class="hljs-built_in">float</span>)<br>    df[<span class="hljs-string">&#x27;high&#x27;</span>] = df[<span class="hljs-string">&#x27;high&#x27;</span>].astype(<span class="hljs-built_in">float</span>)  <span class="hljs-comment"># 转换数据类型</span><br>    df[<span class="hljs-string">&#x27;low&#x27;</span>] = df[<span class="hljs-string">&#x27;low&#x27;</span>].astype(<span class="hljs-built_in">float</span>)<br>    df[<span class="hljs-string">&#x27;close&#x27;</span>] = df[<span class="hljs-string">&#x27;close&#x27;</span>].astype(<span class="hljs-built_in">float</span>)<br>    df[<span class="hljs-string">&#x27;volume&#x27;</span>] = df[<span class="hljs-string">&#x27;volume&#x27;</span>].astype(<span class="hljs-built_in">float</span>)<br>    df.day = pd.to_datetime(df.day)<br>    df.set_index([<span class="hljs-string">&#x27;day&#x27;</span>], inplace=<span class="hljs-literal">True</span>)<br>    df.index.name = <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-comment"># 处理索引</span><br>    <span class="hljs-keyword">if</span> (end_date != <span class="hljs-string">&#x27;&#x27;</span>) &amp; (frequency <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;240m&#x27;</span>, <span class="hljs-string">&#x27;1200m&#x27;</span>, <span class="hljs-string">&#x27;7200m&#x27;</span>]):<br>        <span class="hljs-keyword">return</span> df[df.index &lt;= end_date][-mcount:]  <span class="hljs-comment"># 日线带结束时间先返回</span><br>    <span class="hljs-keyword">return</span> df<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_price</span>(<span class="hljs-params">code, end_date=<span class="hljs-string">&#x27;&#x27;</span>, count=<span class="hljs-number">10</span>, frequency=<span class="hljs-string">&#x27;1d&#x27;</span>, fields=[]</span>):<br>    <span class="hljs-comment"># 对外暴露只有唯一函数，这样对用户才是最友好的</span><br>    xcode = code.replace(<span class="hljs-string">&#x27;.XSHG&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>).replace(<span class="hljs-string">&#x27;.XSHE&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>)  <span class="hljs-comment"># 证券代码编码兼容处理</span><br>    xcode = <span class="hljs-string">&#x27;sh&#x27;</span>+xcode <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;XSHG&#x27;</span> <span class="hljs-keyword">in</span> code) <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;sz&#x27;</span> + \<br>        xcode <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;XSHE&#x27;</span> <span class="hljs-keyword">in</span> code) <span class="hljs-keyword">else</span> code<br><br>    <span class="hljs-keyword">if</span> frequency <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;1d&#x27;</span>, <span class="hljs-string">&#x27;1w&#x27;</span>, <span class="hljs-string">&#x27;1M&#x27;</span>]:  <span class="hljs-comment"># 1d日线  1w周线  1M月线</span><br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 主力</span><br>            <span class="hljs-keyword">return</span> get_price_sina(xcode, end_date=end_date, count=count, frequency=frequency)<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-comment"># 备用</span><br>            <span class="hljs-keyword">return</span> get_price_day_tx(xcode, end_date=end_date, count=count, frequency=frequency)<br><br>    <span class="hljs-keyword">if</span> frequency <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;1m&#x27;</span>, <span class="hljs-string">&#x27;5m&#x27;</span>, <span class="hljs-string">&#x27;15m&#x27;</span>, <span class="hljs-string">&#x27;30m&#x27;</span>, <span class="hljs-string">&#x27;60m&#x27;</span>]:  <span class="hljs-comment"># 分钟线 ,1m只有腾讯接口  5分钟5m   60分钟60m</span><br>        <span class="hljs-keyword">if</span> frequency <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;1m&#x27;</span>:<br>            <span class="hljs-keyword">return</span> get_price_min_tx(xcode, end_date=end_date, count=count, frequency=frequency)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 主力</span><br>            <span class="hljs-keyword">return</span> get_price_sina(xcode, end_date=end_date, count=count, frequency=frequency)<br>        <span class="hljs-keyword">except</span>:<br>            <span class="hljs-comment"># 备用</span><br>            <span class="hljs-keyword">return</span> get_price_min_tx(xcode, end_date=end_date, count=count, frequency=frequency)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    df = get_price(<span class="hljs-string">&#x27;sh000001&#x27;</span>, frequency=<span class="hljs-string">&#x27;1d&#x27;</span>,<br>                   count=<span class="hljs-number">10</span>)  <span class="hljs-comment"># 支持&#x27;1d&#x27;日, &#x27;1w&#x27;周, &#x27;1M&#x27;月</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;上证指数日线行情\n&#x27;</span>, df)<br><br>    <span class="hljs-comment"># 支持&#x27;1m&#x27;,&#x27;5m&#x27;,&#x27;15m&#x27;,&#x27;30m&#x27;,&#x27;60m&#x27;</span><br>    df = get_price(<span class="hljs-string">&#x27;000001.XSHG&#x27;</span>, frequency=<span class="hljs-string">&#x27;15m&#x27;</span>, count=<span class="hljs-number">10</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;上证指数分钟线\n&#x27;</span>, df)<br><br><span class="hljs-comment"># Ashare 股票行情数据( https://github.com/mpquant/Ashare )</span><br><br><br><br><span class="hljs-comment"># 具体用法</span><br><span class="hljs-comment"># -*- coding:utf-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;获取股票历史价格&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> Ashare<br><br>gupiao = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;输入代码：&#x27;</span>)<br><span class="hljs-comment"># count为想要获取的天数</span><br><span class="hljs-keyword">if</span> gupiao[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;6&#x27;</span>:<br>df = Ashare.get_price(<span class="hljs-string">f&#x27;sh<span class="hljs-subst">&#123;gupiao&#125;</span>&#x27;</span>, frequency=<span class="hljs-string">&#x27;1d&#x27;</span>, count=<span class="hljs-number">100</span>)<br><span class="hljs-keyword">else</span>:<br>    df = Ashare.get_price(<span class="hljs-string">f&#x27;sz<span class="hljs-subst">&#123;gupiao&#125;</span>&#x27;</span>, frequency=<span class="hljs-string">&#x27;1d&#x27;</span>, count=<span class="hljs-number">100</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;上证指数历史行情\n&#x27;</span>, df)<br><br>output_File = <span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;gupiao&#125;</span>&#x27;</span><br>df.to_csv(<span class="hljs-string">f&#x27;data_<span class="hljs-subst">&#123;output_File&#125;</span>.csv&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;数据已经存储到data_<span class="hljs-subst">&#123;output_File&#125;</span>.csv&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>python</tag>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人工智能学习笔记</title>
    <link href="/2024/10/04/2024-10-04-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/10/04/2024-10-04-%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="人工智能学习笔记">人工智能学习笔记</h1><hr /><h2 id="什么是人工智能">什么是人工智能？</h2><p>:star:人制造出来的机器，来模仿人的行为。还有就是能够自主学习及解决问题更新自己的知识库。让机器能够像人一样思考和行动。比如以下几种：</p><ul><li>人脸识别、车牌识别、自动驾驶</li><li>机器翻译、人机互动、GPT</li><li>智能机器人、AlphaGO等等</li></ul><p>人工智能实现方法：</p><ul><li><p>符号学习：原理是基于逻辑与规则的学习方法，其原理主要为物理符号系统假设和有限合理性原理，不能升级模型。</p></li><li><p>:star:机器学习：从数据中寻找规律、建立关系，根据建立的关系去解决问题的方法，从数据中学习并且实现自我优化升级，其原理是数据驱动。</p><blockquote><p>:bulb:机器学习是一种实现人工智能的<strong>方法</strong>，从数据中学习然后对真实世界的时间做出决策和预测，比如，垃圾邮件检测、房价预测等等。</p><p>:bulb:深度学习是一种实现机器学习的<strong>技术</strong>。模仿人类神经网络，建立模型，进行数据分析，比如，人脸识别、无人驾驶等等。</p></blockquote></li></ul><p>工具安装：</p><ul><li>python 官网下载安装</li><li>jupyter notebook</li><li>pandas、matplib、numpy</li></ul><p>在系统的一个位置新建一个文件夹，比如：e:_log</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建虚拟环境</span><br>E:\learning_log&gt; python -m venv ai_env<br><br><span class="hljs-comment"># 激活虚拟环境 关闭虚拟环境用 deactivate</span><br>E:\learning_log&gt; ai_env\Scripts\activate<br><br><span class="hljs-comment"># 安装jupyter notebook</span><br>(ll_env) E:\learning_log&gt; python.exe -m pip install --upgrade pip<br>(ll_env) E:\learning_log&gt; pip install notebook<br></code></pre></td></tr></table></figure><p>在虚拟环境的目录下创建一个<code>txt</code>文件并该后缀为<code>bat</code>，编辑内容为：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cmd">@<span class="hljs-built_in">echo</span> off<br><span class="hljs-keyword">call</span> E:\learning_log&gt; ai_env\Scripts\activate<br>jupyter notebook --browser=edge<br># 这个bat文件是放在和虚拟环境文件夹同个目录，需要复制网址打开编辑器<br><br># 如果需要直接启动的话需要在虚拟环境（激活）下输入jupyter notebook --generate-config<br># 这时C盘用户文件夹就会出现一个 C:\Users\用户名\.jupyter 的文件夹<br># 打开里面的 jupyter_notebook_config.py 添加一行 c.NotebookApp.use_redirect_file = False<br>(ll_env) E:\learning_log&gt;jupyter notebook<br><br># 删除虚拟环境<br>直接删除文件目录就可以了，确保没有激活虚拟环境！<br></code></pre></td></tr></table></figure><p>这就启动了jupyter了</p><p>安装pandas等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 国内镜像安装</span><br>pip install pandas -i https://pypi.tuna.tsinghua.edu.cn/simple some-package<br>pip install matplotlib -i https://pypi.tuna.tsinghua.edu.cn/simple some-package<br>pip install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple some-package<br></code></pre></td></tr></table></figure><h2 id="工具使用和介绍">工具使用和介绍</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>y = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><h4 id="安装和使用matplotlib">安装和使用matplotlib</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-comment"># 让图形展示的%代码</span><br>%matplotlib inline<br>fig1 = plt.figure(figsize=(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>))<br>plt.plot(x,y)<br>plt.title(<span class="hljs-string">&#x27;y vs x&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 散点图plt.scatter(x,y)</span><br>fig2 = plt.figure(figsize=(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>))<br>plt.scatter(x,y)<br>plt.title(<span class="hljs-string">&#x27;y vs x&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br><br>plt.show()<br>    <br></code></pre></td></tr></table></figure><h4 id="安装和使用numpy">安装和使用numpy</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>a = np.eye(<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(a))<br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure><pre><code class="hljs">&lt;class &#39;numpy.ndarray&#39;&gt;[[1. 0. 0. 0. 0.] [0. 1. 0. 0. 0.] [0. 0. 1. 0. 0.] [0. 0. 0. 1. 0.] [0. 0. 0. 0. 1.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">b = np.ones([<span class="hljs-number">5</span>,<span class="hljs-number">5</span>])<br><span class="hljs-built_in">print</span>(b)<br><span class="hljs-comment"># 显示行列</span><br><span class="hljs-built_in">print</span>(b.shape)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.] [1. 1. 1. 1. 1.]](5, 5)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">c = a + b<br><span class="hljs-built_in">print</span>(c.shape)<br><span class="hljs-built_in">print</span>(c)<br></code></pre></td></tr></table></figure><pre><code class="hljs">(5, 5)[[2. 1. 1. 1. 1.] [1. 2. 1. 1. 1.] [1. 1. 2. 1. 1.] [1. 1. 1. 2. 1.] [1. 1. 1. 1. 2.]]</code></pre><h4 id="安装和使用pandas">安装和使用pandas</h4><p>这里有个提示：就是有时候windows的路径是反斜杠，我们需要改成正斜杠。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>data = pd.read_csv(<span class="hljs-string">&#x27;./data.csv&#x27;</span>)<br><span class="hljs-built_in">print</span>(data)<br></code></pre></td></tr></table></figure><pre><code class="hljs">      Name  Age         City0    Alice   24     New York1      Bob   27  Los Angeles2  Charlie   22      Chicago3    David   32      Houston4      Eve   29      Phoenix</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = data.loc[:,<span class="hljs-string">&#x27;Name&#x27;</span>]<br><span class="hljs-built_in">print</span>(name)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0      Alice1        Bob2    Charlie3      David4        EveName: Name, dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">age = data.loc[:,<span class="hljs-string">&#x27;Age&#x27;</span>]<br><span class="hljs-built_in">print</span>(age)<br></code></pre></td></tr></table></figure><pre><code class="hljs">0    241    272    223    324    29Name: Age, dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 筛选</span><br>c = data.loc[:,<span class="hljs-string">&#x27;Age&#x27;</span>][age&gt;<span class="hljs-number">25</span>]<br><span class="hljs-built_in">print</span>(c)<br></code></pre></td></tr></table></figure><pre><code class="hljs">1    273    324    29Name: Age, dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># pandas转换为numpy</span><br>data_array = np.array(data)<br><span class="hljs-built_in">print</span>(data_array)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[&#39;Alice&#39; 24 &#39;New York&#39;] [&#39;Bob&#39; 27 &#39;Los Angeles&#39;] [&#39;Charlie&#39; 22 &#39;Chicago&#39;] [&#39;David&#39; 32 &#39;Houston&#39;] [&#39;Eve&#39; 29 &#39;Phoenix&#39;]]</code></pre><p>保存为本地文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">data_new = age + <span class="hljs-number">1</span><br>data_new.head()<br><span class="hljs-comment"># 保存,如果要去除索引列 to_csv( &#x27;1.csv&#x27;,index=None)</span><br>data_new.to_csv(<span class="hljs-string">&#x27;data_new.csv&#x27;</span>,index=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><hr /><h2 id="机器学习线性回归">机器学习——线性回归</h2><p>机器学习是一种实现人工智能的<strong>方法</strong>，从数据中寻找规律、建立关系，根据建立的关系去解决问题。</p><p>机器学习应用场景：</p><ul><li>数据挖掘</li><li>计算机视觉</li><li>自然语言处理</li><li>证券分析</li><li>医学诊断</li><li>机器人</li><li>DNA测序等等</li></ul><p>机器学习基本框架：数据——&gt;函数——&gt;解决问题</p><p>机器学习类别：</p><ul><li><p>监督学习</p><blockquote><p>告诉机器什么是对的</p><ul><li>线性回归</li><li>逻辑回归</li><li>决策树</li><li>神经网络、卷积神经网络、循环神经网络</li></ul></blockquote></li><li><p>无监督学习</p><blockquote><p>让机器自己去数据中寻找规律</p><ul><li>聚类算法</li></ul></blockquote></li><li><p>半监督学习</p><blockquote><p>告诉机器一部分正确的，剩下的让机器自己去理解</p></blockquote></li><li><p>强化学习（深度学习）</p><blockquote><p>根据每次结果收获的奖惩进行学习，实现优化</p></blockquote></li></ul><h3 id="线性回归">线性回归</h3><p>找到两个（或两个以上）数据对应关系的一条线，通过拟合这条线进行新的预测。</p><p><span class="math inline">\(y = ax +b\)</span><code>其中a为斜率，b为截距（y为0或者x为0的时候另一个点在哪里）</code></p><p><span class="math inline">\(y = f(x_1,x_2\dots x_n)\)</span></p><ul><li>一元回归：<span class="math inline">\(y=f(x)\)</span></li><li>多元回归：<span class="math inline">\(y = f(x_1,x_2\dotsx_n)\)</span></li><li>线性回归：<span class="math inline">\(y=ax+b\)</span></li><li>非线性回归：<span class="math inline">\(y=ax^2+bx+c\)</span></li></ul><p><span class="math inline">\(j = \frac{1}{2m}\sum_{i=1}^{m}(y_1-y)^2 =\frac{1}{2m}\sum_{i=1}^{m}(ax_i+b-y_i)^2 = g(a,b)\)</span><code>j的值越小，就代表越接近真实的值。</code></p><h3 id="线性回归实战准备">线性回归实战准备</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Scikit-learn```是针对机器学习的一款开源框架（算法库），其可以实现数据预处理、分类、回归、降维等等。"><br>任务：基于generated_data.csv数据，建立线性回归模型，预测x=3.5对应的y值，评估模型表现(lr.model.coef_和lr_model.intercept_)<br><br><br>```python<br># 加载数据<br>import pandas as pd<br>data = pd.read_csv(&#x27;./data/generated_data.csv&#x27;)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">data.head()<br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th>x</th><th>y</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>7</td></tr><tr><td>1</td><td>2</td><td>9</td></tr><tr><td>2</td><td>3</td><td>11</td></tr><tr><td>3</td><td>4</td><td>13</td></tr><tr><td>4</td><td>5</td><td>15</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数据赋值</span><br>x = data.loc[:,<span class="hljs-string">&#x27;x&#x27;</span>]<br>y = data.loc[:,<span class="hljs-string">&#x27;y&#x27;</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 展示图形</span><br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br>plt.figure(figsize=(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>))<br>plt.scatter(x,y)<br>plt.show()<br></code></pre></td></tr></table></figure><h3id="python调用sklearn实现线性回归">python调用Sklearn实现线性回归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 建立线性回归模型</span><br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>lr_model = LinearRegression()<br><br><span class="hljs-comment"># 用numpy将一维数据转换为二维数据</span><br>x = np.array(x)<br>x = x.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>y = np.array(y)<br>y = y.reshape(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br><br>lr_model.fit(x,y)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 预测模型</span><br>y_predict = lr_model.predict(x)<br><span class="hljs-comment"># print(y_predict)</span><br><br><span class="hljs-comment"># 这里需要注意，如果直接给数值预测会报错，我们需要把数值转换成二维的，就是[[3.5]]这个样子</span><br>y_predict_2 = lr_model.predict([[<span class="hljs-number">3.5</span>]])<br><span class="hljs-built_in">print</span>(y_predict_2)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[12.]]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 打印a、b就是y = ax + b中的，a是斜率，b是截距</span><br>a = lr_model.coef_<br>b = lr_model.intercept_<br><span class="hljs-built_in">print</span>(a,b)<br></code></pre></td></tr></table></figure><pre><code class="hljs">[[2.]] [5.]</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 评估模型----MSE越接近0越好，r2越接近1越好</span><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error,r2_score<br>MSE = mean_squared_error(y,y_predict)<br>R2 = r2_score(y,y_predict)<br><span class="hljs-built_in">print</span>(MSE,R2)<br><br>plt.figure()<br>plt.plot(y,y_predict)<br>plt.show()<br></code></pre></td></tr></table></figure><pre><code class="hljs">3.1554436208840474e-31 1.0</code></pre><p>Ashare用法</p><p>from Ashare import *</p><p>df=get_price('sh000001',frequency='1d',count=5)#默认获取今天往前5天的日线实时行情 print('上证指数日线行情',df)</p><p>df=get_price('000001.XSHG',frequency='1d',count=5,end_date='2021-04-30')#可以指定结束日期，获取历史行情 print('上证指数历史行情',df)</p><p>df=get_price('000001.XSHG',frequency='1w',count=5,end_date='2018-06-15')#支持'1d'日, '1w'周, '1M'月<br />print('上证指数历史周线',df)</p><p>df=get_price('sh600519',frequency='15m',count=5)#分钟线实时行情，可用'1m','5m','15m','30m','60m'print('贵州茅台15分钟线',df)</p><p>df=get_price('600519.XSHG',frequency='60m',count=6)#分钟线实时行情，可用'1m','5m','15m','30m','60m'print('贵州茅台60分钟线',df)</p><h3 id="完整代码多家公司股价预测">完整代码：多家公司股价预测</h3><h4 id="安装依赖包">1. 安装依赖包</h4><p>确保你已经安装了必要的库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pandas numpy scikit-learn matplotlib<br></code></pre></td></tr></table></figure><h4 id="准备-csv-文件">2. 准备 CSV 文件</h4><p>假设你的 CSV 文件结构如下（文件名为<code>stock_data.csv</code>）：</p><table><thead><tr><th>Date</th><th>Open</th><th>High</th><th>Low</th><th>Close</th><th>Volume</th></tr></thead><tbody><tr><td>2024-01-01</td><td>150.00</td><td>155.00</td><td>148.00</td><td>152.00</td><td>1000000</td></tr><tr><td>2024-01-02</td><td>210.00</td><td>215.00</td><td>208.00</td><td>212.00</td><td>1500000</td></tr><tr><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td></tr></tbody></table><h4 id="机器学习代码">3. 机器学习代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 加载数据</span><br>data = pd.read_csv(<span class="hljs-string">&#x27;stock_data.csv&#x27;</span>)<br><br><span class="hljs-comment"># 查看数据</span><br><span class="hljs-built_in">print</span>(data.head())<br><br><span class="hljs-comment"># 数据预处理</span><br>data[<span class="hljs-string">&#x27;Date&#x27;</span>] = pd.to_datetime(data[<span class="hljs-string">&#x27;Date&#x27;</span>])<br>data.set_index(<span class="hljs-string">&#x27;Date&#x27;</span>, inplace=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 为每个公司添加前一天的收盘价和开盘价作为特征</span><br>data[<span class="hljs-string">&#x27;Prev_Close&#x27;</span>] = data[<span class="hljs-string">&#x27;Close&#x27;</span>].shift(<span class="hljs-number">1</span>)<br>data[<span class="hljs-string">&#x27;Prev_Open&#x27;</span>] = data[<span class="hljs-string">&#x27;Open&#x27;</span>].shift(<span class="hljs-number">1</span>)<br>data.dropna(inplace=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 删除缺失值</span><br><br><span class="hljs-comment"># 特征和标签</span><br>features = data[[<span class="hljs-string">&#x27;Prev_Close&#x27;</span>, <span class="hljs-string">&#x27;Prev_Open&#x27;</span>]]<br>target = data[<span class="hljs-string">&#x27;Close&#x27;</span>]<br><br><span class="hljs-comment"># 分割数据集</span><br>X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)<br><br><span class="hljs-comment"># 构建模型</span><br>model = LinearRegression()<br>model.fit(X_train, y_train)<br><br><span class="hljs-comment"># 预测</span><br>predictions = model.predict(X_test)<br><br><span class="hljs-comment"># 评估模型</span><br>mse = mean_squared_error(y_test, predictions)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Mean Squared Error: <span class="hljs-subst">&#123;mse&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 查看预测值和实际值</span><br>result = pd.DataFrame(&#123;<span class="hljs-string">&#x27;Actual&#x27;</span>: y_test, <span class="hljs-string">&#x27;Predicted&#x27;</span>: predictions&#125;)<br><span class="hljs-built_in">print</span>(result.head())<br><br><span class="hljs-comment"># 绘制预测值和实际值对比图</span><br>plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))<br>plt.plot(result.index, result[<span class="hljs-string">&#x27;Actual&#x27;</span>], label=<span class="hljs-string">&#x27;Actual&#x27;</span>, color=<span class="hljs-string">&#x27;blue&#x27;</span>, marker=<span class="hljs-string">&#x27;o&#x27;</span>)<br>plt.plot(result.index, result[<span class="hljs-string">&#x27;Predicted&#x27;</span>], label=<span class="hljs-string">&#x27;Predicted&#x27;</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>, linestyle=<span class="hljs-string">&#x27;--&#x27;</span>, marker=<span class="hljs-string">&#x27;x&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;Date&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Stock Price&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Stock Price Prediction&#x27;</span>)<br>plt.legend()<br>plt.show()<br></code></pre></td></tr></table></figure><h4 id="使用方法说明">4. 使用方法说明</h4><ol type="1"><li><strong>加载数据</strong>:<ul><li>将你的 CSV 文件（如<code>stock_data.csv</code>）存放在脚本的同一目录中，或使用绝对路径。</li><li>使用 <code>pandas.read_csv()</code> 函数加载 CSV 数据。</li></ul></li><li><strong>数据预处理</strong>:<ul><li>将日期列转换为 <code>datetime</code> 类型并设为索引。</li><li>为所有记录添加前一天的开盘价和收盘价作为特征，并删除缺失值。</li></ul></li><li><strong>数据分割</strong>:<ul><li>使用 <code>train_test_split()</code>将数据集分为训练集和测试集。<code>test_size=0.2</code> 表示 20%的数据用于测试。</li></ul></li><li><strong>模型训练</strong>:<ul><li>使用 <code>LinearRegression</code> 构建线性回归模型。</li><li>调用 <code>fit()</code> 方法训练模型。</li></ul></li><li><strong>预测与评估</strong>:<ul><li>使用 <code>predict()</code> 方法对测试集进行预测。</li><li>计算均方误差（MSE）评估模型性能。</li></ul></li><li><strong>结果展示</strong>:<ul><li>将预测值和实际值显示出来，以比较模型的预测效果。</li></ul></li><li><strong>图形化展示</strong>:<ul><li>使用 <code>matplotlib</code>库绘制预测值与实际值的对比图，帮助你直观地了解模型的表现。</li></ul></li></ol><h3 id="注意事项">注意事项</h3><ul><li>你可以将 CSV文件替换为你自己的股票数据，确保文件的格式与示例相匹配。</li><li>该示例使用简单的线性回归模型，可以尝试其他高级模型（如LSTM、XGBoost）以提高预测效果。</li><li>数据中的噪声和不可预测性可能会影响预测准确性，在实际应用中需要小心处理。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>python</tag>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Python打包exe文件</title>
    <link href="/2024/10/03/2024-10-03-Python%E6%89%93%E5%8C%85exe%E6%96%87%E4%BB%B6/"/>
    <url>/2024/10/03/2024-10-03-Python%E6%89%93%E5%8C%85exe%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>将Python程序打包成可执行文件（.exe）是一种常见的方式，以便在不需要安装Python解释器的情况下在其他计算机上运行它。你可以使用一个称为PyInstaller的工具来完成这个任务。以下是一个简单的步骤，以将你的Python程序打包成.exe文件：</p><ol type="1"><li><p><strong>安装PyInstaller</strong>：</p><p>如果你还没有安装PyInstaller，可以使用以下命令进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pyinstaller<br></code></pre></td></tr></table></figure></li><li><p><strong>在命令行中使用PyInstaller</strong>：</p><p>打开命令行终端，并导航到你的Python程序所在的目录。然后运行以下命令，将你的Python程序打包成.exe文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pyinstaller --onefile your_program.py<br></code></pre></td></tr></table></figure><p>这里的<code>your_program.py</code>应该是你的Python程序的文件名。<code>--onefile</code>选项将生成一个独立的可执行文件，而不是一堆相关文件。</p></li><li><p><strong>等待打包完成</strong>：</p><p>PyInstaller将开始分析你的Python程序，并将其打包成可执行文件。这可能需要一些时间，具体取决于你的程序的复杂性。</p></li><li><p><strong>找到可执行文件</strong>：</p><p>打包完成后，你可以在<code>dist</code>目录下找到生成的可执行文件。这个文件的名称通常与你的Python脚本的名称相同，但没有.py扩展名。</p></li><li><p><strong>测试可执行文件</strong>：</p><p>运行生成的可执行文件，确保它可以正常工作。</p></li></ol><p>请注意，打包Python程序成可执行文件时，可能会导致一些文件路径和资源加载问题，因此确保你的程序中没有依赖于特定文件路径的硬编码。如果你的程序需要访问其他文件，确保这些文件与可执行文件位于同一目录或指定正确的路径。</p><p>这是一个简单的指南，帮助你将Python程序打包成可执行文件。如果你的程序包含了其他依赖项，你可能需要进一步配置PyInstaller以确保这些依赖项也包含在可执行文件中。不过，基本上，你应该能够使用上述步骤来创建一个可执行的.exe文件。</p><p>如果你的Python程序依赖于<code>tkinter</code>和<code>messagebox</code>模块，并且你已经使用PyInstaller将程序打包成可执行文件，通常情况下，这两个依赖应该已经包含在可执行文件中。<code>tkinter</code>是Python的标准库，因此不需要额外的步骤来包含它。<code>messagebox</code>模块通常也是<code>tkinter</code>的一部分。</p><p>当你运行生成的可执行文件时，它应该能够正常使用这两个模块。如果你在打包过程中遇到问题，可以尝试以下方法：</p><ol type="1"><li><p><strong>在Python中使用虚拟环境：</strong>确保在你的项目中使用了虚拟环境。这可以帮助隔离你的项目依赖于系统Python的情况。你可以使用<code>venv</code>模块创建虚拟环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m venv venv<br></code></pre></td></tr></table></figure><p>然后在虚拟环境中安装所需的依赖项，包括<code>tkinter</code>和<code>messagebox</code>。</p></li><li><p><strong>在PyInstaller中包含依赖项：</strong>如果PyInstaller没有正确地包含<code>tkinter</code>和<code>messagebox</code>模块，你可以尝试手动指定它们。在运行PyInstaller时，使用<code>--hidden-import</code>选项指定这些模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pyinstaller --onefile --hidden-import=tkinter --hidden-import=tkinter.messagebox your_program.py<br></code></pre></td></tr></table></figure><p>这将强制PyInstaller包含<code>tkinter</code>和<code>messagebox</code>模块。</p></li><li><p><strong>更新PyInstaller：</strong>确保你正在使用最新版本的PyInstaller。有时，更新到最新版本可以解决依赖项问题。</p></li><li><p><strong>检查打包日志：</strong>打包过程中，PyInstaller会生成一个详细的日志文件。查看这个日志文件以查找任何有关依赖项问题的信息。通常，日志文件位于<code>dist</code>目录下的<code>.spec</code>文件所指定的位置。</p></li></ol><p>根据你的具体情况，上述其中一种方法应该能够帮助你解决依赖项问题，并确保打包后的可执行文件可以正常运行。</p><p>出现终端窗口的问题通常是在使用PyInstaller或类似工具打包时的一个常见情况，特别是在Windows上。这是由于默认情况下，PyInstaller在运行时会创建一个控制台窗口，而不是一个纯粹的GUI窗口。</p><p>要解决这个问题，你可以尝试以下几种方法：</p><ol type="1"><li><p><strong>使用<code>--noconsole</code>选项：</strong>在运行PyInstaller时，可以使用<code>--noconsole</code>选项来阻止创建终端窗口。示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pyinstaller --onefile --noconsole your_program.py<br></code></pre></td></tr></table></figure><p>这将告诉PyInstaller创建一个没有终端窗口的可执行文件。请注意，这可能会导致在程序崩溃时无法查看错误消息。</p></li><li><p><strong>使用PyInstaller生成.spec文件：</strong>如果你的应用有复杂的依赖关系或特殊配置，你可以首先生成一个.spec文件，然后手动编辑该文件以指定<code>--noconsole</code>选项。然后使用.spec文件来构建你的可执行文件。</p><ol type="a"><li><p>生成.spec文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pyinstaller your_program.py --name your_app_name --onefile --windowed --noconsole --log-level=WARN<br></code></pre></td></tr></table></figure></li><li><p>编辑.spec文件：找到.spec文件，搜索<code>console=True</code>并将其更改为<code>console=False</code>。</p></li><li><p>使用.spec文件构建可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pyinstaller your_app_name.spec<br></code></pre></td></tr></table></figure></li></ol></li><li><p><strong>使用其他工具：</strong>除了PyInstaller，还有其他工具，如cx_Freeze和py2exe，可以用于将Python程序打包成可执行文件。你可以尝试使用其中之一，看看是否能够解决终端窗口问题。</p></li></ol><p>记得备份你的项目文件或.spec文件，以免不小心弄坏了。如果上述方法仍然不能解决问题，可以考虑使用其他工具或查看PyInstaller的文档和社区支持来获取更多帮助。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Python制作双色球游戏</title>
    <link href="/2024/10/03/2024-10-03-%E5%8F%8C%E8%89%B2%E7%90%83%E6%B8%B8%E6%88%8F/"/>
    <url>/2024/10/03/2024-10-03-%E5%8F%8C%E8%89%B2%E7%90%83%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<p>双色球模拟游戏----(Python)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choice<br><span class="hljs-comment"># from pathlib import Path</span><br><span class="hljs-comment"># 添加音乐模块</span><br><span class="hljs-keyword">import</span> pygame<br><span class="hljs-comment"># 统计历史出现次数，添加计数模块</span><br><span class="hljs-keyword">import</span> collections<br><br><span class="hljs-comment"># 添加音乐</span><br>url = <span class="hljs-string">&#x27;bg_jz.mp3&#x27;</span><br>pygame.mixer.init()<br>pygame.mixer.music.load(url)<br><br><br><span class="hljs-comment"># 统计号码出现次数函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">analyze_ball_appearances</span>(<span class="hljs-params">numbers</span>):<br>    <span class="hljs-comment"># numbers需要是一个列表</span><br>    <span class="hljs-comment"># Counter返回的是一个字典</span><br>    counter = collections.Counter(numbers)<br>    <span class="hljs-comment"># 通过值对字典排序</span><br>    sorted_keys = <span class="hljs-built_in">sorted</span>(<br>        counter.keys(), key=<span class="hljs-keyword">lambda</span> k: counter[k], reverse=<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment"># 遍历排序号的字典</span><br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> sorted_keys:<br>        value = counter[key]<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;key&#125;</span>出现了<span class="hljs-subst">&#123;value&#125;</span>次.&quot;</span>, end=<span class="hljs-string">&quot; &quot;</span>)<br><br>    max_value = <span class="hljs-built_in">max</span>(counter.values())  <span class="hljs-comment"># 寻找字典最大值</span><br>    min_value = <span class="hljs-built_in">min</span>(counter.values())  <span class="hljs-comment"># 寻找字典最小值</span><br>    max_keys = [key <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> counter.items() <span class="hljs-keyword">if</span> value ==<br>                max_value]  <span class="hljs-comment"># 找到对应最大值的键</span><br>    min_keys = [key <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> counter.items() <span class="hljs-keyword">if</span> value ==<br>                min_value]  <span class="hljs-comment"># 找到对应最小值的键</span><br>    <span class="hljs-built_in">print</span>()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---&quot;</span> * <span class="hljs-number">10</span>)<br>    <span class="hljs-comment"># path = Path(&quot;tongji.txt&quot;)</span><br>    <span class="hljs-comment"># xie = &#x27;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;出现次数最多的是：&quot;</span>)<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> max_keys:<br>        <span class="hljs-comment"># xie += f&quot;&#123;key&#125;出现了&#123;max_value&#125;次.&quot;</span><br>        <span class="hljs-comment"># path.write_text(f&#x27;&#123;xie&#125;&#x27;, encoding=&#x27;utf-8&#x27;)</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;key&#125;</span>出现了<span class="hljs-subst">&#123;max_value&#125;</span>次.&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;出现次数最少的是：&quot;</span>)<br>    <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> min_keys:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;key&#125;</span>出现了<span class="hljs-subst">&#123;min_value&#125;</span>次.&quot;</span>)<br><br><br><span class="hljs-comment"># 抽奖测试</span><br><span class="hljs-comment"># 双色球测试</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">shuangseqiu</span>(<span class="hljs-params">money: <span class="hljs-built_in">float</span> = <span class="hljs-number">2</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    玩法说明</span><br><span class="hljs-string">    输入6个红球(1-32)和一个蓝球号码(1-16)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 我的抽奖号码</span><br>    my_red = <span class="hljs-built_in">set</span>()<br>    my_bule = <span class="hljs-built_in">set</span>()<br>    <span class="hljs-comment"># 默认抽奖次数</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 中奖次数统计</span><br>    zj_01,zj_02,zj_03，zj_04，zj_05，zj_06 = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>    <span class="hljs-comment"># 统计红球出现的历史次数</span><br>    red_number = []<br>    <span class="hljs-comment"># 统计篮球出现的历史次数</span><br>    bule_number = []<br>    <span class="hljs-comment"># 红球列表</span><br>    lis = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>,<br>           <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">28</span>, <span class="hljs-number">29</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">32</span>]<br>    <span class="hljs-comment"># 蓝球列表</span><br>    lis_01 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>]<br>    <span class="hljs-comment"># 中奖号码</span><br>    hongqiu = <span class="hljs-built_in">set</span>()<br>    lanqiu = <span class="hljs-built_in">set</span>()<br>    <br>    <span class="hljs-built_in">print</span>(<br>        <span class="hljs-string">f&quot;我们设置了6个等级的奖项,分别是:一等奖<span class="hljs-subst">&#123;money * (<span class="hljs-number">1</span> + <span class="hljs-number">49999</span>)&#125;</span>元,二等奖<span class="hljs-subst">&#123;money * (<span class="hljs-number">1</span> + <span class="hljs-number">19999</span>)&#125;</span>元,三等奖<span class="hljs-subst">&#123;money * (<span class="hljs-number">1</span> + <span class="hljs-number">1499</span>)&#125;</span>元,四等奖<span class="hljs-subst">&#123;money * (<span class="hljs-number">1</span> + <span class="hljs-number">99</span>)&#125;</span>元,五等奖<span class="hljs-subst">&#123;money * (<span class="hljs-number">1</span> + <span class="hljs-number">4</span>)&#125;</span>元,六等奖<span class="hljs-subst">&#123;money * (<span class="hljs-number">1</span> + <span class="hljs-number">1.5</span>)&#125;</span>元&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;玩一次的费用是&#123;:.1f&#125;元钱&quot;</span>.<span class="hljs-built_in">format</span>(money))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;双色球娱乐，请按规则输入号码&quot;</span>)<br>    <span class="hljs-keyword">try</span>:<br>        q = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请先设置要玩几个红球的游戏:&quot;</span>))<br>    <span class="hljs-keyword">except</span> ValueError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你输入有误或没有输入数字, 默认设置了6个球&quot;</span>)<br>        q = <span class="hljs-number">6</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> q &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> q &gt; <span class="hljs-number">6</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;只能玩1至6个球的游戏&quot;</span>)<br>            <span class="hljs-keyword">try</span>:<br>                q = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请先设置要玩几个红球的游戏:&quot;</span>))<br>            <span class="hljs-keyword">except</span> ValueError:<br>                q = <span class="hljs-number">6</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;你输入有误或没有输入数字, 默认设置了<span class="hljs-subst">&#123;q&#125;</span>个球&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-comment"># 循环输入红球并添加控制</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(hongqiu) != q:<br>        <span class="hljs-keyword">try</span>:<br>            red = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">f&quot;请输入第<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(hongqiu) + <span class="hljs-number">1</span>&#125;</span>个红球(1-32)号码：&quot;</span>))<br>        <span class="hljs-keyword">except</span> ValueError:<br>            red = choice(lis)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;你输入有误或没有输入数字, 随机选择了: <span class="hljs-subst">&#123;red&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">if</span> red <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> hongqiu <span class="hljs-keyword">and</span> <span class="hljs-number">32</span> &gt;= red &gt;= <span class="hljs-number">1</span>:<br>            hongqiu.add(red)<br>            lis.remove(red)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你输入了错误的号码，请重新输入.&quot;</span>)<br>    <span class="hljs-comment"># 输入蓝球并添加控制</span><br>    <span class="hljs-keyword">try</span>:<br>        bule_01 = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入蓝球(1-16)号码：&quot;</span>))<br>    <span class="hljs-keyword">except</span> ValueError:<br>        bule_01 = choice(lis_01)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;你输入有误或没有输入数字, 随机选择了: <span class="hljs-subst">&#123;bule_01&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">if</span> bule_01 &gt; <span class="hljs-number">16</span> <span class="hljs-keyword">or</span> bule_01 &lt; <span class="hljs-number">1</span>:<br>            bule_01 = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;超出范围了，请重新输入蓝球(1-16)号码：&quot;</span>))<br>        <span class="hljs-keyword">else</span>:<br>            lanqiu.add(bule_01)<br>            lis_01.remove(bule_01)<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">try</span>:<br>        n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入抽多少次奖:&quot;</span>))<br>    <span class="hljs-keyword">except</span> ValueError:<br>        n = <span class="hljs-number">10</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;你输入有误或没有输入数字, 默认是<span class="hljs-subst">&#123;n&#125;</span>次.&quot;</span>)<br><br>    <span class="hljs-comment"># 循环抽奖</span><br>    <span class="hljs-keyword">while</span> my_bule != lanqiu <span class="hljs-keyword">or</span> my_red != hongqiu <span class="hljs-keyword">or</span> n &gt;= count:<br>        list_red = []<br>        list_bule = []<br>        lis = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>, <span class="hljs-number">17</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>,<br>               <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>, <span class="hljs-number">24</span>, <span class="hljs-number">25</span>, <span class="hljs-number">26</span>, <span class="hljs-number">27</span>, <span class="hljs-number">28</span>, <span class="hljs-number">29</span>, <span class="hljs-number">30</span>, <span class="hljs-number">31</span>, <span class="hljs-number">32</span>]<br>        lis_01 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>, <span class="hljs-number">16</span>]<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;你买的号码是---红球：<span class="hljs-subst">&#123;hongqiu&#125;</span> 蓝球：<span class="hljs-subst">&#123;lanqiu&#125;</span>&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;这是第<span class="hljs-subst">&#123;count + <span class="hljs-number">1</span>&#125;</span>次。&#x27;</span>)<br>        <span class="hljs-comment"># 红球</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(hongqiu)):<br>            num_red = choice(lis[:<span class="hljs-built_in">len</span>(lis) + <span class="hljs-number">1</span> - i])<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>个是:&#x27;</span>, num_red)<br>            list_red.append(num_red)<br>            red_number.append(num_red)<br>            lis.remove(num_red)<br>        <span class="hljs-comment"># 蓝球</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lanqiu)):<br>            num_bule = choice(lis_01[:<span class="hljs-built_in">len</span>(lis_01) + <span class="hljs-number">1</span> - i])<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;蓝球是:&#x27;</span>, num_bule)<br>            list_bule.append(num_bule)<br>            bule_number.append(num_bule)<br>            lis_01.remove(num_bule)<br>        <span class="hljs-comment"># 得到的号码列表赋值给集合</span><br>        my_red = <span class="hljs-built_in">set</span>(list_red)<br>        my_bule = <span class="hljs-built_in">set</span>(list_bule)<br>        <span class="hljs-comment"># 打印彩票号码</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开奖号码是：红球 &quot;</span>, end=<span class="hljs-string">&quot;&quot;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> my_red:<br>            <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;蓝球 &quot;</span>, end=<span class="hljs-string">&quot;&quot;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> my_bule:<br>            <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot; &quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\n抽了<span class="hljs-subst">&#123;count + <span class="hljs-number">1</span>&#125;</span>次奖了&quot;</span>)<br>        <span class="hljs-comment"># 判断中奖与否</span><br>        <span class="hljs-keyword">if</span> my_bule != lanqiu <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(my_red.intersection(hongqiu)) &lt;= <span class="hljs-number">4</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n很遗憾,你没有中奖&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> my_bule == lanqiu:<br>                zj_06 += <span class="hljs-number">1</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n恭喜你中了六等奖,奖金&#123;:.1f&#125;元人民币&quot;</span>.<span class="hljs-built_in">format</span>((money * (<span class="hljs-number">1</span> + <span class="hljs-number">1.5</span>))))<br>                <span class="hljs-comment"># 通过intersection()方法查找我的号码和开奖号码的--并集</span><br>            <span class="hljs-keyword">if</span> my_bule == lanqiu <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(my_red.intersection(hongqiu)) &gt;= <span class="hljs-number">3</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(my_red.intersection(hongqiu)) &gt;= <span class="hljs-number">4</span>:<br>                zj_05 += <span class="hljs-number">1</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n恭喜你中了五等奖,奖金&#123;:.1f&#125;元人民币&quot;</span>.<span class="hljs-built_in">format</span>((money * (<span class="hljs-number">1</span> + <span class="hljs-number">4</span>))))<br>                <span class="hljs-keyword">if</span> my_bule == lanqiu <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(my_red.intersection(hongqiu)) &gt;= <span class="hljs-number">4</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">len</span>(<br>                        my_red.intersection(hongqiu)) &gt;= <span class="hljs-number">5</span>:<br>                    zj_04 += <span class="hljs-number">1</span><br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n恭喜你中了四等奖,奖金&#123;:.1f&#125;元人民币&quot;</span>.<span class="hljs-built_in">format</span>((money * (<span class="hljs-number">1</span> + <span class="hljs-number">99</span>))))<br>                    <span class="hljs-keyword">if</span> my_bule == lanqiu <span class="hljs-keyword">and</span> <span class="hljs-built_in">len</span>(my_red.intersection(hongqiu)) &gt;= <span class="hljs-number">5</span>:<br>                        zj_03 += <span class="hljs-number">1</span><br>                        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n恭喜你中了三等奖,奖金&#123;:.1f&#125;元人民币&quot;</span>.<span class="hljs-built_in">format</span>(<br>                            (money * (<span class="hljs-number">1</span> + <span class="hljs-number">1499</span>))))<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(my_red.intersection(hongqiu)) &gt;= <span class="hljs-number">6</span>:<br>                zj_02 += <span class="hljs-number">1</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n恭喜你中了二等奖,奖金&#123;:.1f&#125;元人民币&quot;</span>.<span class="hljs-built_in">format</span>((money * (<span class="hljs-number">1</span> + <span class="hljs-number">19999</span>))))<br>                <span class="hljs-keyword">if</span> my_bule == lanqiu:<br>                    zj_01 += <span class="hljs-number">1</span><br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n恭喜你中了一等奖,奖金&#123;:.1f&#125;元人民币&quot;</span>.<span class="hljs-built_in">format</span>(<br>                        (money * (<span class="hljs-number">1</span> + <span class="hljs-number">49999</span>))))<br>        count += <span class="hljs-number">1</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---&quot;</span> * <span class="hljs-number">10</span>)<br>        <br>        <span class="hljs-comment"># 判断是否达到游玩次数</span><br>        <span class="hljs-keyword">if</span> count &gt;= n:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;红球历史出现次数&quot;</span>)<br>            analyze_ball_appearances(red_number)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---&quot;</span> * <span class="hljs-number">10</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;蓝球历史出现次数&quot;</span>)<br>            analyze_ball_appearances(bule_number)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---&quot;</span> * <span class="hljs-number">10</span>)<br><br>            <span class="hljs-built_in">print</span>(<br>                <span class="hljs-string">f&quot;你总共的中奖次数为：\n一等奖:<span class="hljs-subst">&#123;zj_01&#125;</span>次\n二等奖:<span class="hljs-subst">&#123;zj_02&#125;</span>次\n三等奖:<span class="hljs-subst">&#123;zj_03&#125;</span>次\n四等奖:<span class="hljs-subst">&#123;zj_04&#125;</span>次\n五等奖:<span class="hljs-subst">&#123;zj_05&#125;</span>次\n六等奖:<span class="hljs-subst">&#123;zj_06&#125;</span>次&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;你总共用了&#123;:.1f&#125;元钱。&quot;</span>.<span class="hljs-built_in">format</span>(n * money))<br>            <span class="hljs-built_in">print</span>(<br>                <span class="hljs-string">f&quot;合计奖金为:<span class="hljs-subst">&#123;zj_01 * (money * (<span class="hljs-number">1</span> + <span class="hljs-number">49999</span>)) + zj_02 * (money * (<span class="hljs-number">1</span> + <span class="hljs-number">19999</span>)) + zj_03 * (money * (<span class="hljs-number">1</span> + <span class="hljs-number">1499</span>)) + zj_04 * (money * (<span class="hljs-number">1</span> + <span class="hljs-number">99</span>)) + zj_05 * (money * (<span class="hljs-number">1</span> + <span class="hljs-number">4</span>)) + zj_06 * (money * (<span class="hljs-number">1</span> + <span class="hljs-number">1.5</span>))&#125;</span>元.&quot;</span>)<br><br>            <span class="hljs-keyword">return</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lianxu</span>():<br>    shuangseqiu()<br>    y = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;\n退出输入(q)：&quot;</span>)<br>    <span class="hljs-keyword">if</span> y == <span class="hljs-string">&quot;q&quot;</span>:<br>        <span class="hljs-comment"># 停止播放背景音乐</span><br>        pygame.mixer.music.stop()<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">else</span>:<br>        lianxu()<br><br><br><span class="hljs-comment"># 播放背景音乐 -1 代表无线循环</span><br>pygame.mixer.music.play(loops=-<span class="hljs-number">1</span>)<br>lianxu()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Python获取网络数据</title>
    <link href="/2024/10/03/2024-10-03-%E7%94%A8Python%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90-1/"/>
    <url>/2024/10/03/2024-10-03-%E7%94%A8Python%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90-1/</url>
    
    <content type="html"><![CDATA[<h2 id="用python获取网络数据">用Python获取网络数据</h2><p>网络数据采集是 Python语言非常擅长的领域，上节课我们讲到，实现网络数据采集的程序通常称之为网络爬虫或蜘蛛程序。即便是在大数据时代，数据对于中小企业来说仍然是硬伤和短板，有些数据需要通过开放或付费的数据接口来获得，其他的行业数据和竞对数据则必须要通过网络数据采集的方式来获得。不管使用哪种方式获取网络数据资源，Python语言都是非常好的选择，因为 Python的标准库和三方库都对网络数据采集提供了良好的支持。</p><h3 id="requests库">requests库</h3><p>要使用 Python 获取网络数据，我们推荐大家使用名为<code>requests</code>的三方库，这个库我们在之前的课程中其实已经使用过了。按照官方网站的解释，<code>requests</code>是基于Python 标准库进行了封装，简化了通过 HTTP 或 HTTPS访问网络资源的操作。上课我们提到过，HTTP是一个请求响应式的协议，当我们在浏览器中输入正确的 <ahref="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/What_is_a_URL">URL</a>（通常也称为网址）并按下Enter 键时，我们就向网络上的 <ahref="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/What_is_a_web_server">Web服务器</a>发送了一个 HTTP 请求，服务器在收到请求后会给我们一个 HTTP响应。在 Chrome浏览器中的菜单中打开“开发者工具”切换到“Network”选项卡就能够查看 HTTP请求和响应到底是什么样子的，如下图所示。</p><p><imgsrc="https://gitee.com/jackfrued/mypic/raw/master/20210822093434.png" /></p><p>通过<code>requests</code>库，我们可以让 Python 程序向浏览器一样向 Web服务器发起请求，并接收服务器返回的响应，从响应中我们就可以提取出想要的数据。浏览器呈现给我们的网页是用<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML">HTML</a>编写的，浏览器相当于是 HTML 的解释器环境，我们看到的网页中的内容都包含在HTML 的标签中。在获取到 HTML代码后，就可以从标签的属性或标签体中提取内容。下面例子演示了如何获取网页HTML代码，我们通过<code>requests</code>库的<code>get</code>函数，获取了搜狐首页的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> requests<br><br>resp = requests.get(<span class="hljs-string">&#x27;https://www.sohu.com/&#x27;</span>)<br><span class="hljs-keyword">if</span> resp.status_code == <span class="hljs-number">200</span>:<br>    <span class="hljs-built_in">print</span>(resp.text)<br></code></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：上面代码中的变量<code>resp</code>是一个<code>Response</code>对象（<code>requests</code>库封装的类型），通过该对象的<code>status_code</code>属性可以获取响应状态码，而该对象的<code>text</code>属性可以帮我们获取到页面的HTML 代码。</p></blockquote><p>由于<code>Response</code>对象的<code>text</code>是一个字符串，所以我们可以利用之前讲过的正则表达式的知识，从页面的HTML 代码中提取新闻的标题和链接，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> re<br><br><span class="hljs-keyword">import</span> requests<br><br>pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;a.*?href=&quot;(.*?)&quot;.*?title=&quot;(.*?)&quot;.*?&gt;&#x27;</span>)<br>resp = requests.get(<span class="hljs-string">&#x27;https://www.sohu.com/&#x27;</span>)<br><span class="hljs-keyword">if</span> resp.status_code == <span class="hljs-number">200</span>:<br>    all_matches = pattern.findall(resp.text)<br>    <span class="hljs-keyword">for</span> href, title <span class="hljs-keyword">in</span> all_matches:<br>        <span class="hljs-built_in">print</span>(href)<br>        <span class="hljs-built_in">print</span>(title)<br></code></pre></td></tr></table></figure><p>除了文本内容，我们也可以使用<code>requests</code>库通过 URL获取二进制资源。下面的例子演示了如何获取百度 Logo并保存到名为<code>baidu.png</code>的本地文件中。可以在百度的首页上右键点击百度Logo，并通过“复制图片地址”菜单项获取图片的URL。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> requests<br><br>resp = requests.get(<span class="hljs-string">&#x27;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&#x27;</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;baidu.png&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    file.write(resp.content)<br></code></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：<code>Response</code>对象的<code>content</code>属性可以获得服务器响应的二进制数据。</p></blockquote><p><code>requests</code>库非常好用而且功能上也比较强大和完整，具体的内容我们在使用的过程中为大家一点点剖析。想解锁关于<code>requests</code>库更多的知识，可以阅读它的<ahref="https://docs.python-requests.org/zh_CN/latest/">官方文档</a>。</p><h3 id="编写爬虫代码">编写爬虫代码</h3><p>接下来，我们以“豆瓣电影”为例，为大家讲解如何编写爬虫代码。按照上面提供的方法，我们先使用<code>requests</code>获取到网页的HTML代码，然后将整个代码看成一个长字符串，这样我们就可以使用正则表达式的捕获组从字符串提取我们需要的内容。下面的代码演示了如何从<ahref="https://movie.douban.com/">豆瓣电影</a>获取排前250名的电影的名称。<ahref="https://movie.douban.com/top250">豆瓣电影Top250</a>的页面结构和对应代码如下图所示，可以看出，每页共展示了25部电影，如果要获取到Top250 数据，我们共需要访问10个页面，对应的地址是<ahref="https://movie.douban.com/top250?start=xxx"class="uri">https://movie.douban.com/top250?start=xxx</a>，这里的<code>xxx</code>如果为<code>0</code>就是第一页，如果<code>xxx</code>的值是<code>100</code>，那么我们可以访问到第五页。为了代码简单易读，我们只获取电影的标题和评分。</p><p><imgsrc="https://gitee.com/jackfrued/mypic/raw/master/20210822093447.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>):<br>    resp = requests.get(<br>        url=<span class="hljs-string">f&#x27;https://movie.douban.com/top250?start=<span class="hljs-subst">&#123;(page - <span class="hljs-number">1</span>) * <span class="hljs-number">25</span>&#125;</span>&#x27;</span>,<br>        <span class="hljs-comment"># 如果不设置HTTP请求头中的User-Agent，豆瓣会检测出不是浏览器而阻止我们的请求。</span><br>        <span class="hljs-comment"># 通过get函数的headers参数设置User-Agent的值，具体的值可以在浏览器的开发者工具查看到。</span><br>        <span class="hljs-comment"># 用爬虫访问大部分网站时，将爬虫伪装成来自浏览器的请求都是非常重要的一步。</span><br>        headers=&#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36&#x27;</span>&#125;<br>    )<br>    <span class="hljs-comment"># 通过正则表达式获取class属性为title且标签体不以&amp;开头的span标签并用捕获组提取标签内容</span><br>    pattern1 = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;span class=&quot;title&quot;&gt;([^&amp;]*?)&lt;/span&gt;&#x27;</span>)<br>    titles = pattern1.findall(resp.text)<br>    <span class="hljs-comment"># 通过正则表达式获取class属性为rating_num的span标签并用捕获组提取标签内容</span><br>    pattern2 = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;span class=&quot;rating_num&quot;.*?&gt;(.*?)&lt;/span&gt;&#x27;</span>)<br>    ranks = pattern2.findall(resp.text)<br>    <span class="hljs-comment"># 使用zip压缩两个列表，循环遍历所有的电影标题和评分</span><br>    <span class="hljs-keyword">for</span> title, rank <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(titles, ranks):<br>        <span class="hljs-built_in">print</span>(title, rank)<br>    <span class="hljs-comment"># 随机休眠1-5秒，避免爬取页面过于频繁</span><br>    time.sleep(random.random() * <span class="hljs-number">4</span> + <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：通过分析豆瓣网的robots协议，我们发现豆瓣网并不拒绝百度爬虫获取它的数据，因此我们也可以将爬虫伪装成百度的爬虫，将<code>get</code>函数的<code>headers</code>参数修改为：<code>headers=&#123;'User-Agent': 'BaiduSpider'&#125;</code>。</p></blockquote><h3 id="使用-ip-代理">使用 IP 代理</h3><p>让爬虫程序隐匿自己的身份对编写爬虫程序来说是比较重要的，很多网站对爬虫都比较反感的，因为爬虫会耗费掉它们很多的网络带宽并制造很多无效的流量。要隐匿身份通常需要使用<strong>商业IP代理</strong>（如蘑菇代理、芝麻代理、快代理等），让被爬取的网站无法获取爬虫程序来源的真实IP 地址，也就无法简单的通过 IP 地址对爬虫程序进行封禁。</p><p>下面以<ahref="http://www.moguproxy.com/">蘑菇代理</a>为例，为大家讲解商业 IP代理的使用方法。首先需要在该网站注册一个账号，注册账号后就可以<ahref="http://www.moguproxy.com/buy">购买</a>相应的套餐来获得商业 IP代理。作为商业用途，建议大家购买不限量套餐，这样可以根据实际需要获取足够多的代理IP地址；作为学习用途，可以购买包时套餐或根据自己的需求来决定。蘑菇代理提供了两种接入代理的方式，分别是API 私密代理和 HTTP 隧道代理，前者是通过请求蘑菇代理的 API接口获取代理服务器地址，后者是直接使用统一的入口（蘑菇代理提供的域名）进行接入。</p><p><img src="https://gitee.com/jackfrued/mypic/raw/master/20210829080647.png" width="75%"></p><p>下面，我们以HTTP隧道代理为例，为大家讲解接入 IP代理的方式，大家也可以直接参考蘑菇代理官网提供的代码来为爬虫设置代理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> requests<br><br>APP_KEY = <span class="hljs-string">&#x27;Wnp******************************XFx&#x27;</span><br>PROXY_HOST = <span class="hljs-string">&#x27;secondtransfer.moguproxy.com:9001&#x27;</span><br><br><span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>):<br>    resp = requests.get(<br>        url=<span class="hljs-string">f&#x27;https://movie.douban.com/top250?start=<span class="hljs-subst">&#123;(page - <span class="hljs-number">1</span>) * <span class="hljs-number">25</span>&#125;</span>&#x27;</span>,<br>        <span class="hljs-comment"># 需要在HTTP请求头设置代理的身份认证方式</span><br>        headers=&#123;<br>            <span class="hljs-string">&#x27;Proxy-Authorization&#x27;</span>: <span class="hljs-string">f&#x27;Basic <span class="hljs-subst">&#123;APP_KEY&#125;</span>&#x27;</span>,<br>            <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36&#x27;</span>,<br>            <span class="hljs-string">&#x27;Accept-Language&#x27;</span>: <span class="hljs-string">&#x27;zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4&#x27;</span><br>        &#125;,<br>        <span class="hljs-comment"># 设置代理服务器</span><br>        proxies=&#123;<br>            <span class="hljs-string">&#x27;http&#x27;</span>: <span class="hljs-string">f&#x27;http://<span class="hljs-subst">&#123;PROXY_HOST&#125;</span>&#x27;</span>,<br>            <span class="hljs-string">&#x27;https&#x27;</span>: <span class="hljs-string">f&#x27;https://<span class="hljs-subst">&#123;PROXY_HOST&#125;</span>&#x27;</span><br>        &#125;,<br>        verify=<span class="hljs-literal">False</span><br>    )<br>    pattern1 = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;span class=&quot;title&quot;&gt;([^&amp;]*?)&lt;/span&gt;&#x27;</span>)<br>    titles = pattern1.findall(resp.text)<br>    pattern2 = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;span class=&quot;rating_num&quot;.*?&gt;(.*?)&lt;/span&gt;&#x27;</span>)<br>    ranks = pattern2.findall(resp.text)<br>    <span class="hljs-keyword">for</span> title, rank <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(titles, ranks):<br>        <span class="hljs-built_in">print</span>(title, rank)<br></code></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：上面的代码需要修改<code>APP_KEY</code>为自己创建的订单对应的<code>Appkey</code>值，这个值可以在用户中心用户订单中查看到。蘑菇代理提供了免费的API 代理和 HTTP隧道代理试用，但是试用的代理接通率不能保证，建议大家还是直接购买一个在自己支付能力范围内的代理服务来体验。</p></blockquote><h3 id="简单的总结">简单的总结</h3><p>Python 语言能做的事情真的很多，就网络数据采集这一项而言，Python几乎是一枝独秀的，大量的企业和个人都在使用 Python从网络上获取自己需要的数据，这可能也是你将来日常工作的一部分。另外，用编写正则表达式的方式从网页中提取内容虽然可行，但是写出一个能够满足需求的正则表达式本身也不是件容易的事情，这一点对于新手来说尤为明显。在下一节课中，我们将会为大家介绍另外两种从页面中提取数据的方法，虽然从性能上来讲，它们可能不如正则表达式，但是却降低了编码的复杂性，相信大家会喜欢上它们的。</p>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Python解析HTML页面</title>
    <link href="/2024/10/03/2024-10-03-%E7%94%A8Python%E8%A7%A3%E6%9E%90HTML%E9%A1%B5%E9%9D%A2-2/"/>
    <url>/2024/10/03/2024-10-03-%E7%94%A8Python%E8%A7%A3%E6%9E%90HTML%E9%A1%B5%E9%9D%A2-2/</url>
    
    <content type="html"><![CDATA[<h2 id="用python解析html页面">用Python解析HTML页面</h2><p>在前面的课程中，我们讲到了使用<code>request</code>三方库获取网络资源，还介绍了一些前端的基础知识。接下来，我们继续探索如何解析HTML代码，从页面中提取出有用的信息。之前，我们尝试过用正则表达式的捕获组操作提取页面内容，但是写出一个正确的正则表达式也是一件让人头疼的事情。为了解决这个问题，我们得先深入的了解一下HTML 页面的结构，并在此基础上研究另外的解析页面的方法。</p><h3 id="html-页面的结构">HTML 页面的结构</h3><p>我们在浏览器中打开任意一个网站，然后通过鼠标右键菜单，选择“显示网页源代码”菜单项，就可以看到网页对应的HTML 代码。</p><figure><imgsrc="https://gitee.com/jackfrued/mypic/raw/master/20210822094218.png"alt="image-20210822094218269" /><figcaption aria-hidden="true">image-20210822094218269</figcaption></figure><p>代码的第<code>1</code>行是文档类型声明，第<code>2</code>行的<code>&lt;html&gt;</code>标签是整个页面根标签的开始标签，最后一行是根标签的结束标签<code>&lt;/html&gt;</code>。<code>&lt;html&gt;</code>标签下面有两个子标签<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>，放在<code>&lt;body&gt;</code>标签下的内容会显示在浏览器窗口中，这部分内容是网页的主体；放在<code>&lt;head&gt;</code>标签下的内容不会显示在浏览器窗口中，但是却包含了页面重要的元信息，通常称之为网页的头部。HTML页面大致的代码结构如下所示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 页面的元信息，如字符编码、标题、关键字、媒体查询等 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 页面的主体，显示在浏览器窗口中的内容 --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>标签、层叠样式表（CSS）、JavaScript 是构成 HTML页面的三要素，其中标签用来承载页面要显示的内容，CSS 负责对页面的渲染，而JavaScript 用来控制页面的交互式行为。要实现 HTML 页面的解析，可以使用XPath 的语法，它原本是 XML 的一种查询语法，可以根据 HTML标签的层次结构提取标签中的内容或标签属性；此外，也可以使用 CSS选择器来定位页面元素，就跟用 CSS 渲染页面元素是同样的道理。</p><h3 id="xpath-解析">XPath 解析</h3><p>XPath 是在 XML（eXtensible MarkupLanguage）文档中查找信息的一种语法，XML 跟 HTML类似也是一种用标签承载数据的标签语言，不同之处在于 XML的标签是可扩展的，可以自定义的，而且 XML 对语法有更严格的要求。XPath使用路径表达式来选取 XML文档中的节点或者节点集，这里所说的节点包括元素、属性、文本、命名空间、处理指令、注释、根节点等。下面我们通过一个例子来说明如何使用XPath 对页面进行解析。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bookstore</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;eng&quot;</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>29.99<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh&quot;</span>&gt;</span>Learning XML<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>39.95<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bookstore</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对于上面的 XML 文件，我们可以用如下所示的 XPath语法获取文档中的节点。</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td><code>/bookstore</code></td><td>选取根元素 bookstore。<strong>注意</strong>：假如路径起始于正斜杠( /)，则此路径始终代表到某元素的绝对路径！</td></tr><tr><td><code>//book</code></td><td>选取所有 book 子元素，而不管它们在文档中的位置。</td></tr><tr><td><code>//@lang</code></td><td>选取名为 lang 的所有属性。</td></tr><tr><td><code>/bookstore/book[1]</code></td><td>选取属于 bookstore 子元素的第一个 book 元素。</td></tr><tr><td><code>/bookstore/book[last()]</code></td><td>选取属于 bookstore 子元素的最后一个 book 元素。</td></tr><tr><td><code>/bookstore/book[last()-1]</code></td><td>选取属于 bookstore 子元素的倒数第二个 book 元素。</td></tr><tr><td><code>/bookstore/book[position()&lt;3]</code></td><td>选取最前面的两个属于 bookstore 元素的子元素的 book 元素。</td></tr><tr><td><code>//title[@lang]</code></td><td>选取所有拥有名为 lang 的属性的 title 元素。</td></tr><tr><td><code>//title[@lang='eng']</code></td><td>选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。</td></tr><tr><td><code>/bookstore/book[price&gt;35.00]</code></td><td>选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于35.00。</td></tr><tr><td><code>/bookstore/book[price&gt;35.00]/title</code></td><td>选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price元素的值须大于 35.00。</td></tr></tbody></table><p>XPath还支持通配符用法，如下所示。</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td><code>/bookstore/*</code></td><td>选取 bookstore 元素的所有子元素。</td></tr><tr><td><code>//*</code></td><td>选取文档中的所有元素。</td></tr><tr><td><code>//title[@*]</code></td><td>选取所有带有属性的 title 元素。</td></tr></tbody></table><p>如果要选取多个节点，可以使用如下所示的方法。</p><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td><code>//book/title \| //book/price</code></td><td>选取 book 元素的所有 title 和 price 元素。</td></tr><tr><td><code>//title \| //price</code></td><td>选取文档中的所有 title 和 price 元素。</td></tr><tr><td><code>/bookstore/book/title \| //price</code></td><td>选取属于 bookstore 元素的 book 元素的所有 title元素，以及文档中所有的 price 元素。</td></tr></tbody></table><blockquote><p><strong>说明</strong>：上面的例子来自于“菜鸟教程”网站上的 <ahref="https://www.runoob.com/xpath/xpath-tutorial.html">XPath教程</a>，有兴趣的读者可以自行阅读原文。</p></blockquote><p>当然，如果不理解或不熟悉 XPath语法，可以在浏览器的开发者工具中按照如下所示的方法查看元素的 XPath语法，下图是在 Chrome浏览器的开发者工具中查看豆瓣网电影详情信息中影片标题的 XPath 语法。</p><p><imgsrc="https://gitee.com/jackfrued/mypic/raw/master/20210822093707.png" /></p><p>实现 XPath 解析需要三方库<code>lxml</code>的支持，可以使用下面的命令安装<code>lxml</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">pip install lxml<br></code></pre></td></tr></table></figure><p>下面我们用 XPath 解析方式改写之前获取豆瓣电影Top250的代码，如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>):<br>    resp = requests.get(<br>        url=<span class="hljs-string">f&#x27;https://movie.douban.com/top250?start=<span class="hljs-subst">&#123;(page - <span class="hljs-number">1</span>) * <span class="hljs-number">25</span>&#125;</span>&#x27;</span>,<br>        headers=&#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;BaiduSpider&#x27;</span>&#125;<br>    )<br>    tree = etree.HTML(resp.text)<br>    <span class="hljs-comment"># 通过XPath语法从页面中提取电影标题</span><br>    title_spans = tree.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;content&quot;]/div/div[1]/ol/li/div/div[2]/div[1]/a/span[1]&#x27;</span>)<br>    <span class="hljs-comment"># 通过XPath语法从页面中提取电影评分</span><br>    rank_spans = tree.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;content&quot;]/div/div[1]/ol/li[1]/div/div[2]/div[2]/div/span[2]&#x27;</span>)<br>    <span class="hljs-keyword">for</span> title_span, rank_span <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(title_spans, rank_spans):<br>        <span class="hljs-built_in">print</span>(title_span.text, rank_span.text)<br></code></pre></td></tr></table></figure><h3 id="css-选择器解析">CSS 选择器解析</h3><p>对于熟悉 CSS 选择器和 JavaScript 的开发者来说，通过 CSS选择器获取页面元素可能是更为简单的选择，因为浏览器中运行的 JavaScript本身就可以<code>document</code>对象的<code>querySelector()</code>和<code>querySelectorAll()</code>方法基于CSS 选择器获取页面元素。在 Python中，我们可以利用三方库<code>beautifulsoup4</code>或<code>pyquery</code>来做同样的事情。BeautifulSoup 可以用来解析 HTML 和 XML文档，修复含有未闭合标签等错误的文档，通过为待解析的页面在内存中创建一棵树结构，实现对从页面中提取数据操作的封装。可以用下面的命令来安装Beautiful Soup。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Python">pip install beautifulsoup4<br></code></pre></td></tr></table></figure><p>下面是使用<code>bs4</code>改写的获取豆瓣电影Top250电影名称的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">import</span> bs4<br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>):<br>    resp = requests.get(<br>        url=<span class="hljs-string">f&#x27;https://movie.douban.com/top250?start=<span class="hljs-subst">&#123;(page - <span class="hljs-number">1</span>) * <span class="hljs-number">25</span>&#125;</span>&#x27;</span>,<br>        headers=&#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;BaiduSpider&#x27;</span>&#125;<br>    )<br>    <span class="hljs-comment"># 创建BeautifulSoup对象</span><br>    soup = bs4.BeautifulSoup(resp.text, <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>    <span class="hljs-comment"># 通过CSS选择器从页面中提取包含电影标题的span标签</span><br>    title_spans = soup.select(<span class="hljs-string">&#x27;div.info &gt; div.hd &gt; a &gt; span:nth-child(1)&#x27;</span>)<br>    <span class="hljs-comment"># 通过CSS选择器从页面中提取包含电影评分的span标签</span><br>    rank_spans = soup.select(<span class="hljs-string">&#x27;div.info &gt; div.bd &gt; div &gt; span.rating_num&#x27;</span>)<br>    <span class="hljs-keyword">for</span> title_span, rank_span <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(title_spans, rank_spans):<br>        <span class="hljs-built_in">print</span>(title_span.text, rank_span.text)<br></code></pre></td></tr></table></figure><p>关于 BeautifulSoup 更多的知识，可以参考它的<ahref="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/">官方文档</a>。</p><h3 id="简单的总结">简单的总结</h3><p>下面我们对三种解析方式做一个简单比较。</p><table><thead><tr><th>解析方式</th><th>对应的模块</th><th>速度</th><th>使用难度</th></tr></thead><tbody><tr><td>正则表达式解析</td><td><code>re</code></td><td>快</td><td>困难</td></tr><tr><td>XPath 解析</td><td><code>lxml</code></td><td>快</td><td>一般</td></tr><tr><td>CSS 选择器解析</td><td><code>bs4</code>或<code>pyquery</code></td><td>不确定</td><td>简单</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>计算机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
